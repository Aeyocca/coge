package CoGe::Builder::Methylation::Bismark;

use v5.14;
use strict;
use warnings;

use Data::Dumper qw(Dumper);
use File::Spec::Functions qw(catdir catfile);
use CoGe::Accessory::Utils qw(to_filename);
use CoGe::Accessory::Web qw(get_defaults);
use CoGe::Accessory::Workflow;
use CoGe::Core::Storage qw(get_genome_file get_workflow_paths);
use CoGe::Core::Metadata qw(to_annotations);
use CoGe::Builder::CommonTasks;

our $CONF = CoGe::Accessory::Web::get_defaults();

BEGIN {
    use vars qw ($VERSION @ISA @EXPORT @EXPORT_OK);
    require Exporter;

    $VERSION = 0.1;
    @ISA     = qw(Exporter);
    @EXPORT  = qw(build);
}

sub build {
    my $opts = shift;
    my $genome = $opts->{genome};
    my $user = $opts->{user};
    my $input_file = $opts->{input_file}; # path to bam file
    my $metadata = $opts->{metadata};
    my $additional_metadata = $opts->{additional_metadata};
    my $wid = $opts->{wid};
    my $params = $opts->{params};

    # Setup paths
    my ($staging_dir, $result_dir) = get_workflow_paths($user->name, $wid);
    my $gid = $genome->id;
    my $FASTA_CACHE_DIR = catdir($CONF->{CACHEDIR}, $gid, "fasta");
    die "ERROR: CACHEDIR not specified in config" unless $FASTA_CACHE_DIR;

    # Set metadata for the pipeline being used
    my $annotations = generate_additional_metadata($params);
    my @annotations2 = CoGe::Core::Metadata::to_annotations($additional_metadata);
    push @$annotations, @annotations2;

    #
    # Build the workflow
    #
    my @tasks;

    # Reheader the fasta file
    my $fasta = get_genome_file($gid);
    my $reheader_fasta = to_filename($fasta) . ".reheader.faa";
    push @tasks, create_fasta_reheader_job( 
        fasta => $fasta, 
        reheader_fasta => $reheader_fasta, 
        cache_dir => $FASTA_CACHE_DIR
    );
    
    # Trim the reads
    push @tasks, create_trim_galore_job( 
        fasta => $fasta, 
        reheader_fasta => $reheader_fasta, 
        cache_dir => $FASTA_CACHE_DIR
    );

    # Save outputs for retrieval by downstream tasks
#    my @done_files; = (
#        $load_bed_task->{outputs}->[0]
#    );
#    push @done_files, $load_csv_task->{outputs}->[0] if ($include_csv);
    
    return {
        tasks => \@tasks,
#        done_files => \@done_files
    };
}

sub generate_additional_metadata {
    my $params = shift;
    
    my @annotations;
#    push @annotations, qq{https://genomevolution.org/wiki/index.php/Expression_Analysis_Pipeline||note|Generated by CoGe's RNAseq Analysis Pipeline};
#    push @annotations, qq{note|samtools depth -q } . $params->{'-q'};
#    push @annotations, qq{note|cufflinks (default parameters)} if $isAnnotated;

    return \@annotations;
}

sub create_trim_galore_job {
    my %opts = @_;
    my $fastq       = $opts{fastq};     # single fastq file (string) or two paired-end fastq files (array ref)
    my $validated   = $opts{validated}; # input dependency from previous task, one or two files based on fastq arg
    my $staging_dir = $opts{staging_dir};
    my $params      = $opts{params} // {}; #/
    my $read_type   = $params->{read_type} // 'single'; #/ 'single' or 'paired'

    my $cmd = $CONF->{TRIMGALORE} || 'trim_galore';
    $cmd = 'nice ' . $cmd; # run at lower priority

    $fastq = [ $fastq ] unless (ref($fastq) eq 'ARRAY');
    $validated = [ $validated ] unless (ref($validated) eq 'ARRAY');
    
    my $name = join(', ', map { basename($_) } @$fastq);
    my @inputs = ( @$fastq, @$validated);
    my @outputs = map { catfile($staging_dir, to_filename($_) . '.trimmed.fastq') } @$fastq;

    # Build up command/arguments string
    my @args;
    if ($read_type eq 'paired') {
        push @args, ['--paired', '', 0];
        push @args, ['--trim1', join(' ', @$fastq), 0];
    }
    else { # single
        push @args, ['', join(' ', @$fastq), 0];
    }

    return {
        cmd => $cmd,
        script => undef,
        args => \@args,
        inputs => \@inputs,
        outputs => \@outputs,
        description => "Trimming (TrimGalore) $name...",
    };
}

1;
