#!/usr/bin/perl
##---------------------------------------------------------------------------##
##  File:
##      @(#) ProcessRepeats
##  Author:
##      Arian Smit <asmit@systemsbiology.org>
##      Robert Hubley <rhubley@systemsbiology.org>
##      original ExtractObjects module by Chris Abadjian
##      and Todd Smith.
##  Description:
##      Takes RepeatMasker output and produces an annotation table.
##
##
#******************************************************************************
#*
#* Copyright (C) Institute for Systems Biology 2002-2007 Developed by
#* Arian Smit and Robert Hubley.
#*
#* Copyright (C) Arian Smit 2000-2001
#*
#* Copyright (C) University of Washington 1996-1999 Developed by Arian Smit,
#* Philip Green and Colin Wilson of the University of Washington Department of
#* Genomics.
#*
#* This work is licensed under the Open Source License v2.1.  To view a copy
#* of this license, visit http://www.opensource.org/licenses/osl-2.1.php or
#* see the license.txt file contained in this distribution.
#*
###############################################################################
# ChangeLog
#
#   $Log: ProcessRepeats,v $
#   Revision 1.167  2007/06/12 23:32:30  rhubley
#     - Turned off recursion assert.  This still needs some work.
#
#   Revision 1.166  2007/05/24 20:20:06  rhubley
#     - Fixed a bug in ProcessRepeats reported by
#       ya-long.guo@tuebingen.mpg.de.  He reported running into an
#       error like:
#
#       cycle 3 ..........................join(): Invalid join!  $this ==
#       $partner at RepeatMasker3.1.8/ProcessRepeats line 8164.
#
#       This was caused by the .cat annotation:
#
#       ..
#       242 22.56 7.56 4.65 CHR2 9768538 9768709 (9936650) C ArnoldY2#DNA/MuDR (474) 705 529 5
#   245 26.16 6.06 1.52 CHR2 9768578 9768709 (9936650) C ArnoldY1#DNA/MuDR (1406) 530 393 5
#       ..
#
#       The DNA Transposon joining routine was not quiting after finding these
#       two items compatable.  Instead it was recording this combination 4
#       times.  Missing a "last" in the innermost loop.
#
#       This change was tested against 3.1.8 baseline and no changes have
#       have been found.
#
#   Revision 1.165  2007/05/17 21:01:53  rhubley
#   Cleanup before a distribution
#
#
###############################################################################
#
# To Do:
# The two alignments of L1 elements presented on one line (L1..extended
# appear in reverse order in the .ali file (no effect in .out file)
#

=head1 NAME

ProcessRepeats - Post process results from RepeatMasker and produce an annotation file.

=head1 SYNOPSIS

  ProcessRepeats [-options] <RepeatMasker *.cat file>

=head1 DESCRIPTION

The options are:

=over 4

=item -h(elp)

Detailed help

=item -species <query species> 

Post process RepeatMasker results run on sequence from
this species.  Default is human.

=item -lib <libfile>

Skips most processing, does not produce a .tbl file unless
the custome library is in the ">name#class" format.

=item -nolow 

Does not display simple repeats or low_complexity DNA in the annotation.

=item -noint 

Skips steps specific to interspersed repeats, saving lots of time.

=item -lcambig

Outputs ambiguous DNA transposon fragments using a lower case
name.  All other repeats are listed in upper case.  Ambiguous 
fragments match multiple repeat elements and can only be
called based on flanking repeat information.

=item -u     

Creates an untouched annotation file besides the manipulated file.

=item -xm    

Creates an additional output file in cross_match format (for parsing).

=item -ace

Creates an additional output file in ACeDB format.

=item -gff   

Creates an additional Gene Feature Finding format.

=item -poly  

Creates an output file listing only potentially polymorphic simple repeats.

=item -no_id 

Leaves out final column with unique number for each element (was default).

=item -excln 

Calculates repeat densities excluding long stretches of Ns in the query.

=item -orf2   

Results in sometimes negative coordinates for L1 elements; all L1 subfamilies
are aligned over the ORF2 region, sometimes improving interpretation of data.

=item -a     

Shows the alignments in a .align output file.

=item -maskSource <originalSeqenceFile> 

Instructs ProcessRepeats to mask the sequence file using the annotation.

=item -x        

Mask repeats with a lower case 'x'.

=item -xsmall   

Mask repeats by making the sequence lowercase.

=back

=head1 SEE ALSO

=over 4

RepeatMasker, Crossmatch, Blast

=back

=head1 COPYRIGHT

Copyright 2006 Arian Smit, Institute for Systems Biology

=head1 AUTHORS

Arian Smit <asmit@systemsbiology.org>

Robert Hubley <rhubley@systemsbiology.org>

=cut

#
# Module Dependence
#
use strict;
use FindBin;
use lib $FindBin::RealBin;
use SeqDBI;
use RepeatAnnotationData;
use FastaDB;
use SearchResult;
use SearchEngineI;
use SearchResultCollection;
use ArrayList;
use CrossmatchSearchEngine;
use Getopt::Long;
use Taxonomy;
use Data::Dumper;

# Global variables
my $DEBUG     = 0;
my $DIRECTORY = "$FindBin::Bin";

# A bug in 5.8 produces way too many warnings
if ( $] && $] >= 5.008003 ) {
  use warnings;
}

#
# Option processing
#  e.g.
#   -t: Single letter binary option
#   -t=s: String parameters
#   -t=i: Number paramters
#
my @opts =
    qw (a ace debug excln gff lib=s noint nolow orf2 orifile=s no_id poly species=s u xm mammal mus rat rod|rodent cow pig artiodactyl cat dog carnivore chicken fugu danio drosophila elegans arabidopsis rice wheat maize primate maskSource=s xsmall x lcambig source );

#
# Get the supplied command line options, and set flags
#
my %options = ();
unless ( &GetOptions( \%options, @opts ) ) {
  exec "pod2text $0";
  exit( 0 );
}

## Print the internal POD documentation if something is missing
if ( $#ARGV == -1 && !$options{'help'} ) {
  print "No cat file indicated\n\n";

  # This is a nifty trick so we don't have to have
  # a duplicate "USAGE()" subroutine.  Instead we
  # just recycle our POD docs.  See PERL POD for more
  # details.
  exec "pod2text $0";
  die;
}

##
## Species Options and Taxonomy Processing
##
## NOTE: Tax needs to be global for the moment
my $tax;
if ( $options{'species'} ) {

  # Need to set opt_species, opt_mammal, opt_mus
  $tax = Taxonomy->new( taxonomyDataFile => "$DIRECTORY/taxonomy.dat" );

  if ( $tax->isA( $options{'species'}, "primates" ) ) {
    $options{'primate'} = 1;
  }
  elsif ( $tax->isA( $options{'species'}, "rodentia" ) ) {
    $options{'mus'} = 1;
  }
  elsif ( $tax->isA( $options{'species'}, "mammalia" ) ) {
    $options{'mammal'} = 1;
  }
  if ( $tax->isA( $options{'species'}, "metatheria" ) ) {
    $options{'marsupial'} = 1;
  }
}
else {
  $options{'species'} = "homo";
  $options{'primate'} = 1;
}

# warning for debug mode
print "Note that in debug mode the IDs are not adjusted to go up stepwise\n\n"
    if $options{'debug'};

#
# Check library type used
#
# TODO: We need different levels of meta data compliance.  Ie.
#       Pound formatting isn't enough anymore. Also we can glean
#       compliance like pound formatting from the cat file.  No
#       need to open up the lib ( yet ).
my $poundformat = "";
if ( $options{'lib'} ) {
  open( IN, $options{'lib'} );
  while ( <IN> ) {
    if ( /^>\S+\#\S+/ ) {
      $poundformat = 1;

      # Assuming that this represents my classification formatting; no sure
      # thing could make it more restrictive by also requiring a backslash
      last;
    }
  }
}
else {
  $poundformat = 1;
}

#
# Loop over input files
#
foreach my $file ( @ARGV ) {
  open( INCAT, $file ) || die "Can\'t open file $file\n";

  # get some data from .cat file
  my $runningtot  = 0;
  my $runningnonN = 0;
  my $totalSeqLen = 0;
  my $exclnote    = "";
  my $versionmode = "";
  my $engine      = "";
  my $dbversion   = "";

  # Read the cat file and calculate:
  #   - The length of the original sequence ( minus 1/2 of the overlap )
  #   - The number of N bases
  #   - The number of sequences
  #   - The length of each sequence
  #   - The fraction GC the version the masked length and the dbversion.
  # Also...grab batch overlap boundaries if information is present.
  my %batchOverlapBoundaries         = ();
  my $numSearchedSeqs                = 0;
  my $lenSearchedSeqs                = 0;
  my $lenSearchedSeqsExcludingXNRuns = 0;
  my $lenSearchedSeqsExcludingAmbig  = 0;
  while ( <INCAT> ) {
    if ( /^##\s*(\S+)\s+([\d\s,]+)/ ) {
      $batchOverlapBoundaries{$1} = [ sort( split( /,/, $2 ) ) ];
    }
    elsif ( /^##\s*Total\s+Sequences:\s*(\d+)/i ) {
      $numSearchedSeqs = $1;
    }
    elsif ( /^##\s*Total\s+Length:\s*(\d+)/i ) {
      $lenSearchedSeqs = $1;
    }
    elsif ( /^##\s*Total\s+NonMask.*:\s*(\d+)/i ) {
      $lenSearchedSeqsExcludingXNRuns = $1;
    }
    elsif ( /^##\s*Total\s+NonSub.*:\s*(\d+)/i ) {
      $lenSearchedSeqsExcludingAmbig = $1;
    }
    elsif ( /^RepeatMasker|run|RepBase/ ) {
      my @bit = split;
      $versionmode = $_ if $bit[ 0 ] eq 'RepeatMasker';
      $engine = $1 if /^(run with.*)/;
      if ( /^(RepBase.*)/ ) {
        $dbversion = $1;
        last;
      }
    }
  }
  close INCAT;

  #
  #  Parse the cat file into an object
  #
  my $sortedAnnotationsList = undef;
  if ( $options{'a'} ) {
    $sortedAnnotationsList = &parseCATFile( file => $file );
  }
  else {
    $sortedAnnotationsList = &parseCATFile( file => $file, noAlignData => 1 );
  }

  # Create some filename constants
  my $catfile = $file;
  $file =~ s/\.(temp)?cat$//;
  my $filename = $file;
  $filename =~ s/(.*\/)//;

  unless ( $sortedAnnotationsList->size() > 0 ) {
    my $filenaam = $file;
    $filenaam = $options{'orifile'} if $options{'orifile'};
    open( OUT, ">$file.out" );
    print STDERR "\n\n\nNo repetitive sequences were detected in $filenaam\n";
    print OUT "There were no repetitive sequences detected in $filenaam\n";
    close( OUT );
    next;
  }

  if ( $options{'a'} ) {
    open( OUTALIGN, ">$file.align" );
  }

  print STDERR "processing output: ";

  open( OUTRAW, ">$file.ori.out" ) if ( $options{'u'} || !$poundformat );
  $options{'xm'}
      && ( open( OUTXM, ">$file.out.xm" )
           || die "can't create $file.out.xm\n" );
  $options{'ace'}
      && ( open( OUTACE, ">$file.out.ace" )
           || die "can't create $file.out.ace\n" );
  $options{'poly'}
      && ( open( OUTPOLY, ">$file.polyout" )
           || die "can't create $file.out.polyout\n" );

  if ( $options{'gff'} ) {
    open( OUTGFF, ">$file.out.gff" ) || die "can't create $file.out.gff\n";
    print OUTGFF "##gff-version 2\n";
    printf OUTGFF "##date %4d-%02d-%02d\n", ( localtime )[ 5 ] + 1900,
        ( localtime )[ 4 ] + 1, ( localtime )[ 3 ];    # date as 1999-09-24...
    ( my $seqname = $file ) =~ s/^.*\///;
    print OUTGFF "##sequence-region $seqname\n";
  }

  #
  # Initialize data structures and ID each annotation
  #
  # Makes global %seq1Lengths
  #   NOTE: Only needed because we are not updating LeftOver
  #         when we modify Seq1Beg/End
  #
  $sortedAnnotationsList->sort( \&byNameBeginEndrevSWrev );
  my $cycleAnnotIter = $sortedAnnotationsList->getIterator();
  my $i              = -1;
  my %seq1Lengths    = ();
  while ( $cycleAnnotIter->hasNext() ) {
    $i++;
    my $currentAnnot = $cycleAnnotIter->next();
    my $HitName      = $currentAnnot->getHitName();
    $HitName =~ s/_short_$//;
    $currentAnnot->setHitName( $HitName );
    if ( !defined $seq1Lengths{ $currentAnnot->getSeq1Name() }
         || $seq1Lengths{ $currentAnnot->getSeq1Name() } <
         ( $currentAnnot->getSeq1End() + $currentAnnot->getLeftOver() ) )
    {
      $seq1Lengths{ $currentAnnot->getSeq1Name() } =
          $currentAnnot->getSeq1End() + $currentAnnot->getLeftOver();
    }
  }

  ##########################  C Y C L E   1  ###############################
  # Purpose: Join fragments broken up by RepeatMasker
  #   Creates chainBeg{ ID } and chainEnd->{ ID }.  These hashses
  #   contain the seq2beg and seq2end respectively for sets of
  #   annotations which repeatmasker found as one alignment.
  ###########################################################################
  print STDERR "\ncycle 1 ";
  $sortedAnnotationsList->sort( \&bySeqSWConbegin );
  $cycleAnnotIter = $sortedAnnotationsList->getIterator();
  ### Globals: We create chainBeg and chainEnd ( Used in cycles 2 & 3 )
  my %chainBeg = ();
  my %chainEnd = ();
  $i = -1;
  while ( $cycleAnnotIter->hasNext() ) {
    $i++;
    my $DEBUG = 0;
    print STDERR "." if ( $i + 1 ) % 1000 == 0;
    my $currentAnnot = $cycleAnnotIter->next();
    next
        if (    $currentAnnot->getLeftLinkedHit()
             || $currentAnnot->getRightLinkedHit() );

    # Simple and Low Complexity repeats should not be rejoined.
    # There are often large gaps and misalignments which do not
    # necessary indicate that the fragments should be part of
    # one alignment.  I.e consider two alus side by side with
    # long poly-A tails.  In some cases the poly-A tails will be
    # joined as one alignment when in fact they are two independent
    # regions.
    next if ( $currentAnnot->getClassName() =~ /Simple|Low_/ );

    #
    #  Join fragments artificially broken up by repeatmasker
    #
    #  Rules: Same HitName
    #         Same Sequence
    #         Same Score, divg's
    #         Cons Boundaries match
    my $proxIter      = $cycleAnnotIter->getIterator();
    my @compatIDs     = ( $currentAnnot->getID() );
    my $lastSeq2Begin = $currentAnnot->getSeq2Beg();
    my $lastSeq2End   = $currentAnnot->getSeq2End();
    my $lowestSeq2Pos = $lastSeq2Begin;
    my $lastAnnot     = $currentAnnot;
    $lowestSeq2Pos = $lastSeq2End
        if ( $lowestSeq2Pos > $lastSeq2End );
    my $highestSeq2Pos = $lastSeq2Begin;
    $highestSeq2Pos = $lastSeq2End
        if ( $highestSeq2Pos < $lastSeq2End );
    my $contained = 0;

    while ( $proxIter->hasNext() ) {
      my $nextAnnot = $proxIter->next();
      if ( $nextAnnot->containsElement( $currentAnnot ) ) {
        $contained = 1;
      }
      last
          unless (    $currentAnnot->getSeq1Name() eq $nextAnnot->getSeq1Name()
                   && $nextAnnot->getSW() == $currentAnnot->getSW() );
      my $nextHitName   = $nextAnnot->getHitName();
      my $nextClassName = $nextAnnot->getClassName();
      if (
           $nextHitName == $currentAnnot->getHitName()
        && !$nextAnnot->getLeftLinkedHit()
        && !$nextAnnot->getRightLinkedHit()
        && $nextAnnot->getLastField() == $currentAnnot->getLastField()
        && $nextAnnot->getPctSubst() == $currentAnnot->getPctSubst()
        && $nextAnnot->getPctInsert() == $currentAnnot->getPctInsert()
        && $nextAnnot->getPctDelete() == $currentAnnot->getPctDelete()
        && (
          abs( $nextAnnot->getSeq2Beg() - $lastSeq2End ) == 1
          ||

          # I don't think I need this or
          abs( $nextAnnot->getSeq2End() - $lastSeq2Begin ) == 1
        )
          )
      {
        if ( $DEBUG ) {
          print STDERR "Joining RepeatMasker fragmented alignment:\n";
          $currentAnnot->print();
          print STDERR "  because of next:\n";
          $nextAnnot->print();
        }

        if ( $contained && $DEBUG ) {
          print STDERR "\n\n\n\n\n\nWARNING WARNING -- containment "
              . "breached!\n\n\n\n\n\n";
        }

        $lastAnnot->join( $nextAnnot );

        push @compatIDs, $nextAnnot->getID();
        $lastAnnot     = $nextAnnot;
        $lastSeq2Begin = $nextAnnot->getSeq2Beg();
        $lastSeq2End   = $nextAnnot->getSeq2End();
        $lowestSeq2Pos = $nextAnnot->getSeq2Beg()
            if ( $lowestSeq2Pos > $nextAnnot->getSeq2Beg() );
        $lowestSeq2Pos = $nextAnnot->getSeq2End()
            if ( $lowestSeq2Pos > $nextAnnot->getSeq2End() );
        $highestSeq2Pos = $nextAnnot->getSeq2Beg()
            if ( $highestSeq2Pos < $nextAnnot->getSeq2Beg() );
        $highestSeq2Pos = $nextAnnot->getSeq2End()
            if ( $highestSeq2Pos < $nextAnnot->getSeq2End() );
      }
    }
    if ( @compatIDs > 1 ) {
      if ( $DEBUG ) {
        print STDERR "Chain range = $lowestSeq2Pos - $highestSeq2Pos\n";
        print STDERR "Join ids sorted: " . join( ", ", @compatIDs ) . "\n";
      }
      foreach my $joinID ( @compatIDs ) {
        print STDERR "  Setting:  chainBeg/End{ $joinID }\n" if ( $DEBUG );
        $chainBeg{$joinID} = $lowestSeq2Pos;
        $chainEnd{$joinID} = $highestSeq2Pos;
      }
    }
    else {
      my $singleID = shift @compatIDs;
      if ( $DEBUG ) {
        print STDERR "Adding singleton = "
            . ( $currentAnnot->getSeq2Beg() - $currentAnnot->getSeq2End() )
            . "ID="
            . $currentAnnot->getID()
            . " ID=$singleID\n";
        $currentAnnot->print();
      }
      $chainBeg{$singleID} = $currentAnnot->getSeq2Beg();
      $chainEnd{$singleID} = $currentAnnot->getSeq2End();
    }
  }

  #printHitArrayList( $sortedAnnotationsList );

  ##########################  C Y C L E   2  ###############################
  # Purpose: Remove Edge Effect Annotations
  #          Join Poly-A Tails
  #          Reconstruct Satellite Annotations
  ##########################################################################
  print STDERR "\ncycle 2 ";

  # Sort by name, begin position, and end position descending
  $sortedAnnotationsList->sort( \&byNameBeginEndrevSWrev );

  # Create an ArrayListIterator for this cycle
  $cycleAnnotIter = $sortedAnnotationsList->getIterator();

  $DEBUG = 0;
  $i     = -1;
CYCLE2:
  while ( $cycleAnnotIter->hasNext() ) {
    $i++;
    print STDERR "." if ( $i + 1 ) % 1000 == 0;

    # NOTE: An iterator's index is considered
    #       to be in between elements of a datastructure.
    #       To obtain the correct index for the
    #       current element in this pass we should
    #       get the index *before* we move the iterator.
    my $currentIndex = $cycleAnnotIter->getIndex();
    my $currentAnnot = $cycleAnnotIter->next();

    if ( $DEBUG ) {
      print STDERR "CYCLE2: Considering\n";
      $currentAnnot->print();
    }

    if ( $currentAnnot->getRightLinkedHit() ) {
      my $proxIter = $cycleAnnotIter->getIterator();
      while ( $proxIter->hasNext() ) {
        my $nextAnnot = $proxIter->next();

        # Quit once we reach our partner
        last if ( $nextAnnot == $currentAnnot->getRightLinkedHit() );

        # Break Recursion Violations
        if ( $currentAnnot->containsElement( $nextAnnot )
          && $nextAnnot->containsElement( $currentAnnot->getRightLinkedHit() ) )
        {
          if ( $DEBUG ) {
            print STDERR "This violates recursion:\nFirst:\n";
            $currentAnnot->printLeftRightLinks();
            print STDERR "Second:\n";
            $nextAnnot->printLeftRightLinks();
          }

          # Break lower scoring link
          my $oldRight = $nextAnnot->getRightLinkedHit();
          $nextAnnot->setRightLinkedHit( undef );
          $oldRight->setLeftLinkedHit( undef );
        }
      }
    }

    ##
    ##  Edge Effect Removal
    ##
    ##  The current method of processing overlaps, while better
    ##  than before still produces some edge effects.  This
    ##  section attempts to remove these before we start any
    ##  serious analysis.
    ##
    ##  Overlaps are handled in RepeatMasker thus:
    ##
    ##                     Middle
    ##          <------      |
    ##                    ----->
    ##    Batch#1            |  ----x---->
    ##    ...-----------------------------|
    ##                       |
    ##                       |
    ##             |-----------------------------...
    ##                       |               BATCH#2
    ##              <-x-     |
    ##                     ---->
    ##                       |  ---------------->
    ##
    ##
    ## RepeatMasker deletes all annotations which are
    ## contained in the region left/right ( closest to
    ## the edge ) of the overlap midpoint. Shown here
    ## with an "x" in the diagram annotations.
    ## If an annotation spans the midpoint it is kept
    ## in the cat file.  This leaves several types of
    ## edge effects in annoation:
    ##
    ## Perfect or Near Perfect duplicates.  Perfect if
    ## the same matrix was used and the annotation is
    ## completely contained in the overlap.  Near perfect
    ## otherwise.
    ##
    ##                     Middle
    ##                       |
    ##                     ----->
    ##                       |
    ##                     ----->
    ##
    ##
    ## Cut Level Ambiguities.  A full length young repeat
    ## partially contained in the overlap will be excised
    ## at a lower cutlevel in one batch and masked at
    ## a higher cutlevel in the other batch. See below
    ## for some examples.
    ##
    ##
    # Remove exact duplicates.  Near duplicates get resolved elsewhere
    # ( FuseOverlappingSeqs etc ). We do this now especially to handle
    # duplicated poly-a tails that we are about to join.
    my $prevAnnot = $sortedAnnotationsList->get( $currentIndex - 1 )
        if ( $currentIndex > 0 );
    if (    $prevAnnot
         && $currentAnnot->getSW() == $prevAnnot->getSW()
         && $currentAnnot->getPctSubst() == $prevAnnot->getPctSubst()
         && $currentAnnot->getSeq1Name() eq $prevAnnot->getSeq1Name()
         && $currentAnnot->getSeq1Beg() == $prevAnnot->getSeq1Beg()
         && $currentAnnot->getSeq1End() == $prevAnnot->getSeq1End() )
    {

      #  Lower Scoring Overlap > %90 Covered by Higher Scoring
      #  Get rid of lower scoring one
      #  same cutlevel
      if ( $DEBUG ) {
        print STDERR "REMOVING EXACT DUPLICATE:\n";
        $currentAnnot->print();
        print STDERR "  because of:\n";
        $prevAnnot->print();
      }

      # Fix any previous joins to this element
      $currentAnnot->removeFromJoins();
      $prevAnnot->addDerivedFromAnnot( $currentAnnot )
          if ( $options{'source'} );
      $cycleAnnotIter->remove();
      next CYCLE2;
    }

    #
    #    If a large >1000bp ( 1/2 current overlap distance )
    #    young repeat starts outside the overlap and spans
    #    the middle of the overlap you will get edge effect
    #    duplications.  I.e.
    #
    #  Case #1              Middle
    #      batch1             |
    #      ---------------------------|
    #           ----------------->   ( excised cutlevels 0-4 )
    #                   ----X---->   ( masked cutlevel 5 )
    #                  |------------------------------
    #                         |                  batch2
    #                         |
    # or                      |
    #      batch1             ----X-->  ( masked cutlevel 5 )
    #      ----------------------------|
    #                  |------------------------------- batch2
    #                         -----------------> ( excised cutlevel 0-4 )
    #                         |
    #
    #    Because excision is only performed on full length
    #    elements (lines can be 5' truncated) this can be
    #    detected by checking for elements which contained by
    #    a cutlevel 5 annotation *and* are less than cutlevel 5.
    #
    #  Case #2              Middle
    #                         |
    #                         <---X---  ( cut level 5..just outside the other )
    #      ----------------------------|
    #                  |-------------------------------
    #                         | <---------- (excised cut level 0-4 )
    #                         |
    #                         |
    #  Case #3                |
    #          (c.l. 5)  -->  |
    #                       -------> ( c.l. 3 )
    #     -----------------------------|
    #                  |----------------------------
    #                    X>   |
    #                      -------->
    #
    #  In this case you have a cut level 3 spaning a middle
    #  which is one bp longer in one batch.  This creates
    #  a 1bp overlap with a something at a higher cut level.
    #
    #  So our general rule ends up: Remove all elements
    #  in cutlevels 4/5 which overlap ( by > 10bp ) or are
    #  contained by another element at a lessor cut level.
    #  These cases should never occur outside the overlap
    #  region anyway.
    #
    if ( $currentAnnot->getLastField >= 4 ) {
      my $proxIter = $cycleAnnotIter->getIterator();
      $proxIter->previous();
      while ( $proxIter->hasPrevious() ) {
        my $prevAnnot = $proxIter->previous();
        last
            unless (  $currentAnnot->getSeq1Name eq $prevAnnot->getSeq1Name()
                   && $prevAnnot->getSeq1End() >= $currentAnnot->getSeq1Beg() );
        if (    $prevAnnot->getLastField() < $currentAnnot->getLastField
             && $prevAnnot->getSeq1End() - $currentAnnot->getSeq1Beg() >= 10 )
        {
          if ( $DEBUG ) {
            print STDERR "DELETING MASKED INSIDE CUT:\n";
            $currentAnnot->print();
            print STDERR "  because of previous:\n";
            $prevAnnot->print();
          }

          # Fix any previous joins to this element
          $currentAnnot->removeFromJoins();
          $prevAnnot->addDerivedFromAnnot( $currentAnnot )
              if ( $options{'source'} );
          $cycleAnnotIter->remove();
          next CYCLE2;
        }
      }

      $proxIter = $cycleAnnotIter->getIterator();
      while ( $proxIter->hasNext() ) {
        my $nextAnnot = $proxIter->next();
        last
            unless (  $currentAnnot->getSeq1Name eq $nextAnnot->getSeq1Name()
                   && $nextAnnot->getSeq1Beg() <= $currentAnnot->getSeq1End() );
        if (    $nextAnnot->getLastField() < $currentAnnot->getLastField
             && $currentAnnot->getSeq1End() - $nextAnnot->getSeq1Beg() >= 10 )
        {
          if ( $DEBUG ) {
            print STDERR "DELETING MASKED INSIDE CUT:\n";
            $currentAnnot->print();
            print STDERR "  because of next:\n";
            $nextAnnot->print();
          }

          # Fix any previous joins to this element
          $currentAnnot->removeFromJoins();
          $nextAnnot->addDerivedFromAnnot( $currentAnnot )
              if ( $options{'source'} );
          $cycleAnnotIter->remove();
          next CYCLE2;
        }
      }
    }

    #
    # Masklevel Violations From Clipping Boundaries
    #
    #   RepeatMasker fragments alignments which span
    # cut out elements.  This fragmentation process may
    # convert a pair of alignments like:
    #
    #       --------------^------------->     SW=1000
    #          -----------^----------------->  SW=1500
    #
    # ( where "^" marks the site of a clipped out element )
    # into something like:
    #
    #         SW = 1000          SW = 1000
    #       -------------->     ------------->
    #          ----------->     ----------------->
    #            SW = 1500       SW = 1500
    #
    # This little block of code resolves this masklevel
    # rule-breaker ( lower scoring alignment contained by
    # higher scoring one ) by elminating the lower scoring
    # subfragments.
    #
    # i.e Delete element if flanking elements include
    # it and have a better or equal score.
    #
    #         SW = 1000
    #       -------------->
    #          ----------->     ----------------->
    #            SW = 1500       SW = 1500
    #
    # This is still a bit artificial.
    #
    $prevAnnot = $sortedAnnotationsList->get( $currentIndex - 1 )
        if ( $currentIndex > 0 );
    my $proxIter = $cycleAnnotIter->getIterator();
    my ( $prevHitName, $prevClassName ) =
        split( /\#/, $prevAnnot->getSeq2Name() )
        if ( $prevAnnot );

    #
    # Delete iff:
    #       ----current-----^   SW <= past
    #       -----past-------^
    #  -..----past----------^
    #
    #   or
    #       ^---current-----   SW <= past
    #       ^----past-------
    #       ^------past----------...--
    #
    if (
         $prevAnnot
         && (
              (
                   $currentAnnot->getSeq1End() == $prevAnnot->getSeq1End()
                && $currentAnnot->getSW() <= $prevAnnot->getSW()
                && $currentAnnot->getSeq1Name()  eq $prevAnnot->getSeq1Name()
                && $currentAnnot->getClassName() eq $prevClassName
              )
              || (    $currentAnnot->getSeq1Beg() == $prevAnnot->getSeq1Beg()
                   && $currentAnnot->getSeq1End() <= $prevAnnot->getSeq1End()
                   && $currentAnnot->getSW() <= $prevAnnot->getSW()
                   && $currentAnnot->getSeq1Name()  eq $prevAnnot->getSeq1Name()
                   && $currentAnnot->getClassName() eq $prevClassName )
         )
        )
    {
      if ( $DEBUG ) {
        print STDERR "Deleting clipping boundary fragment "
            . "( masklevel violation ):\n";
        $prevAnnot->print();
        $currentAnnot->print();
      }

      # Fix any previous joins to this element
      $currentAnnot->removeFromJoins();
      $prevAnnot->addDerivedFromAnnot( $currentAnnot )
          if ( $options{'source'} );
      $cycleAnnotIter->remove();
      next CYCLE2;
    }

    my $Seq2BeginPrint     = $currentAnnot->getSeq2Beg();
    my $LeftUnalignedPrint = "(" . $currentAnnot->get3PrimeUnaligned() . ")";
    my $LeftOverPrint      = "(" . $currentAnnot->getLeftOver() . ")";
    if ( $currentAnnot->getRevComp() eq "C" ) {
      $Seq2BeginPrint     = "(" . $currentAnnot->get3PrimeUnaligned() . ")";
      $LeftUnalignedPrint = $currentAnnot->getSeq2Beg();
    }

    #
    # Supposedly creates an untouched annotation file.
    # What it really does is create an annotation file
    # which has been modified to remove exact duplicates
    # and batch overlap artifacts only.
    #
    if ( $options{'u'} || !$poundformat ) {

      my $prevAnnot = $sortedAnnotationsList->get( $currentIndex - 1 )
          if ( $currentIndex > 0 );

      my $nextAnnot = $sortedAnnotationsList->get( $currentIndex + 1 )
          if ( $currentIndex < $sortedAnnotationsList->size() - 1 );

      my $Overlapped = "";
      if (    $prevAnnot
           && $currentAnnot->getSeq1Beg() <= $prevAnnot->getSeq1End()
           && $currentAnnot->getSW() < $prevAnnot->getSW()
           || $nextAnnot
           && $currentAnnot->getSeq1End() >= $nextAnnot->getSeq1Beg()
           && $currentAnnot->getSW() < $nextAnnot->getSW() )
      {
        $Overlapped = "*";
      }
      $currentAnnot->setClassName( "" )
          unless ( $currentAnnot->getClassName() );

      #
      # sequence names get truncated to 20 letters. Too
      # cumbersome to change.  However, names like
      # /mnt/user/users/FlipvanTiel/mystuff/sequence1 better be
      # clipped from the end. Thus:
      $currentAnnot->setSeq1Name( substr( $currentAnnot->getSeq1Name(), -20 ) )
          if ( length $currentAnnot->getSeq1Name() > 20
               && $currentAnnot->getSeq1Name() =~ /^\// );

      printf OUTRAW "%6d %4s %4s %4s %20s %9s %9s %8s %1s "
          . "%20s %15s %7s %7s %7s %3s\n", $currentAnnot->getSW(),
          $currentAnnot->getPctSubst,  $currentAnnot->getPctDelete,
          $currentAnnot->getPctInsert, $currentAnnot->getSeq1Name(),
          $currentAnnot->getSeq1Beg(), $currentAnnot->getSeq1End(),
          "(" . $currentAnnot->getLeftOver() . ")", $currentAnnot->getRevComp(),
          $currentAnnot->getHitName(), $currentAnnot->getClassName(),
          $Seq2BeginPrint, $currentAnnot->getSeq2End(), $LeftUnalignedPrint;
      $Overlapped;
    }    # if ( $options{'u'}  || !$poundformat )

    #
    #  Create an alignment file
    #
    if ( $options{'a'} ) {
      print OUTALIGN $currentAnnot->getAlignData();
    }

    #
    # If a user supplied non-classified library was used
    #
    if ( !$poundformat ) {
      if ( $options{'ace'} ) {
        if ( $currentAnnot->getRevComp() eq "C" ) {
          print OUTACE "Motif_homol \""
              . $currentAnnot->getHitName()
              . "\" \"RepeatMasker\" "
              . $currentAnnot->getPctSubst() . " "
              . $currentAnnot->getSeq1Beg() . " "
              . $currentAnnot->getSeq1End() . " - "
              . $currentAnnot->getSeq2End() . " "
              . $currentAnnot->getSeq2Beg() . "\n";
        }
        else {
          print OUTACE "Motif_homol \""
              . $currentAnnot->getHitName()
              . "\" \"RepeatMasker\" "
              . $currentAnnot->getPctSubst() . " "
              . $currentAnnot->getSeq1Beg() . " "
              . $currentAnnot->getSeq1End() . " + "
              . $currentAnnot->getSeq2Beg() . " "
              . $currentAnnot->getSeq2End() . "\n";
        }
      }
      if ( $options{'xm'} ) {
        my $tempclassname = "";
        $tempclassname = "\#" . $currentAnnot->getClassName()
            if ( $currentAnnot->getClassName() );
        print OUTXM $currentAnnot->getSW() . " "
            . $currentAnnot->getPctSubst() . " "
            . $currentAnnot->getPctDelete() . " "
            . $currentAnnot->getPctInsert() . " "
            . $currentAnnot->getSeq1Name() . " "
            . $currentAnnot->getSeq1Beg() . " "
            . $currentAnnot->getSeq1End() . " "
            . $LeftOverPrint . " "
            . $currentAnnot->getRevComp() . " "
            . $currentAnnot->getHitName()
            . $tempclassname . " "
            . $Seq2BeginPrint . " "
            . $currentAnnot->getSeq2End() . " "
            . $LeftUnalignedPrint . "\n";
      }
      if ( $options{'gff'} ) {
        my $source;
        if ( $currentAnnot->getHitName() =~ /Alu/ ) {
          $source = 'RepeatMasker_SINE';
        }
        else {    #
          $source = 'RepeatMasker';
        }
        print OUTGFF ""
            . $currentAnnot->getSeq1Name()
            . "\t$source\tsimilarity\t"
            . $currentAnnot->getSeq1Beg() . "\t"
            . $currentAnnot->getSeq1End() . "\t"
            . $currentAnnot->getPctSubst() . "\t"
            . ( $currentAnnot->getRevComp() eq 'C' ? '-' : '+' ) . "\t.\t"
            . "Target \"Motif:"
            . $currentAnnot->getHitName() . "\" "
            . $currentAnnot->getSeq2Beg() . " "
            . $currentAnnot->getSeq2End() . "\n";
      }
    }    # if ( !$poundformat )
    else {

      # TODO: Meta Data
      $currentAnnot->setClassName( "Satellite" )
          if ( $currentAnnot->getHitName =~ /HSATII|SUBTEL/ );

      #
      # Join Poly-A tails to SINE or LINE1 annotations:
      #
      # A Poly A tail defined as:
      #
      #    - A hit to a '(A)n', '(CA)n', '(CAA)n', '(AAA)n' etc
      #    - a previous hit (within 5) to a Alu,Flam, Fr?am, L1.*_3end,
      #      L1_.*extended or SVA.  Why would you go five back?? Is it
      #      because you could have overlapping annotations for the previous
      #      segment of DNA?  Why not go back to the limit of the gap that you
      #      accept?
      #    - And for each group of element there is a tolerance for
      #      the amount of consensus that remains unaligned at the end.
      #    - The annotations are not > 3 bases apart
      #    - The simple repeat isn't subsumed by more than 30 bases on
      #      the end. I.e the IR doesn't extend past the simple repeat
      #      by more than 30 bases.
      #    - They are in the same orientation, same sequence etc.
      #    - NOTE: This 30 base limit is due to a search related
      #            constant.  The maximum match to a simple repeat
      #            is around ~20bp.
      #
      #  TODO: Consider doing the same for repeat tails of other SINEs
      #        and LINEs.  Also could consider limiting this to diverged
      #        simple repeats. Consider what is the best way to deal
      #        with the consensus length/masked when the tail exceeds the
      #        length of the origincal consensus.
      #
      #  NOTE: This routine makes the assumption that simple repeats
      #        and low-complexity regions which where fragmented by
      #        repeatmasker are *not* rejoined above.  Rejoining
      #        is not always appropriate and would cause the code
      #        below to connect up distant fragments to the ends of
      #        SINEs and LINEs.
      #
      my $backIter = $cycleAnnotIter->getIterator();
      $backIter->previous();
      my $forwIter = $cycleAnnotIter->getIterator();
      if (
           (
                $currentAnnot->getHitName eq '(A)n'
             || $currentAnnot->getHitName =~ /^\(.A{3,6}\)/
           )
           && !$options{'noint'}
          )
      {
        my $k = 1;
        my $prevAnnot;
        my $nextAnnot;
        while ( $k < 5 ) {
          my ( $prevHitName, $prevClassName );
          my ( $nextHitName, $nextClassName );
          if ( $backIter->hasPrevious() ) {
            $prevAnnot = $backIter->previous();
            ( $prevHitName, $prevClassName ) =
                split( /\#/, $prevAnnot->getSeq2Name() );
          }
          if ( $forwIter->hasNext() ) {
            $nextAnnot = $forwIter->next();
            ( $nextHitName, $nextClassName ) =
                split( /\#/, $nextAnnot->getSeq2Name() );
          }
          if (
            $prevAnnot
            && (    $prevHitName =~ /^Alu|^FLAM/
                 && $prevAnnot->get3PrimeUnaligned() < 32
                 || $prevHitName =~ /^FR?AM$|^L1.*_3end$|^L1.*extended$|^SVA$/
                 && $prevAnnot->get3PrimeUnaligned() < 26 )

            # the IR is an Alu or L1 at it's 3' end
            && $currentAnnot->getSeq1Beg() - $prevAnnot->getSeq1End() < 4
            && $currentAnnot->getRevComp  eq $prevAnnot->getRevComp()
            && $currentAnnot->getSeq1Name eq $prevAnnot->getSeq1Name()
              )
          {

            # Check for inclusion of simple inside IR with
            # ext limited to 31 beyond
            if (
                 $currentAnnot->getRevComp eq '+'
              && $prevAnnot->getSeq1End() - $currentAnnot->getSeq1End() < 32

              # IR extends at most 31 bp beyond the clipped simple repeat
              || $currentAnnot->getRevComp eq 'C'
              && $currentAnnot->getSeq1Beg() - $prevAnnot->getSeq1Beg() < 32

              # In this case IR always extends beyond the
              # clipped simple repeat; limited to 31 bp
                )
            {
              my $newend = $currentAnnot->getSeq1End();

              # should not be counted as insert anymore
              if ( $DEBUG ) {
                print STDERR "Fusing ALU and Poly A: Current element:\n";
                $currentAnnot->print();
                print STDERR "will be renamed for prev element:\n";
                $prevAnnot->print();
              }

              # Copy most data fields from $prevAnnot
              $currentAnnot->setFrom( $prevAnnot );

              $currentAnnot->setSeq1End( $newend )
                  if ( $currentAnnot->getSeq1End() < $newend );

              # This is now always the case; used to be that
              # interrupted IRs were "broken up" after this routine
              $currentAnnot->setSeq2End( $currentAnnot->getSeq2End() +
                                         $currentAnnot->get3PrimeUnaligned() );

              $currentAnnot->set3PrimeUnaligned( 0 );

              # Fix any previous joins to this element
              $prevAnnot->removeFromJoins();
              $currentAnnot->addDerivedFromAnnot( $prevAnnot )
                  if ( $options{'source'} );
              $backIter->remove();

              if ( $DEBUG ) {
                print STDERR "Final call:\n";
                $currentAnnot->print();
              }
            }
            last;
          }

          # Reverse strand equivalent
          elsif (
               $nextAnnot
            && $currentAnnot->getRevComp  eq 'C'
            && $currentAnnot->getSeq1Name eq $nextAnnot->getSeq1Name()
            && $nextAnnot->getRevComp()   eq 'C'
            && $nextAnnot->getSeq1Beg() - $currentAnnot->getSeq1End() < 3
            && ( $nextAnnot->getSeq2Name() =~ /^Alu|^FLAM/
              && $nextAnnot->get3PrimeUnaligned() < 32
              || $nextAnnot->getSeq2Name() =~ /^FR?AM$|^L1.*_3end|^L1.*extended/
              && $nextAnnot->get3PrimeUnaligned() < 26 )
              )
          {
            my $newbegin = $currentAnnot->getSeq1Beg();

            # Copy most data fields from $nextAnnot
            $currentAnnot->setFrom( $nextAnnot );

            if ( $DEBUG ) {
              print STDERR "Fusing ALU and Poly A: Current element:\n";
              $currentAnnot->print();
              print STDERR "will be renamed for next element:\n";
              $nextAnnot->print();
            }

            # It seems better to adjust Seq2End to the end of
            # the consensus instead. This must (almost) always be
            # reached (maximally 25 bp unaligned to start; minimum
            # lenht of deleted simple repeat is 21 bp) and it is
            # confusing that IR consensus sequences appear to have
            # different lengths in the output (which you get with
            # the commented-out line).
            $currentAnnot->setSeq2End(
               $currentAnnot->getSeq2End() + $currentAnnot->get3PrimeUnaligned()
            );
            $currentAnnot->setSeq1Beg( $newbegin );
            $currentAnnot->set3PrimeUnaligned( 0 );
            my $LeftOver = $currentAnnot->getLeftOver();
            $LeftOver =~ tr/[\(\)]//d;
            $currentAnnot->setLeftOver( $LeftOver );

            # Fix any previous joins to this element
            $nextAnnot->removeFromJoins();
            $currentAnnot->addDerivedFromAnnot( $nextAnnot )
                if ( $options{'source'} );
            $forwIter->remove();
            last;
          }

          # What does this do?
          my $ClassName = $currentAnnot->getClassName();
          $ClassName =~ s/_[no][el][dw](\d{1,2})?$//;
          $currentAnnot->setClassName( $ClassName );
          ++$k;
        }    # While ( $k < 5 ) loop

      }    # Join poly-A tails to SINE or LINE1 annotations
           #
           # Join Alu and L1 fragments broken by clipped-out A-rich simple
           # repeats, subsequently (in the previous annotation line)
           # attached to the poly A tail by above code
           #
      elsif ( $backIter->hasPrevious() ) {
        my $prevAnnot = $backIter->previous();
        my ( $prevHitName, $prevClassName ) =
            split( /\#/, $prevAnnot->getSeq2Name() );
        if (    $currentAnnot->getHitName eq $prevHitName
             && $currentAnnot->getSeq1Beg() - $prevAnnot->getSeq1End() == 1
             && $currentAnnot->getRevComp() eq $prevAnnot->getRevComp() )
        {

          # TODO: Consider removing the following block
          if (    $currentAnnot->getRevComp eq '+'
               && $currentAnnot->getSeq2Beg - $prevAnnot->getSeq2End() == 1 )
          {
            if ( 1 || $DEBUG ) {
              print STDERR "Fusing SINE/LINE and Poly A: Current element:\n";
              $currentAnnot->print();
              print STDERR "will be renamed for prev element:\n";
              $prevAnnot->print();
            }
            $currentAnnot->setSeq1Beg( $prevAnnot->getSeq1Beg() );
            $currentAnnot->setSeq2Beg( $prevAnnot->getSeq2Beg() );

            # Fix any previous joins to this element
            $prevAnnot->removeFromJoins();
            $currentAnnot->addDerivedFromAnnot( $prevAnnot )
                if ( $options{'source'} );
            $backIter->remove();
          }
          elsif (  $currentAnnot->getRevComp() eq 'C'
                && $prevAnnot->getSeq2Beg() - $currentAnnot->getSeq2End() == 1 )
          {
            if ( $DEBUG ) {
              print STDERR "Fusing SINE/LINE and Poly A: Current element:\n";
              $currentAnnot->print();
              print STDERR "will be renamed for prev element:\n";
              $prevAnnot->print();
            }
            $currentAnnot->setSeq1Beg( $prevAnnot->getSeq1Beg() );
            $currentAnnot->setSeq2End( $prevAnnot->getSeq2End() );
            $currentAnnot->set3PrimeUnaligned(
                                             $prevAnnot->get3PrimeUnaligned() );

            # Fix any previous joins to this element
            $prevAnnot->removeFromJoins();
            $currentAnnot->addDerivedFromAnnot( $prevAnnot )
                if ( $options{'source'} );
            $backIter->remove();
          }
        }
      }

      #
      # Satellite Consensi
      #    Searching for satellites with consensi is a hack.
      #    Search engines such as crossmatch will often return
      #    hits to a single repeating pattern as:
      #           |       |       |       |       |
      #           abcdefghabcdefghabcdefghabcdefghabcdefgh
      #          --------->
      #                           -------->
      #                                           -------->
      #    By creating a consensus for the repeat pattern and
      #    another for the same pattern shifted by 1/2 of the
      #    cycle. You can nicely overlapping hits.
      #    These shifted consensi are denoted by the use of a
      #    trailing "_" in the name.
      #
      #    Here is the regular expression for the syntax:
      #
      #    [A-Z_]+[a-z]?_?#Satellite
      #
      #    So here are some examples:
      #
      #     ALR_#Satellite
      #     ALRa#Satellite
      #     ALRa_#Satellite
      #     CENSAT_MC#Satellite
      #
      #    Since these trailing "_" variants and the "[a-z]"
      #    variants are equivalent we only need to restore
      #    the original name by stripping these characters
      #    HitName.
      #
      #    NOTE: The lowercase varieties are not in repbase.
      #
      if ( $currentAnnot->getClassName =~ /Satellite/ ) {
        my $HitName = $currentAnnot->getHitName();
        $HitName =~ s/_$//;
        $HitName =~ s/[a-z]$//;
        $currentAnnot->setHitName( $HitName );
      }

      if ( $currentAnnot->getClassName =~ /DNA/ ) {

        # Find all ambiguous dna transposon fragments and generate
        # equivalency lists
        &preProcessDNATransp( \%chainBeg, \%chainEnd, $currentAnnot,
                              \%RepeatAnnotationData::repeatDB );
      }

    }
  }    # END CYCLE 2

  close( OUTRAW ) if ( $options{'u'} || !$poundformat );
  close( OUTALIGN ) if $options{'a'};

  #
  #  If we do not have a pound formatted database we are done!
  #
  if ( !$poundformat ) {
    rename( "$file.ori.out", "$file.out" );
    if ( -f $options{'maskSource'} ) {
      print "\nmasking";
      my $db = FastaDB->new(
                             fileName    => $options{'maskSource'},
                             openMode    => SeqDBI::ReadOnly,
                             maxIDLength => 50
      );
      my $maskFormat = '';
      $maskFormat = 'x'      if ( $options{'x'} );
      $maskFormat = 'xsmall' if ( $options{'xsmall'} );
      &maskSequence( $maskFormat, $db, "$file.out",
                     $options{'maskSource'} . ".masked" );
    }
  }
  else {

    # Continue with the rest of the cycles!

    open( OUTFULL, ">$file.out" ) || die "can't create $file.out\n";

    ########################## C Y C L E 3 ################################
    #
    #  This cycle is currently handling the de-fragmentation
    #  of DNA Transposons using a new method.  It also joins simple
    #  repeats together.
    #
    #  Creates global %conPosCorrection
    ########################################################################

    #printHitArrayList( $sortedAnnotationsList );

    # Sort by name, begin position, and end position descending
    print STDERR "\ncycle 3 ";
    $sortedAnnotationsList->sort( \&byNameBeginEndrevSWrev );
    $i              = -1;
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();
    $DEBUG          = 0;
    my %conPosCorrection = ();

CYCLE3:
    while ( $cycleAnnotIter->hasNext() ) {
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;

      # NOTE: An iterator's index is considered
      #       to be in between elements of a datastructure.
      #       To obtain the correct index for the
      #       current element in this pass we should
      #       get the index *before* we move the iterator.
      my $currentIndex = $cycleAnnotIter->getIndex();
      my $currentAnnot = $cycleAnnotIter->next();

      if ( $currentAnnot->getStatus() eq "DELETED" ) {

        # Fix any previous joins to this element
        $currentAnnot->removeFromJoins();
        $cycleAnnotIter->remove();
        next CYCLE3;
      }

      if ( $DEBUG ) {
        print STDERR "Considering:\n";
        $currentAnnot->print();
      }

      if (    $currentAnnot->getClassName() =~ /DNA/
           && $currentAnnot->getStatus() ne "JOINED" )
      {

        #if ( $DEBUG ) {
        #print STDERR "DNA Transposon Equivalent:\n";
        #print STDERR Dumper( $EquivHash ) . "\n";
        #}
        # Look into our future
        my $proxIter             = $cycleAnnotIter->getIterator();
        my @dnaTransposonCluster = ();
        my $elementDistance      = 0;
        my $ignoreUntil          = undef;
        while ( $proxIter->hasNext() ) {
          my $nextAnnot = $proxIter->next();
          my ( $nextHitName, $nextClassName ) =
              split( /\#/, $nextAnnot->getSeq2Name() );

          if ( $DEBUG ) {
            print STDERR "   -vs-: ";
            $nextAnnot->print();
          }

          $elementDistance++ if ( $nextClassName =~ /DNA/ );

          #
          # Reasons we wouldn't consider this element in our cluster and
          # trigger the end to the search
          #
          # TODO: Do not join fragments outside of a parent fragment.
          #
          last
              if (
               $currentAnnot->getSeq1Name() ne $nextAnnot->getSeq1Name()
            || $elementDistance > 20
            || $nextAnnot->getSeq1End() - $currentAnnot->getSeq1End() >
            15000    # max retrovirus insert
            || $nextAnnot->containsElement( $currentAnnot )
              );

          if ( $ignoreUntil ) {
            if ( $ignoreUntil == $nextAnnot ) {
              $ignoreUntil = undef;
            }
            next;
          }

          if (    $nextClassName =~ /DNA/
               && $nextAnnot->getStatus() ne "JOINED"
               && $nextAnnot->getStatus() ne "DELETED" )
          {
            push @dnaTransposonCluster, $nextAnnot;
          }

          if ( $nextAnnot->getRightLinkedHit() ) {
            $ignoreUntil = $nextAnnot->getRightLinkedHit();
          }

        }
        if ( @dnaTransposonCluster ) {

          # Consider recruiting putative related elements to our cause
          &joinDNATransposonFragments(
                                       \%chainBeg,
                                       \%chainEnd,
                                       \%RepeatAnnotationData::repeatDB,
                                       $currentAnnot,
                                       \@dnaTransposonCluster
          );
        }
      }

      ## RMH  Tried to move this to cycle 0.  Found that
      ##      at least with the preProcessSINE we run
      ##     into problems joining to Poly A tails.  The
      ##     preprocess routine changes the 3primunaligned which
      ##     invalidates the join.  Consider this deeper
      if ( $currentAnnot->getClassName() =~ /SINE/ ) {
        &preProcessSINE( \%chainBeg, \%chainEnd, $currentAnnot );
      }
      elsif ( $currentAnnot->getHitName =~ /^MLT2/ )
      {    #  middle region of MLT2 variable in length in subfamilies
            # NOTE: Initializes conPosCorrection{ID} for LTRs
        &preProcessLTR( \%chainBeg,         \%chainEnd,
                        \%conPosCorrection, $currentAnnot );
      }
      elsif ( $currentAnnot->getClassName =~ /LINE/ ) {

        # I placed this here because I could.
        # adjust start position of LINE termini and
        # give generic names to too precisely categorized LINEs
        # NOTE: Initializes conPosCorrection{ID} for LINEs
        &preProcessLINE( \%chainBeg,         \%chainEnd,
                         \%conPosCorrection, $currentAnnot );
      }

      # merge long simple repeats which were initially partly spliced out
      # Note that not all satellite entries represent (multiple)
      # units. Some are complex sequences that can contain
      # minisatellites in it; overlapping matches to such
      # subsequences cause 'funny' annotation (in particular,
      # the location of the match in the consensus sequence is off)
      if ( $currentAnnot->getClassName() =~ /Simple|Satellite/ ) {
        if ( $cycleAnnotIter->hasNext() ) {

          #
          # current   ..-----------
          # next          ..-----
          #
          my $proxIter  = $cycleAnnotIter->getIterator();
          my $nextAnnot = $proxIter->next();

          if (    $currentAnnot->getSeq1Name() eq $nextAnnot->getSeq1Name()
               && $currentAnnot->getRevComp() eq $nextAnnot->getRevComp()
               && $currentAnnot->getSeq1End() > $nextAnnot->getSeq1End() )
          {
            my $tempname = quotemeta $currentAnnot->getHitName();
            if ( $nextAnnot->getSeq2Name() =~ /tempname/ ) {
              my $thislength =
                  $currentAnnot->getSeq2End() - $currentAnnot->getSeq2Beg() + 1;
              my $nextlength =
                  $nextAnnot->getSeq2End() - $nextAnnot->getSeq2Beg() + 1;
              my $Seq2Length = $thislength + $nextlength;
              my $SW         = $nextAnnot->getSW()
                  if ( $nextAnnot->getSW() > $currentAnnot->getSW() );
              $currentAnnot->setSW( $SW );
              $currentAnnot->setPctSubst(
                                  (
                                    $currentAnnot->getPctSubst() * $thislength +
                                        $nextAnnot->getPctSubst() * $nextlength
                                  ) / $Seq2Length
              );
              $currentAnnot->setPctDelete(
                                 (
                                   $currentAnnot->getPctDelete() * $thislength +
                                       $nextAnnot->getPctDelete() * $nextlength
                                 ) / $Seq2Length
              );
              $currentAnnot->setPctInsert(
                                 (
                                   $currentAnnot->getPctInsert() * $thislength +
                                       $nextAnnot->getPctInsert() * $nextlength
                                 ) / $Seq2Length
              );
              $nextAnnot->removeFromJoins();
              $currentAnnot->addDerivedFromAnnot( $nextAnnot )
                  if ( $options{'source'} );
              $proxIter->remove();
            }
          }
        }    # if ( $cycleAnnotIter->hasNext()...
             #
        if ( $currentAnnot->getClassName() =~ /Simple/ ) {

          # Requirement added in January 2005; Satellites should not
          # be considered This loop will convert all to forward
          # orientation. The annotation shows then the inverse
          # complement unit of simple repeats, but such is not
          # available for satellites.
          if (
               (
                 $currentAnnot->getPctSubst() + $currentAnnot->getPctDelete() +
                 $currentAnnot->getPctInsert()
               ) > 15
              )
          {
            if ( $currentAnnot->getHitName() =~ /AAAA|\(A\)/ ) {
              if ( $currentAnnot->getRevComp() eq '+' ) {
                $currentAnnot->setHitName( "A-rich" );
              }
              else {
                $currentAnnot->setHitName( "T-rich" );
              }
            }
            elsif ( $currentAnnot->getHitName() =~ /GGGG|\(G\)/ ) {
              if ( $currentAnnot->getRevComp() eq '+' ) {
                $currentAnnot->setHitName( "G-rich" );
              }
              else {
                $currentAnnot->setHitName( "C-rich" );
              }
            }
            if ( $currentAnnot->getHitName() =~ /\([GA]+\)/ ) {
              if (
                 $currentAnnot->getSW() < (
                   $currentAnnot->getSeq2End() - $currentAnnot->getSeq2Beg() + 1
                 ) * (
                       9 - $currentAnnot->getPctSubst() * 16 / 100 - (
                                               $currentAnnot->getPctDelete() +
                                                   $currentAnnot->getPctInsert()
                           ) * 23 / 100
                 )
                  )
              {
                if ( $currentAnnot->getRevComp() eq '+' ) {
                  $currentAnnot->setHitName( "GA-rich" );
                }
                else {
                  $currentAnnot->setHitName( "CT-rich" );
                }
              }
              else {
                if ( $currentAnnot->getRevComp() eq '+' ) {
                  $currentAnnot->setHitName( "polypurine" );
                }
                else {
                  $currentAnnot->setHitName( "polypyrimidine" );
                }
              }
            }
          }
          if ( $currentAnnot->getHitName() =~ /^\(/ ) {
            my $unit = $currentAnnot->getHitName();
            $unit =~ s/\((\w+)\)n/$1/;
            my $merness = length $unit;
            if ( $currentAnnot->getRevComp() eq "C" ) {
              unless ( $currentAnnot->getHitName() =~
                       /\(TA\)|\(TTAA\)|\(CG\)|\(CCGG\)/ )
              {
                $unit = reverse $unit;
                $unit =~ tr/ACGT/TGCA/;
                $currentAnnot->setHitName( "($unit)n" );
              }
            }
            while ( $currentAnnot->getSeq2Beg() > $merness ) {
              $currentAnnot->setSeq2Beg(
                                       $currentAnnot->getSeq2Beg() - $merness );
              $currentAnnot->setSeq2End(
                                       $currentAnnot->getSeq2End() - $merness );
            }
          }

          # These are satellites labeled as simple repeats in the
          # database; hence they get through to this point
          # RMH: Why are they labeled as simple repeats?
          $currentAnnot->setRevComp( "+" )
              unless ( $currentAnnot->getHitName() =~ /HSATII|SUBTEL/ );
          if (    $currentAnnot->getHitName() eq 'HSATII'
               && $currentAnnot->getRevComp() eq "C" )
          {
            $currentAnnot->setHitName( "HSATIIrev" );
            $currentAnnot->setRevComp( '+' );
          }
          $currentAnnot->set3PrimeUnaligned( 0 );
        }
      }

      if ( $currentAnnot->getClassName() eq "Low_complexity" ) {

        # AT-rich and GC rich not strand specific
        $currentAnnot->setRevComp( '+' );
        $currentAnnot->setSeq2End(
                $currentAnnot->getSeq2End() - $currentAnnot->getSeq2Beg() + 1 );
        $currentAnnot->setSeq2Beg( 1 );
        $currentAnnot->set3PrimeUnaligned( 0 );
      }

    }

    ####################### C Y C L E 4 ###########################
    # Purpose: SINES
    ################################################################
    print STDERR "\ncycle 4 ";
    $sortedAnnotationsList->sort( \&byNameClassBeginEndrevAndSWrev );

    $i              = -1;
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();

    $DEBUG = 0;

    #printHitArrayList( $sortedAnnotationsList );

CYCLE4:
    while ( $cycleAnnotIter->hasNext() ) {
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;
      my $currentAnnot = $cycleAnnotIter->next();

      #
      # Adjust Alu subfamily names
      #
      $DEBUG = 0;
      if ( $currentAnnot->getClassName() =~ /SINE/ ) {
        if ( $DEBUG ) {
          print STDERR "BIG SINE LOOP: CONSIDERING\n";
          $currentAnnot->print();
        }

        # TODO: Consider how to extricate this meta data
        if (
             $currentAnnot->getHitName() =~ /Alu$|Alu.*_[35]/
             || (
                  $currentAnnot->getHitName() =~ /AluJ[bo]/
                  && (    $currentAnnot->getSeq2Beg() > 103
                       || $currentAnnot->getSeq2End() < 213 )
             )
            )
        {

          # Setup iterators in both directions
          my $prevIter = $cycleAnnotIter->getIterator();
          $prevIter->previous();
          my $nextIter = $cycleAnnotIter->getIterator();
          if ( $DEBUG ) {
            print STDERR "Considering SINE:\n";
            $currentAnnot->print();
          }

          # TODO: I don't like this.  There is definately
          #       a better way to consider the surrounding
          #       elements.
          # First go left
          my $count = 0;
          while (    $prevIter->hasPrevious()
                  && $count++ < 3 )
          {
            my $prevAnnot = $prevIter->previous();
            if ( $DEBUG ) {
              print STDERR "  -vs- left $count ";
              $prevAnnot->print();
            }
            last
                if ( $prevAnnot->getSeq1Name() ne $currentAnnot->getSeq1Name()
                     && $prevAnnot->getClassName() !~ /SINE/ );

            if (
                    $currentAnnot->getRevComp() eq $prevAnnot->getRevComp()
                 && $currentAnnot->getConsensusOverlap( $prevAnnot ) <= 25
                 && ( -$currentAnnot->getConsensusOverlap( $prevAnnot ) <= 10
                     || $count == 1
                     && -$currentAnnot->getConsensusOverlap( $prevAnnot ) <= 100
                     && -$currentAnnot->getQueryOverlap( $prevAnnot ) <= 25 )
                )
            {

              #print STDERR "Considering SINE:\n";
              if ( $DEBUG ) {
                print STDERR "CO="
                    . $currentAnnot->getConsensusOverlap( $prevAnnot ) . "\n";
                print STDERR "QO="
                    . $currentAnnot->getQueryOverlap( $prevAnnot ) . "\n";
                print STDERR "Before: ";
                $currentAnnot->printBrief();
                print STDERR "   with ";
                $prevAnnot->printBrief();
              }
              &ChangeAluNames( $currentAnnot, $prevAnnot );
              print STDERR "After: " . $currentAnnot->getHitName() . "\n"
                  if ( $DEBUG );
              last;
            }
          }

          # Now go right
          $count = 0;
          while (    $nextIter->hasNext()
                  && $count++ < 3 )
          {
            my $nextAnnot = $nextIter->next();
            if ( $DEBUG ) {
              print STDERR "  -vs- right $count  ";
              $nextAnnot->print();
            }
            last
                if ( $nextAnnot->getSeq1Name() ne $currentAnnot->getSeq1Name()
                     && $nextAnnot->getClassName() !~ /SINE/ );
            if (
                    $currentAnnot->getRevComp() eq $nextAnnot->getRevComp()
                 && $currentAnnot->getConsensusOverlap( $nextAnnot ) <= 25
                 && ( -$currentAnnot->getConsensusOverlap( $nextAnnot ) <= 10
                     || $count == 1
                     && -$currentAnnot->getConsensusOverlap( $nextAnnot ) <= 100
                     && -$currentAnnot->getQueryOverlap( $nextAnnot ) <= 25 )
                )
            {
              if ( $DEBUG ) {
                print STDERR "CO="
                    . $currentAnnot->getConsensusOverlap( $nextAnnot ) . "\n";
                print STDERR "Before: ";
                $currentAnnot->printBrief();
                print STDERR "   with ";
                $nextAnnot->printBrief();
              }
              &ChangeAluNames( $currentAnnot, $nextAnnot );
              print STDERR "After: " . $currentAnnot->getHitName() . "\n"
                  if ( $DEBUG );
              last;
            }
          }
        }
      }    # end adjust Alu subfamily names
    }

    ########################## C Y C L E 5 ################################
    #
    #  Join Overlapping Fragments
    #
    ########################################################################

    # Sort by name, begin position, and end position descending
    print STDERR "\ncycle 5 ";
    $sortedAnnotationsList->sort( \&byNameBeginEndrevSWrev );

    $i = -1;
    ##
    ## This "joins" overlapping fragments for all types of
    ## annotations.  This in effect replaces the FuseOverlappingSeqs sub.
    ##
    ##
    $DEBUG          = 0;
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();
    my $prevAnnot;
    while ( $cycleAnnotIter->hasNext() ) {
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;
      my $currentAnnot = $cycleAnnotIter->next();
      if ( $DEBUG ) {
        print STDERR "Overlapping Fragments Considering:\n";
        $currentAnnot->printBrief();
      }
      next if ( $currentAnnot->getClassName() =~ /Simple|Low/ );

      my $nextAnnot;
      my $proxIter   = $cycleAnnotIter->getIterator();
      my @joinList   = ();
      my $currentEnd = $currentAnnot->getSeq1End();
      my $skipUntil  = undef;
      while ( $proxIter->hasNext() ) {
        $nextAnnot = $proxIter->next();
        if ( $DEBUG ) {
          print STDERR "   -vs->: ";
          $nextAnnot->printBrief();
          print STDERR " qo = "
              . $currentAnnot->getQueryOverlap( $nextAnnot ) . "\n";
        }

        # Quit once we reach our partner
        last
            if (
                 (
                      $currentAnnot->getRightLinkedHit()
                   && $nextAnnot == $currentAnnot->getRightLinkedHit()
                 )
                 || ( !$currentAnnot->getRightLinkedHit()
                      && $currentEnd < $nextAnnot->getSeq1Beg() )
                 || $currentAnnot->getSeq1Name() ne $nextAnnot->getSeq1Name()
            );

        # ASSERT: No more recursion violations
        if ( $currentAnnot->getRightLinkedHit()
          && $currentAnnot->containsElement( $nextAnnot )
          && $nextAnnot->containsElement( $currentAnnot->getRightLinkedHit() ) )
        {
          ## Currently DNA Transposons can violate recursion rules.
          if ( $DEBUG ) {
            print STDERR "\n\n\nThis violates recursion:\nFirst:\n";
            $currentAnnot->printLeftRightLinks();
            print STDERR "Second:\n";
            $nextAnnot->printLeftRightLinks();
            print STDERR "\n\n\n";
            die;
          }
        }

        if ( $skipUntil ) {
          if ( $skipUntil == $nextAnnot ) {
            $skipUntil = undef;
          }
          else {
            print STDERR "  -- Can't consider...inside existing join\n"
                if ( $DEBUG );
            next;
          }
        }

        #
        # Join Overlapping Elements
        #
        if (
             (
               $currentEnd - $nextAnnot->getSeq1Beg() > 33
               || ( $currentAnnot->getQueryOverlap( $nextAnnot ) ==
                   ( $nextAnnot->getSeq1End() - $nextAnnot->getSeq1Beg() + 1 ) )
             )
             && $currentAnnot->getRightLinkedHit() != $nextAnnot
             && $currentAnnot->getClassName() eq $nextAnnot->getClassName()
             && $currentAnnot->getRevComp()   eq $nextAnnot->getRevComp()
            )
        {
          if ( $DEBUG ) {
            print STDERR "Adding to overlap elements cluster:\n";
            $currentAnnot->printBrief();
            $nextAnnot->printBrief();
          }
          push @joinList, $nextAnnot;
          $currentEnd = $nextAnnot->getSeq1End()
              if ( $currentEnd < $nextAnnot->getSeq1End() );
        }
        elsif ( $nextAnnot->getRightLinkedHit() ) {
          $skipUntil = $nextAnnot->getRightLinkedHit();
        }
      }    # while has next

      if ( @joinList ) {
        my $leftSide  = $currentAnnot;
        my $equivHash = {};
        foreach my $partner ( @joinList ) {
          if ( $DEBUG ) {
            print STDERR "Joining overlap cluster ---- :\n";
            $leftSide->printBrief();
            $partner->printBrief();
          }

          $leftSide->join( $partner );

          # Don't ambiguate the name unless the overlap is excessive
          # or the element is subsummed completely by the other.
          if (    $leftSide->getQueryOverlap( $partner ) > 50
               || $leftSide->getSeq1End() >= $partner->getSeq1End() )
          {
            print STDERR " ls = "
                . $leftSide->getSeq2Name()
                . " par = "
                . $partner->getSeq2Name() . "\n"
                if ( $DEBUG );
            $equivHash->{ $leftSide->getSeq2Name() } = 1;
            $equivHash->{ $partner->getSeq2Name() }  = 1;
          }
          $leftSide = $partner;
        }

        if ( keys( %{$equivHash} ) ) {
          foreach my $element ( @joinList, $currentAnnot ) {
            my $newEquivHash = { %{$equivHash} };
            if ( defined $equivHash->{ $element->getSeq2Name() } ) {
              delete $newEquivHash->{ $element->getSeq2Name() };
            }
            $element->setEquivHash( $newEquivHash );
          }
        }
      }
    }

    #printHitArrayList( $sortedAnnotationsList );
    ########################## C Y C L E 6 ################################
    #
    #  LINE/LTR/SINE Joining Algorithm
    #
    ########################################################################

    print STDERR "\ncycle 6 ";
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();
    $i              = -1;
    $DEBUG          = 0;
    while ( $cycleAnnotIter->hasNext() ) {
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;
      my $currentAnnot     = $cycleAnnotIter->next();
      my $currentHitName   = $currentAnnot->getHitName();
      my $currentClassName = $currentAnnot->getClassName();

      #
      # This is not a simple/low complexity joinging loop.
      # Skip these and do not include them in the intervening
      # divergence calculations. Also skip DNA Transposons
      # which were joined in a previous cycle.
      #
      next if ( $currentClassName =~ /^simple|low|dna/i );

      my $maxScore        = 0;
      my $maxScoringAnnot = undef;

      #
      # Do not attempt to link fragments which are already
      # pre-linked.
      #
      if ( !$currentAnnot->getRightLinkedHit() ) {
        if ( $DEBUG ) {
          print STDERR "\nCYCLE6: Considering:\n";
          $currentAnnot->print();
        }

        # Look into our future
        my $proxIter = $cycleAnnotIter->getIterator();
        my $ignoreUntil;
        my $classElementDistance  = 0;
        my $totElementDistance    = 0;
        my $highestInterveningDiv = 0;
        my $unAnnotatedBP         = 0;
        my $unAnnotatedGaps       = 0;
        my $lastDivAnnot          = undef;
        my $lastAnnot             = $currentAnnot;
        my $score                 = 0;
        while ( $proxIter->hasNext() ) {
          my $nextAnnot     = $proxIter->next();
          my $nextHitName   = $nextAnnot->getHitName();
          my $nextClassName = $nextAnnot->getClassName();

          $totElementDistance++;

          #
          # A new statistic for giving up on joins
          #    - Count all un-annoted gaps > threshold ( currently 100 )
          #    - Sum all bp in the above gaps
          #
          my $queryGap = $lastAnnot->getQueryGap( $nextAnnot );
          if ( $queryGap >= 100 ) {
            $unAnnotatedBP += $queryGap;

            # Only count a series of low/simple repeats as one gap
            if ( $currentAnnot->getClassName !~ /^simple|low/i ) {
              $unAnnotatedGaps++;
            }
          }
          $lastAnnot = $nextAnnot;

          # We don't care to record the divergence of simple/low complexity
          if (    $lastDivAnnot
               && $lastDivAnnot->getClassName() !~ /^simple|low/i )
          {
            $highestInterveningDiv = $lastDivAnnot->getPctSubst()
                if ( $highestInterveningDiv < $lastDivAnnot->getPctSubst() );
          }
          $lastDivAnnot = $nextAnnot;

          # Number of intervening elements of the same class
          $classElementDistance++ if ( $nextClassName eq $currentClassName );

          if ( $DEBUG ) {
            print STDERR " $totElementDistance -vs-> ";
            $nextAnnot->print();
            print STDERR
"     unAnnotatedBP = $unAnnotatedBP * unAnnoatedGaps = $unAnnotatedGaps < 10000\n";
          }

          #
          # Reasons we wouldn't consider this element in our cluster and
          # trigger the end to the search
          #
          #   A parent join ends at this element
          #   A much older element is reached ( higher cutlevel )
          #   A much older intervening ( any class ) element.
          #   A set of unannotated gaps exceeds our threshold
          #   When the 21st annotation is reached
          #
          if (
               $nextAnnot->containsElement( $currentAnnot )
            || $currentAnnot->getSeq1Name() ne $nextAnnot->getSeq1Name()
            || $totElementDistance > 21
            || ( $unAnnotatedBP * $unAnnotatedGaps ) > 10000
            || (

              # Think about these impacts a bit:
              # Don't give up on high intervening
              # divergence if ( LTR-int or a SINE )
              !&isInternal( $nextAnnot ) && $currentClassName !~ /SINE/
              && (
                 ( $currentAnnot->getSeq2End() - $currentAnnot->getSeq2Beg() ) >
                 50
                 && &isTooDiverged(
                                    $currentAnnot->getPctSubst(),
                                    $highestInterveningDiv
                 )
              )
            )
              )
          {
            if ( $DEBUG ) {
              print STDERR "    ---> This element is beyond our "
                  . "consideration boundary:\n";
              print STDERR "         totElementDistance = "
                  . "$totElementDistance\n";
              print STDERR "         highestInterveningDiv = "
                  . "$highestInterveningDiv\n";
              print STDERR "         unAnnotatedBP = $unAnnotatedBP\n";
              print STDERR "         unAnnotatedGaps = $unAnnotatedGaps\n";
              print STDERR "         isTooDiverged() = "
                  . &isTooDiverged( $currentAnnot->getPctSubst(),
                                    $highestInterveningDiv )
                  . "\n";
              print STDERR "         containsElement ==> "
                  . $nextAnnot->containsElement( $currentAnnot ) . "\n";
            }
            last;
          }

          #
          # Do not consider this one if it has a much lower divergence than
          # something in between.  This is the symmetric opposite of the
          # catch above.
          #
          #  TODO: Consider doing this for SINES as above
          #
          if (    !&isInternal( $nextAnnot )
               && $nextAnnot->getSeq2End() - $nextAnnot->getSeq2Beg() > 50
               && &isTooDiverged( $nextAnnot->getPctSubst(),
                                  $highestInterveningDiv ) )
          {
            if ( $DEBUG ) {
              print STDERR "   --> This has a much lower div than something "
                  . "in between: interveningHitDiv = $highestInterveningDiv\n";
            }
            next;
          }

          #
          # Move along if we are moving over a joined set of
          # fragments ( and their children ) which cannot be joined
          # to us.  This flag is set below.
          #
          #                     +--------joined------------+
          #                     |                          |
          #   --current--  -----+----   ---   ------    ---+---  -----
          #                  *skip*    *skip*  *skip*
          #
          if (    $ignoreUntil
               && $ignoreUntil != $nextAnnot )
          {
            print STDERR "   --> Ignoring joined fragments\n" if ( $DEBUG );
            next;
          }
          else {
            $ignoreUntil = undef;
          }

          #
          # Don't join fragments of different classes.
          #
          if ( $nextClassName ne $currentClassName ) {
            print STDERR "   --> Not same class...moving on\n" if ( $DEBUG );
            next;
          }

          #
          # Only elements not already linked to something before the
          # current element:
          #
          #                     +--------joined------------+
          #                     |                          |
          #   --current--  -----+----   ---   ------    ---+---  -----
          #                                              *skip*
          #
          if ( !$nextAnnot->getLeftLinkedHit() ) {
            my @currentNames = ( $currentAnnot->getSeq2Name() );
            if ( defined $currentAnnot->getEquivHash() ) {
              push @currentNames, keys( %{ $currentAnnot->getEquivHash() } );
            }

            #print STDERR "Dumper: " . Dumper(\@currentNames) . "\n";
            my @nextNames = ( $nextAnnot->getSeq2Name() );
            if ( defined $nextAnnot->getEquivHash() ) {
              push @nextNames, keys( %{ $nextAnnot->getEquivHash() } );
            }
            my $savedCName = $currentAnnot->getSeq2Name();
            my $savedNName = $nextAnnot->getSeq2Name();
            foreach my $cName ( @currentNames ) {
              print STDERR "    -->trying current name: $cName\n"
                  if ( $DEBUG );
              $currentAnnot->setSeq2Name( $cName );
              foreach my $nName ( @nextNames ) {
                print STDERR "    -->trying next name: $nName\n"
                    if ( $DEBUG );
                $nextAnnot->setSeq2Name( $nName );
                if ( $currentClassName =~ /LINE/ ) {
                  $score = &scoreLINEPair( $currentAnnot,         $nextAnnot,
                                           $classElementDistance, \%options );
                }
                elsif ( $currentClassName =~ /LTR/ ) {
                  $score =
                      &scoreLTRPair( $currentAnnot, $nextAnnot,
                                     $totElementDistance,
                                     $classElementDistance );
                }
                elsif ( $currentClassName =~ /SINE/ ) {
                  $score =
                      &scoreSINEPair( $currentAnnot, $nextAnnot,
                                      $totElementDistance,
                                      $classElementDistance );
                }
                else {
                  $score =
                      &scoreGenericPair( $currentAnnot, $nextAnnot,
                                   $totElementDistance, $classElementDistance );
                }

                if ( $score > 0 ) {
                  print STDERR "    --> Ambiguous names matched:"
                      . " $cName, $nName\n"
                      if ( $DEBUG );
                  last;
                }
              }
              last if ( $score > 0 );
            }    # foreach my $cName...

            $currentAnnot->setSeq2Name( $savedCName );
            $nextAnnot->setSeq2Name( $savedNName );
            print STDERR "    ---Wow saved one!\n"
                if ( $score > 0 && $DEBUG );

            #
            # If we found a compatable match we now look backwards
            # to see if there was a better intervening match to
            # the candidate.  I.e preserve the "best-closest-match"
            # concept.
            #
            #         +------------good-----------------+
            #         |                   +-better-+    |
            #         |                   |        |    |
            #  ----current---  -----   ---+---  ---+----+---
            #
            #  Ignore this match if there is a better intervening
            #  match.
            #
            if ( $score > 0 ) {
              print STDERR " \\----> score = $score\n" if ( $DEBUG );
              my $revIter = $proxIter->getIterator();
              $revIter->previous();
              my $inBetweenDistance    = 0;
              my $classBetweenDistance = 0;
              my $inBetweenScore       = 0;
              my $prevAnnot;
              print STDERR "   Looking backwards to see if there was a "
                  . "better match\n"
                  if ( $DEBUG );

              while ( $revIter->hasPrevious() ) {
                $prevAnnot = $revIter->previous();

                if ( $DEBUG ) {
                  print STDERR "     -vs-> ";
                  $prevAnnot->printBrief();
                }

                $inBetweenDistance++;
                $classBetweenDistance++;

                # Look backwards up to $currentAnnot
                last if ( $prevAnnot == $currentAnnot );
                next
                    if (
                  $prevAnnot->getClassName() ne $currentAnnot->getClassName() );
                if ( $currentClassName =~ /LINE/ ) {
                  $inBetweenScore = &scoreLINEPair(
                                                 $prevAnnot,         $nextAnnot,
                                                 $inBetweenDistance, \%options
                  );
                }
                elsif ( $currentClassName =~ /LTR/ ) {
                  $inBetweenScore =
                      &scoreLTRPair( $prevAnnot, $nextAnnot, $inBetweenDistance,
                                     $classBetweenDistance );
                }
                elsif ( $currentClassName =~ /SINE/ ) {
                  $inBetweenScore =
                      &scoreSINEPair( $prevAnnot, $nextAnnot,
                                      $inBetweenDistance );
                }
                else {
                  $inBetweenScore =
                      &scoreGenericPair( $prevAnnot, $nextAnnot,
                                    $inBetweenDistance, $classElementDistance );
                }

                last if ( $inBetweenScore >= $score );
              }

              if ( $inBetweenScore >= $score ) {

                # Abandon match, there is an intervening better match
                print STDERR "     \\--> Better intervening score "
                    . "$inBetweenScore\n"
                    if ( $DEBUG );
              }
              else {
                print STDERR "   ---> Sticking with first match: score=$score\n"
                    if ( $DEBUG );
                if ( $maxScore < $score ) {
                  $maxScore        = $score;
                  $maxScoringAnnot = $nextAnnot;
                }
              }
            }
          }
          else {
            if ( $DEBUG ) {
              print STDERR "   ---> Already linked to something on left"
                  . "\n        ";
              $nextAnnot->getLeftLinkedHit()->printBrief();
            }
          }

          #
          # Need to ignore all element until we reach the right-hand element.
          #
          if ( $nextAnnot->getRightLinkedHit() ) {
            print STDERR "   ---> Has right linked hit...ignoring until\n"
                if ( $DEBUG );
            $ignoreUntil = $nextAnnot->getRightLinkedHit();
          }

        }    # while ( $proxIter->hasNext()...

        if ( $maxScore > 0 ) {
          if ( $DEBUG ) {
            print STDERR " *** And the winner is: score = $maxScore\n     ";
            $maxScoringAnnot->print();
          }
          $currentAnnot->setRightLinkedHit( $maxScoringAnnot );
          $maxScoringAnnot->setLeftLinkedHit( $currentAnnot );
        }

      }
    }
    $DEBUG = 0;

    #printHitArrayList( $sortedAnnotationsList );

    ########################## C Y C L E 7 ################################
    #
    #  Name joined LINE/LTR clusters
    #
    ########################################################################

    print STDERR "\ncycle 7 ";

    ##
    ## Name joined fragments & pick consensus adjustment
    ##
    ##   The name of a chain is determined by the highest scoring
    ##   fragment in the highest priority model group.  The model
    ##   groups are ( in order of priority ) 3-Prime End Models,
    ##   5-Prime End Models, ORF Models, and Undesignated Models.
    ##
    ##   Also the consensus adjustment is calculated by finding
    ##   the highest consensus adjustment from conPosCorrection
    ##   for the given fragment chain.
    ##
    $DEBUG          = 0;
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();
    $i              = -1;
    while ( $cycleAnnotIter->hasNext() ) {
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;
      my $currentAnnot = $cycleAnnotIter->next();

      # We only care about LINES right now
      next if ( $currentAnnot->getSeq2Name !~ /LINE|LTR/ );

      # Consider only left ( from our direction of iteration )
      # fragment ends
      if ( $currentAnnot->getRightLinkedHit()
           && !$currentAnnot->getLeftLinkedHit()
           || !$currentAnnot->getLeftLinkedHit()
           && !$currentAnnot->getRightLinkedHit() )
      {
        my @elements = ();
        push @elements, $currentAnnot;

        # Follow links until end
        my $nextInChain    = $currentAnnot;
        my $highestConCorr = $conPosCorrection{ $nextInChain->getID() };
        if ( $DEBUG ) {
          print STDERR "Naming Current:\n";
          $currentAnnot->print();
        }
        while ( $nextInChain ) {
          if ( $DEBUG ) {
            print STDERR " -- ";
            $nextInChain->print();
            print STDERR "   \\--- ID="
                . $nextInChain->getID()
                . " con{ID} = "
                . $conPosCorrection{ $nextInChain->getID() }
                . " highest = "
                . $highestConCorr . "\n";
          }
          push @elements, $nextInChain;
          $highestConCorr = $conPosCorrection{ $nextInChain->getID() }
              if (
                 $conPosCorrection{ $nextInChain->getID() } > $highestConCorr );
          $nextInChain = $nextInChain->getRightLinkedHit();
        }
        $nextInChain = $elements[ $#elements ];

        # LTR or LINE
        my $newLINEName   = "";
        my $newLTRName    = "";
        my $newLTRIntName = "";
        if ( $currentAnnot->getClassName =~ /LTR/ ) {
          @elements =
              sort {
            isLTR( $b ) <=> isLTR( $a )
                || $b->getSW() <=> $a->getSW();
              } @elements;
          my $winner = $elements[ 0 ];
          $newLTRName = $winner->getHitName() if ( isLTR( $winner ) );

          @elements =
              sort {
            isInternal( $b ) <=> isInternal( $a )
                || $b->getSW() <=> $a->getSW();
              } @elements;
          $winner = shift @elements;
          $newLTRIntName = $winner->getHitName() if ( isInternal( $winner ) );
          $newLTRIntName =~ s/-int//g;
        }
        else {
          @elements =
              sort {
            my $nameA = $a->getSeq2Name();
            my $nameB = $b->getSeq2Name();
            ( $nameA ) = ( $nameA =~ /(_5end|_3end|_orf2)/ );
            ( $nameB ) = ( $nameB =~ /(_5end|_3end|_orf2)/ );
            $nameA = "_zzz" if ( $nameA eq "" );
            $nameB = "_zzz" if ( $nameB eq "" );
            $nameA cmp $nameB || $b->getSW() <=> $a->getSW();
              } @elements;
          my $winner = shift @elements;
          $newLINEName = $winner->getSeq2Name();
        }

        # Now change the names
        while ( $nextInChain ) {
          if ( $currentAnnot->getClassName() =~ /LTR/ ) {
            if ( isInternal( $nextInChain ) ) {
              if (    $newLTRName
                   && $nextInChain->getClassName() =~ /MaLR/ )
              {

                # Name after LTR
                $nextInChain->setHitName( $newLTRName . "-int" );
              }
              elsif ( $newLTRIntName ) {

                # Name after highest scoring internal
                $nextInChain->setHitName( $newLTRIntName . "-int" );
              }
            }
            else {
              $nextInChain->setHitName( $newLTRName );
            }
          }
          else {
            $nextInChain->setSeq2Name( $newLINEName );
          }
          if ( $DEBUG ) {
            print STDERR "Fixing conPosCorrection(*$highestConCorr): ";
            $nextInChain->print();
          }
          $conPosCorrection{ $nextInChain->getID() } = $highestConCorr;
          $nextInChain = $nextInChain->getLeftLinkedHit();
        }    # while ( $nextInChain...
      }
    }
    $DEBUG = 0;

    #printHitArrayList( $sortedAnnotationsList );

    ########################## C Y C L E 8 ################################
    #
    #  Merge overlapping fragments
    #
    ########################################################################

    print STDERR "\ncycle 8 ";

    ##
    ## Merge joined overlapping fragments into one fragment
    ##
    ##   This is basically the old FuseOverlappingSeqs routine.
    ##   The process is basically a cosmetic one -- simplifying
    ##   the output.
    ##
    ##  Sort by class?
    ##
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();
    my $prevAnnot;
    $DEBUG = 0;
    $i     = -1;
    while ( $cycleAnnotIter->hasNext() ) {

      # Pick one element
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;
      my $currentAnnot = $cycleAnnotIter->next();

      if ( $DEBUG ) {
        print STDERR "Considering:\n";
        $currentAnnot->print();
      }

      my $proxIter  = $cycleAnnotIter->getIterator();
      my $lookAhead = 0;
      while ( $proxIter->hasNext() ) {
        my $next1Annot = $proxIter->next();

        if ( $DEBUG ) {
          print STDERR "  --vs-->";
          $next1Annot->print();
          print STDERR "      query Gap = "
              . $currentAnnot->getQueryGap( $next1Annot ) . "\n";
        }

        # TODO: Now this is specific for SVA...need to generalize this for
        #       anything which contains a tandem repeat unit.
        last
            if (
                 $next1Annot->getSeq1Name() ne $currentAnnot->getSeq1Name()
                 || (    $currentAnnot->getHitName !~ /SVA/
                      && $currentAnnot->getQueryGap( $next1Annot ) > 10 )
                 || (    $currentAnnot->getHitName() =~ /SVA/
                      && $lookAhead++ > 2 )
            );

        next
            if ( $next1Annot->getClassName() ne $currentAnnot->getClassName() );

        my $next2Annot = undef;
        if ( $proxIter->hasNext() ) {
          $next2Annot = $proxIter->next();
          $proxIter->previous();

          # So as to emit the one we will delete
          $proxIter->previous();
          $proxIter->next();
        }

        my $QO = $currentAnnot->getQueryOverlap( $next1Annot );

        #
        # SVAs
        #
        #   - Special because they contain a vntr region.  This region
        #     behaves in a similar way to satellites or simple repeats.
        #     As a consequence we have to allow a lessor overlap??
        #   - also can have different cut levels due to it's placement in
        #     the Alu(SINES) search phase.....hmmm.
        #   - Lastly these are not joined yet.
        #   - Query Gap < 10bp
        #
        if (    $currentAnnot->getHitName() =~ /SVA/
             && $next1Annot->getHitName() =~ /SVA/ )
        {
          if (    $currentAnnot->getRevComp() eq "C"
               && $currentAnnot->getSeq2End() > 425
               && $next1Annot->getSeq2End() < 880
               || $currentAnnot->getRevComp() eq "+"
               && $currentAnnot->getSeq2Beg() < 880
               && $next1Annot->getSeq2Beg() > 425 )
          {

            # rest taken care of elsewhere
            if ( $QO >= -10 ) {
              if ( $DEBUG ) {
                print STDERR "SVA merging:\n";
                $currentAnnot->print();
                $next1Annot->print();
              }
              $currentAnnot->merge( $next1Annot );
              $currentAnnot->addDerivedFromAnnot( $next1Annot )
                  if ( $options{'source'} );
              $proxIter->remove();
            }
            else {
              if ( $DEBUG ) {
                print STDERR "SVA joining\n";
                $currentAnnot->print();
                $next1Annot->print();
              }
              $currentAnnot->join( $next1Annot );
              last;
            }
          }
        }
        elsif (    $currentAnnot->getClassName() =~ /Simple|Satellite/
                && $QO >= -10 )
        {

          # Simple Repeats and Satellites
          my $thislength =
              $currentAnnot->getSeq2End() - $currentAnnot->getSeq2Beg() + 1;
          my $lastlength =
              $next1Annot->getSeq2End() - $next1Annot->getSeq2Beg() + 1;
          if ( $DEBUG ) {
            print STDERR "    Simple/Satellite";
          }
          if ( $next1Annot->getSeq1End() >= $currentAnnot->getSeq1End() ) {
            if ( $currentAnnot->getHitName() ne $next1Annot->getHitName() ) {
              my $nextoverlap = 0;
              if ( $next2Annot ) {
                if ( $DEBUG ) {
                  print STDERR "  --next->:";
                  $next2Annot->printBrief();
                }

                # don't fuse (CA)n(TG)n(CA)n etc
                my $tempname = quotemeta $next1Annot->getHitName();
                if (    $next2Annot->getSeq2Name() =~ /$tempname/
                     && $next1Annot->getSeq1Name() eq $next2Annot->getSeq1Name()
                     && $next2Annot->getSeq1Beg() < $next1Annot->getSeq1End() )
                {
                  $nextoverlap = $currentAnnot->getQueryOverlap( $next2Annot );
                }
              }

              #print STDERR " QO=$QO, thislength = $thislength, " .
              #             "nextoverlap = $nextoverlap\n" if ( $DEBUG );
              if (
                $QO + $nextoverlap > 10
                &&

                # just to be sure it's not 0 in the following division
                $thislength / ( $QO + $nextoverlap ) < 2
                  )
              {
                print STDERR "  --> merging!\n" if ( $DEBUG );
                $currentAnnot->mergeSimpleLow( $next1Annot );
                $currentAnnot->addDerivedFromAnnot( $next1Annot )
                    if ( $options{'source'} );
                $proxIter->remove();
              }
            }
            else {
              print STDERR "  --> merging!\n" if ( $DEBUG );
              $currentAnnot->mergeSimpleLow( $next1Annot );
              $currentAnnot->addDerivedFromAnnot( $next1Annot )
                  if ( $options{'source'} );
              $proxIter->remove();
            }
          }
        }

        # See if they overlap by some obvious amount
        if ( $currentAnnot->getSeq1End() - $next1Annot->getSeq1Beg() + 1 > 33 )
        {
          print STDERR "     -- a big overlap...is it already linked?\n"
              if ( $DEBUG );
          if ( $currentAnnot->getRightLinkedHit() == $next1Annot ) {
            if ( $DEBUG ) {
              print STDERR "Merging a joined pair:\n";
              $currentAnnot->print();
              $next1Annot->print();
            }
            $currentAnnot->merge( $next1Annot );

            #print STDERR "Adding derived:\n";
            #$currentAnnot->print();
            #$next1Annot->print();
            $currentAnnot->addDerivedFromAnnot( $next1Annot )
                if ( $options{'source'} );
            $proxIter->remove();
            if ( $DEBUG ) {
              print STDERR "  Outcome:\n";
              $currentAnnot->print();
            }
            if (    $conPosCorrection{ $currentAnnot->getID() }
                 && $currentAnnot->getSeq2Beg() < $next1Annot->getSeq2Beg() )
            {
              $conPosCorrection{ $next1Annot->getID() } =
                  $conPosCorrection{ $currentAnnot->getID() };
            }
          }
          elsif ( $DEBUG ) {
            print STDERR "      No!\n";

            #$currentAnnot->printLinks();
          }

          # If they don't....then try again with a not so obvious
          # check
        }
        elsif (
                   $currentAnnot->getRightLinkedHit() == $next1Annot
                && $currentAnnot->getRevComp() eq $next1Annot->getRevComp()
                && $currentAnnot->getLastField == $next1Annot->getLastField()
                && $currentAnnot->getQueryGap( $next1Annot ) <= 10
                && $currentAnnot->getConsensusGap( $next1Annot ) <= 100
                && (    $currentAnnot->getConsensusOverlap( $next1Annot ) <= 20
                     || $currentAnnot->getQueryGap( $next1Annot ) < 0
                     && $currentAnnot->getConsensusOverlap( $next1Annot ) -
                     $currentAnnot->getQueryOverlap( $next1Annot ) <= 20 )
            )
        {

          # Fuse all remaining neighboring closely related elements that
          # overlap or nearly join in the query and have small gaps or tiny
          # overlaps in the consensus. This simlplifies the output, though
          # there is a further disconnect with the alignments. Since this is
          # largely a cosmetic action, selectivity trumps sensitivity.
          #
          # TODO: Arian suggested that we only join these if the pctDel
          #       does not exceed some threshold.  This limit would keep
          #       fragments from merging if they contain more info as
          #       independent annotations.
          #
          # TODO: In the past we also made sure we weren't merging fragments
          #       with names that are sufficiently different.  Now we
          #       already have made all our joins and unified the names
          #       so this is irrelevant?
          if ( $DEBUG ) {
            print STDERR "SHOULD MERGE THESE TWO:\n";
            $currentAnnot->printBrief();
            $next1Annot->printBrief();
          }
          $currentAnnot->merge( $next1Annot );
          $currentAnnot->addDerivedFromAnnot( $next1Annot )
              if ( $options{'source'} );
          $proxIter->remove();
          if ( $DEBUG ) {
            print STDERR "  Outcome:\n";
            $currentAnnot->print();
          }
          if (    $conPosCorrection{ $currentAnnot->getID() }
               && $currentAnnot->getSeq2Beg() < $next1Annot->getSeq2Beg() )
          {
            $conPosCorrection{ $next1Annot->getID() } =
                $conPosCorrection{ $currentAnnot->getID() };
          }
        }    # Merge close fragments
        elsif ( $DEBUG ) {
          print STDERR "     Don't merge: qo = "
              . $currentAnnot->getQueryOverlap( $next1Annot )
              . " co = "
              . $currentAnnot->getConsensusOverlap( $next1Annot )
              . " linked = ";
          if ( $currentAnnot->getRightLinkedHit() == $next1Annot ) {
            print STDERR "yes";
          }
          else {
            print STDERR "no";
          }
          print STDERR "\n";
        }
      }    # while proxIter->hasNext()...

    }

    #printHitArrayList( $sortedAnnotationsList );

    ########################## C Y C L E 9 ################################
    #
    #  Remove things included in other things???
    #  LINE Recombinants
    #  Unhide elements inserted inside other hits
    #
    ########################################################################

    print STDERR "\ncycle 9 ";

    $sortedAnnotationsList->sort( \&byNameBeginEndrevSWrev );

    $i              = -1;
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();

    $DEBUG = 0;

CYCLE9:
    while ( $cycleAnnotIter->hasNext() ) {
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;
      my $currentAnnot = $cycleAnnotIter->next();

      if ( $DEBUG ) {
        print STDERR "Cycle9: Considering: ";
        $currentAnnot->print();
      }

      #
      # Remove fragments contained by a previous annotation
      #
      my $pastIter = $cycleAnnotIter->getIterator();
      $pastIter->previous();
      my $k = 1;
      while ( $k++ < 10 && $pastIter->hasPrevious() ) {
        my $pastAnnot = $pastIter->previous();
        if ( $currentAnnot->getSeq1Name() eq $pastAnnot->getSeq1Name() ) {
          my $currentClassName = $currentAnnot->getClassName();
          if (
               $currentAnnot->getLastField() eq $pastAnnot->getLastField()
               && (
                  $currentAnnot->getSeq1End() <= $pastAnnot->getSeq1End()
                  && ( $currentAnnot->getSeq2Name() eq $pastAnnot->getSeq2Name()
                       || $currentAnnot->getSeq2Name() =~ /LTR8$/
                       && $pastAnnot->getSeq2Name()    =~ /Harlequin/ )
                  || (
                    (
                         $currentAnnot->getSeq1End() == $pastAnnot->getSeq1End()
                      || $currentAnnot->getSeq1Beg() == $pastAnnot->getSeq1Beg()
                    )
                    && $pastAnnot->getClassName() =~ /$currentClassName/
                  )
               )
              )
          {
            if ( $DEBUG ) {
              print STDERR "1Removing because it's included in the previous!\n";
              $pastAnnot->print();
              $currentAnnot->print();
            }
            if ( $pastAnnot->getRightLinkedHit() == $currentAnnot ) {
              print STDERR "Relinking the past\n" if ( $DEBUG );
              $pastAnnot->setRightLinkedHit(
                                           $currentAnnot->getRightLinkedHit() );
              if ( $currentAnnot->getRightLinkedHit() ) {
                $currentAnnot->getRightLinkedHit()
                    ->setLeftLinkedHit( $pastAnnot );
              }
            }
            else {    ###  What should be done with these?  They may have linked
              ###  partners.
            }
            $currentAnnot->removeFromJoins();
            $pastAnnot->addDerivedFromAnnot( $currentAnnot )
                if ( $options{'source'} );
            $cycleAnnotIter->remove();
            next CYCLE9;
          }
          elsif (
                     $currentAnnot->getLastField() == 4
                  && $pastAnnot->getLastField() == 5
                  && $currentAnnot->getSeq2Name() eq $pastAnnot->getSeq2Name()
                  && ( $currentAnnot->getSeq1End() == $pastAnnot->getSeq1End()
                    || $currentAnnot->getSeq1Beg() == $pastAnnot->getSeq1Beg() )
              )
          {
            if ( $DEBUG ) {
              print STDERR "2Removing because it's included in the previous!\n";
              $pastAnnot->print();
              $currentAnnot->print();
            }
            if ( $pastAnnot->getRightLinkedHit() == $currentAnnot ) {
              print STDERR "Relinking the past\n" if ( $DEBUG );
              $pastAnnot->setRightLinkedHit(
                                           $currentAnnot->getRightLinkedHit() );
              if ( $currentAnnot->getRightLinkedHit() ) {
                $currentAnnot->getRightLinkedHit()
                    ->setLeftLinkedHit( $pastAnnot );
              }
            }    # See above
            $currentAnnot->removeFromJoins();
            $pastAnnot->addDerivedFromAnnot( $currentAnnot )
                if ( $options{'source'} );
            $cycleAnnotIter->remove();
            next CYCLE9;
          }
        }
        else {
          last;
        }
      }

      # March 2004; moved this block to so that recombined elements
      # with inserts can be joined properly.
      # I have seen insertions in human vs chimp (and chimp vs human) in
      # which the gap in the consensus was up to 175 bp
      # With new ORF2 consensus seqs less chance of false joining and more
      # consistent divergence of fragments, I've reset the allowed gap in the
      # consensus from 33 to a calculated distance based on difference in
      # divergence level, gap between fragments in query sequence. The gap
      # allowed is doubled when the fragments have the same subfamily
      # designation.
      if ( $currentAnnot->getClassName =~ /^LINE\/L1/ ) {

        # special case of (the quite common case of) LINEs integrated
        # after recombination this appears as an inversion of part of
        # the element giving a <- -> structure. matchL1frags() matches
        # up IDs of fragments and improves subfamily name if possible.
        # This is not seen in L2,L3 (Perhaps in L4; don't know yet)
        my $pastIter = $cycleAnnotIter->getIterator();
        $pastIter->previous();
        my $forwIter = $cycleAnnotIter->getIterator();
        my $n        = 1;
        my $matched  = 0;
        while ( $n++ < 6 ) {
          my $pastAnnot = undef;
          my $pastAnnot = $pastIter->previous() if ( $pastIter->hasPrevious() );
          my $nextAnnot = undef;
          my $nextAnnot = $forwIter->next() if ( $forwIter->hasNext() );

          if (    $pastAnnot
               && $currentAnnot->getSeq1Name() eq $pastAnnot->getSeq1Name()
               && $pastAnnot->getClassName()   eq "LINE/L1"
               && $currentAnnot->getSeq1Beg() - $pastAnnot->getSeq1End() <= 20
               && $currentAnnot->getRevComp() eq '+'
               && $pastAnnot->getRevComp()    eq "C" )
          {
            my $gap = $currentAnnot->getSeq1Beg() - $pastAnnot->getSeq1End();

            # Overlaps always indicate false extension; neither bad nor good
            $gap = 0 if ( $gap < 0 );

            # The more different the divergence and the further apart
            # the fragments, the stricter the requirements
            my $gapallowed = 175 - 20 *
                abs( $currentAnnot->getPctSubst() - $pastAnnot->getPctSubst() )
                - 5 * $gap;

            # Same subfamily name is a big bonus
            $gapallowed += 50
                if ( $currentAnnot->getHitName() eq $pastAnnot->getHitName() );

            if (
              $currentAnnot->getSeq2End() - $pastAnnot->getSeq2Beg() <
              $gapallowed / 2
              &&    # overlap should be smaller, but ones seen up to 46 bp
              $pastAnnot->getSeq2Beg() - $currentAnnot->getSeq2End() <
              $gapallowed
                )
            {
              if (   &areLINENamesCompat( $currentAnnot, $pastAnnot )
                  || $currentAnnot->getHitName() =~ /^L1.*_3end$/
                  && $currentAnnot->getSeq2End() < 6015
                  && $pastAnnot->getSeq2End() - $pastAnnot->getSeq2Beg() > 100 )
              {
                $matched = $pastAnnot;
                last;
              }
            }
          }
          elsif (   $nextAnnot
                 && $nextAnnot->getSeq2Name() =~ /LINE\/L1/
                 && $currentAnnot->getSeq1Name() eq $nextAnnot->getSeq1Name()
                 && $nextAnnot->getSeq1Beg() - $currentAnnot->getSeq1End() <= 20
                 && $currentAnnot->getRevComp() eq "C"
                 && $nextAnnot->getRevComp()    eq '+' )
          {
            my $gap = $nextAnnot->getSeq1Beg() - $currentAnnot->getSeq1End();
            $gap = 0 if ( $gap < 0 );

            my $gapallowed = 175 - 20 *
                abs( $currentAnnot->getPctSubst() - $nextAnnot->getPctSubst() )
                - 5 * $gap;

            $gapallowed += 50
                if ( $nextAnnot->getHitName() eq $currentAnnot->getHitName() );

            if ( $currentAnnot->getSeq2End() - $nextAnnot->getSeq2Beg() <
                    $gapallowed / 2
                 && $nextAnnot->getSeq2Beg() - $currentAnnot->getSeq2End <
                 $gapallowed )
            {
              if (   &areLINENamesCompat( $currentAnnot, $nextAnnot )
                  || $currentAnnot->getHitName() =~ /^L1.*_3end$/
                  && $currentAnnot->getSeq2End() < 6015
                  && $nextAnnot->getSeq2End() - $nextAnnot->getSeq2Beg() > 100 )
              {
                $matched = $nextAnnot;
                last;
              }
            }
          }
        }
        if ( $matched ) {
          ## TODO: This code should be moved before line clusters
          ##       are named and corrections are determined.  This
          ##       would reduce having to do this twice.
          if ( $DEBUG ) {
            print STDERR "Joining recombinant L1's:\n";
            $matched->print();
            $currentAnnot->print();
          }
          my $highestConsCorrection = $conPosCorrection{ $matched->getID() };
          $highestConsCorrection = $conPosCorrection{ $currentAnnot->getID() }
              if ( $conPosCorrection{ $currentAnnot->getID() } >
                   $highestConsCorrection );
          $currentAnnot->join( $matched );

          # Fix left
          my $chainNext  = $currentAnnot;
          my $detectLoop = 0;
          while (    $chainNext->getLeftLinkedHit() != undef
                  && $detectLoop < 50 )
          {
            $chainNext = $chainNext->getLeftLinkedHit();
            $conPosCorrection{ $chainNext->getID() } = $highestConsCorrection;
            $detectLoop++;
          }

          # Fix right
          $chainNext  = $currentAnnot;
          $detectLoop = 0;
          while (    $chainNext->getRightLinkedHit() != undef
                  && $detectLoop < 50 )
          {
            $chainNext = $chainNext->getRightLinkedHit();
            $conPosCorrection{ $chainNext->getID() } = $highestConsCorrection;
            $detectLoop++;
          }

          # Fix current
          $conPosCorrection{ $currentAnnot->getID() } = $highestConsCorrection;

          $currentAnnot->setHitName( $matched->getSeq2Name() );
          if ( $DEBUG ) {
            print STDERR "Result:";
            $currentAnnot->print();
          }
        }
      }    # if ( $ClassName =~ /^LINE\/L1/...

      unless ( $options{'noint'} ) {

        my $flankingIter = $cycleAnnotIter->getIterator();
        $flankingIter->previous();
        my $prevAnnot = undef;
        if ( $flankingIter->hasPrevious ) {
          $prevAnnot = $flankingIter->previous();
          $flankingIter->next();
        }
        $flankingIter->next();
        my $nextAnnot = undef;
        if ( $flankingIter->hasNext() ) {
          $nextAnnot = $flankingIter->next();
          $flankingIter->previous();
        }

        &adjustSINEName( $prevAnnot, $currentAnnot, $nextAnnot,
                         \%RepeatAnnotationData::repeatDB, \%options );

        #
        # unhide elements inserted in older elements by breaking up the
        # older elements.
        #
        #  ie.      ---------LINE--------------------
        #                  ------LTR-----------
        #
        # These would not get fused in the previous code because
        # they are of different classes. Now we need to decide
        # if the LINE above should be broken up?
        #
        my $newSeq2Begin = $currentAnnot->getSeq2Beg();
        my $newSeq2End   = $currentAnnot->getSeq2End();
        my @inserts      = ();

        # Look for all elements inserted in this entry
        # we're estimating the position(s) in Seq2 where the
        # insertion(s) took place from the position(s) in Seq1
        # Look into the future until
        #    - The future element isn't contained inside the current one.
        #    - We have moved into a new query sequence.
        my $j             = 0;
        my $prevNextAnnot = undef;
        if ( $DEBUG ) {
          print STDERR "Unhide Inserts:\n";
        }
        while ( $flankingIter->hasNext() ) {
          $j++;
          $nextAnnot = $flankingIter->next();
          if ( $DEBUG ) {
            print STDERR " --vs-->";
            $nextAnnot->print();
          }
          last
              if (  $nextAnnot->getSeq1End() > $currentAnnot->getSeq1End()
                 || $nextAnnot->getSeq1Name() ne $currentAnnot->getSeq1Name() );

          # Same class and last field????  Shouldn't these already
          # have been caught?
          if (
               $nextAnnot->getSeq2Name() =~ $currentAnnot->getClassName()
            && $currentAnnot->getLastField() == $nextAnnot->getLastField()

            ||    # i.e. ignore not yet eliminated overlapping matches to the
                  # same element
            $nextAnnot->getSeq1Beg() < $currentAnnot->getSeq1Beg()
            ## TODO ASSERT:  IF $sortedHits[ $j ]->getSeq1Beg()
            ##                  < $BeginAlign
              )
          {
            next;
          }

          # Too close to the beginning -- just shift it along
          elsif (  $j == 1
                && $nextAnnot->getSeq1Beg() <= $currentAnnot->getSeq1Beg() + 5 )
          {

            # Only 5 bp or less before insertion; move BeginAlign after
            # this element
            if ( $DEBUG ) {
              print STDERR "Only 5bp or less...begin extension...clipping it\n";
            }
            my $diff = $nextAnnot->getSeq1Beg() - $currentAnnot->getSeq1Beg();
            if ( $currentAnnot->getRevComp() eq '+' ) {
              $currentAnnot->setSeq2Beg( $currentAnnot->getSeq2Beg() + $diff );
            }
            else {
              $currentAnnot->setSeq2End( $currentAnnot->getSeq2End() - $diff );
            }
            $currentAnnot->setSeq1Beg( $nextAnnot->getSeq1End() + 1 );
            if ( $DEBUG ) {
              print STDERR "Now:\n";
              $currentAnnot->print();
            }

            # There are cases where exposing an insert by cutting back the
            # begin position will change the sort order of a previously joined
            # set of fragments.  Obvioulsy you don't want a left join
            # pointing to something on the right.
            $currentAnnot->resortJoins();
            next;
          }

          # Too close to the end -- just shift it along
          elsif ( $nextAnnot->getSeq1End() >= $currentAnnot->getSeq1End() - 5 )
          {

            # Only 5 bp or less after insertion; change EndAlign to
            # just before this element

            # First remove invalidated inserts
            while ( ( $nextAnnot->getSeq1Beg() - 1 ) < $inserts[ $#inserts ] ) {

              # Remove insert
              pop @inserts;
              pop @inserts;
            }

            if ( $DEBUG ) {
              print STDERR "Only 5bp or less...end extension...clipping it\n";
            }
            my $diff = $currentAnnot->getSeq1End() - $nextAnnot->getSeq1End();

            # could do + 1, but penalty for gap == match to X
            if ( $currentAnnot->getRevComp() eq 'C' ) {
              $currentAnnot->setSeq2Beg( $currentAnnot->getSeq2Beg() + $diff );
            }
            else {
              $currentAnnot->setSeq2End( $currentAnnot->getSeq2End() - $diff );
            }
            $currentAnnot->setSeq1End( $nextAnnot->getSeq1Beg() - 1 );
            $currentAnnot->resortJoins();
          }
          else {

            # Do not consider inserts within previous inserts
            #  ie.   ------------------------
            #             -----------------
            #                 -----------
            if (    $prevNextAnnot
                 && $nextAnnot->getSeq1End() < $prevNextAnnot->getSeq1End() )
            {
              next;
            }

            # Immediate (i.e. within 5 bp) flanking inserts are merged
            if (   $prevNextAnnot
                && $nextAnnot->getSeq1Beg() < $prevNextAnnot->getSeq1End() + 5 )
            {

              # replace last insert end with current one; use last insert start
              pop @inserts;
            }
            else {
              push( @inserts, $nextAnnot->getSeq1Beg() );
            }
            print STDERR "Pushing into inserts\n" if ( $DEBUG );
            push( @inserts, $nextAnnot->getSeq1End() );
          }
          $prevNextAnnot = $nextAnnot;
        }    # while loop

        if ( @inserts ) {
          my $lengthQmatch =
              $currentAnnot->getSeq1End() - $currentAnnot->getSeq1Beg() + 1;
          for ( my $m = 0 ; $m < $#inserts ; $m += 2 ) {

            #print STDERR " inserts[ m, m+1 ] = " . $inserts[$m] . ", " .
            #             $inserts[ $m + 1 ] . "\n";
            my $endInsert = $currentAnnot->getSeq1End();
            $endInsert = $inserts[ $m ] if ( $inserts[ $m ] < $endInsert );
            $lengthQmatch -= ( $inserts[ $m + 1 ] - $endInsert );
            --$inserts[ $m ];    # now last position of
            ++$inserts[ $m + 1 ];
          }
          my $bpHitperbpQuery =
              ( $currentAnnot->getSeq2End() - $currentAnnot->getSeq2Beg() + 1 )
              / $lengthQmatch;

          if ( $DEBUG ) {
            print STDERR "Total inserts = " . scalar( @inserts ) . "\n"
                if ( $DEBUG );
            print STDERR "lengthQMatch = $lengthQmatch  bpHitperbpQuery = "
                . $bpHitperbpQuery . "\n";
          }

          my @edges = @inserts;
          unshift( @edges, $currentAnnot->getSeq1Beg() );
          push( @edges, $currentAnnot->getSeq1End() );

          my $outline = "";

          if ( $DEBUG ) {
            print STDERR "   Fragmenting:\n";
          }
          $cycleAnnotIter->remove();
          my $newHit     = undef;
          my $lastNewHit = $currentAnnot->getLeftLinkedHit();
          for ( my $m = 0 ; $m < $#edges ; $m += 2 ) {
            my $newBeginAlign = $edges[ $m ];
            my $newEndAlign   = $edges[ $m + 1 ];
            if ( $DEBUG ) {
              print STDERR "     newBeginAlign = $newBeginAlign\n";
              print STDERR "     newEndAlign = $newEndAlign\n";
            }
            my $fragsize = sprintf( "%d",
                                    ( $newEndAlign - $newBeginAlign ) *
                                        $bpHitperbpQuery );
            print STDERR "     frag size = $fragsize\n" if ( $DEBUG );
            if ( $currentAnnot->getRevComp() eq '+' ) {
              $newHit = $currentAnnot->clone();

              # We don't want to alter the final end position of the
              # original match
              if ( $m < $#edges - 2 ) {
                $newSeq2End = $newSeq2Begin + $fragsize;
                my $remainder = $currentAnnot->getSeq2Len() - $newSeq2End;
                $newHit->set3PrimeUnaligned( $remainder );
                $newHit->setSeq2End( $newSeq2End );
              }
              $newHit->setSeq1End( $newEndAlign );
              $newHit->setSeq1Beg( $newBeginAlign );
              $newHit->setSeq2Beg( $newSeq2Begin );
              $newSeq2Begin = $newSeq2End + 1;
            }
            else {
              $newHit = $currentAnnot->clone();
              if ( $m < $#edges - 2 ) {
                my $remainder = $currentAnnot->getSeq2Len() - $newSeq2End;
                $newSeq2Begin = $newSeq2End - $fragsize;    # estimate
                $newHit->setSeq2Beg( $newSeq2Begin );
                $newHit->set3PrimeUnaligned( $remainder );
              }
              $newHit->setSeq1Beg( $newBeginAlign );
              $newHit->setSeq1End( $newEndAlign );
              $newHit->setSeq2End( $newSeq2End );
              $newSeq2End = $newSeq2Begin - 1;
            }
            if ( $lastNewHit ) {
              $newHit->setLeftLinkedHit( $lastNewHit );
              $lastNewHit->setRightLinkedHit( $newHit );
            }
            if ( $DEBUG ) {
              print STDERR "Inserting\n";
              $newHit->print();

              #print STDERR "    Linked to left:";
              #$newHit->getLeftLinkedHit()->printBrief()
              #    if ( $newHit->getLeftLinkedHit() );
              #print STDERR "\n    Linked to right:";
              #$newHit->getRightLinkedHit()->printBrief()
              #    if ( $newHit->getRightLinkedHit() );
              #print STDERR "\n";

            }
            $cycleAnnotIter->insert( $newHit );
            $lastNewHit = $newHit;
          }    # for loop
          $newHit->addDerivedFromAnnot( $currentAnnot )
              if ( $options{'source'} );
          if ( $newHit->getRightLinkedHit() ) {
            $newHit->getRightLinkedHit()->setLeftLinkedHit( $newHit );
          }
        }    # if @inserts
      }
    }

    #printHitArrayList( $sortedAnnotationsList );
    ########################## C Y C L E 10 ################################
    #
    #
    ########################################################################

    print STDERR "\ncycle 10 ";
    $sortedAnnotationsList->sort( \&byNameBeginEndrevSWrev );

    $i              = -1;
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();

    $DEBUG = 0;

    # Local to cycle
    my $pastAnnot = undef;
    my $lastid    = 0;

    # Globals created for stats
    my %totlength       = ();
    my %uniqCount       = ();
    my %checked         = ();
    my $seq_cnt         = 0;
    my $frac_GC         = 0;
    my $totseqlen       = 0;
    my $nonNSeqLen      = 0;
    my $totalSeqLen     = 0;
    my $maskedpercent   = 0;
    my $maskedlength    = 0;
    my $sinecnt         = 0;
    my $sinelength      = 0;
    my $linecnt         = 0;
    my $linelength      = 0;
    my $lineCR1cnt      = 0;
    my $lineCR1length   = 0;
    my $lineIcnt        = 0;
    my $lineIlength     = 0;
    my $lineR2cnt       = 0;
    my $lineR2length    = 0;
    my $lineRTEcnt      = 0;
    my $lineRTElength   = 0;
    my $ltrcnt          = 0;
    my $ltrlength       = 0;
    my $ltrERVcnt       = 0;
    my $ltrERVlength    = 0;
    my $ltrBELcnt       = 0;
    my $ltrBELlength    = 0;
    my $ltrGYPcnt       = 0;
    my $ltrGYPlength    = 0;
    my $dnacnt          = 0;
    my $dnalength       = 0;
    my $dnaHATcnt       = 0;
    my $dnaHATlength    = 0;
    my $dnaTC1cnt       = 0;
    my $dnaTC1length    = 0;
    my $dnaPIGcnt       = 0;
    my $dnaPIGlength    = 0;
    my $dnaHcnt         = 0;
    my $dnaHlength      = 0;
    my $dnaPcnt         = 0;
    my $dnaPlength      = 0;
    my $othercnt        = 0;
    my $otherlength     = 0;
    my $rnacnt          = 0;
    my $rnalength       = 0;
    my $satelcnt        = 0;
    my $satellength     = 0;
    my $simplecnt       = 0;
    my $simplelength    = 0;
    my $lowcompcnt      = 0;
    my $lowcomplength   = 0;
    my $annotatedlength = 0;

CYCLE10:
    while ( $cycleAnnotIter->hasNext() ) {
      $i++;
      print STDERR "." if ( $i + 1 ) % 1000 == 0;
      my $currentAnnot = $cycleAnnotIter->next();

      #
      # LINE Renaming
      #
      if ( $currentAnnot->getClassName() =~ /^LINE/ ) {
        my $HitName = $currentAnnot->getHitName();

        # Rename unresolved LINEs
        $HitName =~ s/_orf2$//;

        # TODO: This is a special case of an element which needs
        #       a portion of it's sequence masked out in a seperate stage.
        #       The sequence is a simple repeats which is scored too high
        #       otherwise. I am refering to the endX designation.
        $HitName =~ s/(.*)_[35]endX?$/$1/;
        $HitName =~ s/_strong$//;

        # could use latter as a general tool to indicate a diagnostic fragment
        # rename carnivore LINEs who's name have been adjusted
        # temporarily to allow neighboring fragment recognition
        if ( $HitName =~ /^L1_Ca/ ) {
          $HitName =~ s/^L1_Canis0/L1_Cf/;
          $HitName =~ s/^L1_Canis4/L1_Canid/;
          $HitName =~ s/^L1_Canis5/L1_Canid2/;
        }
        $currentAnnot->setHitName( $HitName );
      }

      #
      # Count tandemly repeated fragments of a repeat as one insert
      # only recognizes constant monomers; croaks on diverged dimers
      #
      if (
           $pastAnnot
        && $pastAnnot->getClassName() !~ /^SINE/

        # SINEs are too common and often miss > 10 bp of tail
        # probably safe with LINEs because of variable 5' ends
        && $currentAnnot->getSeq1Beg() - $pastAnnot->getSeq1End() < 30
        && $currentAnnot->getHitName()  eq $pastAnnot->getHitName()
        && $currentAnnot->getSeq1Name() eq $pastAnnot->getSeq1Name()
        && (    $currentAnnot->getSeq2Beg() > 10
             || $currentAnnot->get3PrimeUnaligned() > 10 )
        && $currentAnnot->getSeq2Beg() - $pastAnnot->getSeq2Beg() < 15
        && $pastAnnot->getSeq2Beg() - $currentAnnot->getSeq2Beg() < 15
        && $currentAnnot->getSeq2End() - $pastAnnot->getSeq2End() < 15
        && $pastAnnot->getSeq2End() - $currentAnnot->getSeq2End() < 15
          )
      {
        $currentAnnot->setLeftLinkedHit( $pastAnnot );
      }

      # Get the next annot
      my $nextAnnot = undef;
      if ( $cycleAnnotIter->hasNext ) {
        $nextAnnot = $cycleAnnotIter->next();
        $cycleAnnotIter->previous();

        # NOTE: If you are going to remove anything in this
        #       cycle you should move back and forward so
        #       the last thing returned is the previous one.
        $cycleAnnotIter->previous();
        $cycleAnnotIter->next();
      }

      #
      # Skip the following processing blocks if we are simple/low
      #
      unless ( $currentAnnot->getClassName() =~
               /Low_complexity|Simple_repeat|Satellite/ )
      {

        #
        # Adjust overlapping sequences when begin or end of one of repeats
        # is probably known
        #    -----------
        #            ---------
        # Does the current fragment have 4-5 bp of unaligned space
        # at the end or begining?  Or...is the current fragment a LINE
        # a Unknown or a Composite?
        if (
             $currentAnnot->getRevComp eq '+'
             && ( $currentAnnot->get3PrimeUnaligned >= 4 )
             || (    $currentAnnot->getRevComp eq "C"
                  && $currentAnnot->getSeq2Beg >= 5 )
             || ( $currentAnnot->getClassName =~ /^L1|^Unknown|Composite/ )
            )
        {

          # Does the current fragment and the next fragment:
          #       - Have the same name?
          #  and  - Overlap by 1 or more bp in the query?
          #  and  - Is the next fragment a LTR or SINE or DNA?
          if (    $nextAnnot
               && $currentAnnot->getSeq1Name eq $nextAnnot->getSeq1Name()
               && $currentAnnot->getSeq1End >= $nextAnnot->getSeq1Beg()
               && $currentAnnot->getSeq1End < $nextAnnot->getSeq1End()
               && ( $nextAnnot->getSeq2Name() =~ /LTR|SINE|DNA/ ) )
          {

            # Does the current fragment run to the end of consensus ( or close )
            # at the end opposite the overlap?  SINES are a special case?
            if (
               (
                 $nextAnnot->getRevComp() eq '+' && $nextAnnot->getSeq2Beg() < 5
               )
               || (    $nextAnnot->getRevComp() eq "C"
                    && $nextAnnot->get3PrimeUnaligned() < 4
                    && $nextAnnot->getSeq2Name() !~ /SINE/ )
                )
            {
              my $overlap =
                  $currentAnnot->getSeq1End - $nextAnnot->getSeq1Beg() + 1;

              # Added the following checks so that we do not end up
              # creating consensus positions that end before they
              # begin. - RMH 2005/12/2
              if (    $currentAnnot->getRevComp eq '+'
                   && $currentAnnot->getSeq2End - $overlap >
                   $currentAnnot->getSeq2Beg )
              {
                $currentAnnot->setSeq2End(
                                       $currentAnnot->getSeq2End() - $overlap );
                $currentAnnot->set3PrimeUnaligned(
                                 $currentAnnot->get3PrimeUnaligned + $overlap );
                $currentAnnot->setSeq1End(
                                         $currentAnnot->getSeq1End - $overlap );
              }
              elsif ( $currentAnnot->getSeq2Beg + $overlap <
                      $currentAnnot->getSeq2End )
              {
                $currentAnnot->setSeq2Beg(
                                       $currentAnnot->getSeq2Beg() + $overlap );
                $currentAnnot->setSeq1End(
                                         $currentAnnot->getSeq1End - $overlap );
              }
            }
          }
        }    # End Adjust overlapping sequences when begin...

        # Same as above but in reverse????
        if (
          $currentAnnot->getRevComp eq '+' && ( $currentAnnot->getSeq2Beg >= 5 )
          || (    $currentAnnot->getRevComp eq "C"
               && $currentAnnot->get3PrimeUnaligned >= 4 )
          || ( $currentAnnot->getClassName =~ /^L1|^Unknown|Composite/ )
            )
        {
          if (    $pastAnnot
               && $currentAnnot->getSeq1Name eq $pastAnnot->getSeq1Name
               && $currentAnnot->getSeq1Beg <= $pastAnnot->getSeq1End
               && $currentAnnot->getSeq1End > $pastAnnot->getSeq1End + 25 )
          {
            if ( $pastAnnot->getClassName() =~ /^LTR|^SINE|^DNA/ ) {
              if (
                   (
                        $pastAnnot->getRevComp eq '+'
                     && $pastAnnot->get3PrimeUnaligned < 4
                     && $pastAnnot->getClassName =~ /^[^S]/
                   )
                   || (    $pastAnnot->getRevComp eq "C"
                        && $pastAnnot->getSeq2Beg < 5 )
                  )
              {
                my $overlap =
                    $pastAnnot->getSeq1End - $currentAnnot->getSeq1Beg + 1;

                # Added the following checks so that we do not end up
                # creating consensus positions that end before they
                # begin. - RMH 2005/12/2
                if (    $currentAnnot->getRevComp eq '+'
                     && $currentAnnot->getSeq2Beg + $overlap <
                     $currentAnnot->getSeq2End )
                {
                  $currentAnnot->setSeq2Beg(
                                       $currentAnnot->getSeq2Beg() + $overlap );
                  $currentAnnot->setSeq1Beg( $pastAnnot->getSeq1End + 1 );
                }
                elsif ( $currentAnnot->getSeq2End - $overlap >
                        $currentAnnot->getSeq2Beg )
                {
                  $currentAnnot->setSeq2End(
                                         $currentAnnot->getSeq2End - $overlap );
                  $currentAnnot->set3PrimeUnaligned(
                               $currentAnnot->get3PrimeUnaligned() + $overlap );
                  $currentAnnot->setSeq1Beg( $pastAnnot->getSeq1End + 1 );
                }
              }
            }
          }
        }

        if ( $currentAnnot->getClassName =~ /^SINE/ ) {
          $currentAnnot->setClassName( "srpRNA" )
              if ( $currentAnnot->getHitName eq "7SLRNA" );
          $currentAnnot->setClassName( "scRNA" )
              if (    $currentAnnot->getHitName eq "BC200"
                   || $currentAnnot->getHitName =~ /^BC1_/ );

          # $ClassName = "scRNA" if $HitName eq "BC200" && $Seq2End > 100;
          if (    $currentAnnot->getHitName eq "ID_B1"
               && $currentAnnot->getSeq2End < 90 )
          {
            $currentAnnot->setClassName( "SINE/ID" );
            $currentAnnot->setHitName( "ID" );
          }
        }

      }    # Unless ( $ClassName =~ /Low_complexity...

      # get rid of negative LINE1 positions; also readjust MLT2 fragments
      if ( $conPosCorrection{ $currentAnnot->getID() } ) {

        # probably don't need to be so restrictive, as only those
        # repeats in the following if ever obtain a $conPosCorrection vallue
        if (    $currentAnnot->getClassName() =~ /^LINE/ && !$options{'orf2'}
             || $currentAnnot->getHitName() =~ /^MLT2\w\d?/
             && $currentAnnot->getHitName() =~ /^MLT2B[34]$/ )
        {    # the adjusted pos are right for B3 & 4

          #$currentAnnot->sanityCheckConsPos( \%conPosCorrection );
          $currentAnnot->setSeq2Beg( $currentAnnot->getSeq2Beg() +
                                  $conPosCorrection{ $currentAnnot->getID() } );
          ## TODO: Consider why this needs to be protected from
          ##       producing negative/0 numbers.  Considered: If the
          ##       renaming of a fragment changes the length of the consensus
          ##       ( making it shorter ) the adjustment will be off.
          ##       Now consider how to fix this.
          $currentAnnot->setSeq2Beg( 1 )
              if ( $currentAnnot->getSeq2Beg() < 1 );
          $currentAnnot->setSeq2End( $currentAnnot->getSeq2End() +
                                  $conPosCorrection{ $currentAnnot->getID() } );
        }
      }
      elsif (    $currentAnnot->getHitName() =~ /MER33|Charlie5/
              && $currentAnnot->getSeq2Beg < 1 )
      {
        $currentAnnot->setSeq2Beg( 1 );
      }

      my $length = $currentAnnot->getSeq1End - $currentAnnot->getSeq1Beg + 1;
      ## following happens sometimes with overlapping simple repeats:
      if (    $nextAnnot
           && $currentAnnot->getSeq1Name eq $nextAnnot->getSeq1Name()
           && $currentAnnot->getSeq1End > $nextAnnot->getSeq1End() )
      {
        $length -= $nextAnnot->getSeq1End() - $nextAnnot->getSeq1Beg() + 1;
      }

      if ( $currentAnnot->getClassName =~ /Simple_repeat|Satellite/ ) {
        $currentAnnot->setClassName( "Low_complexity" )
            if ( $currentAnnot->getHitName =~ /rich|purine|pyrimidin/ );

        if ( $currentAnnot->getHitName =~ /\(CATTC\)n|\(GAATG\)n/ ) {
          my $hitname = quotemeta $currentAnnot->getHitName;
          if (
              $currentAnnot->getSeq2End > 200
              || (    $pastAnnot
                   && $pastAnnot->getHitName =~ /$hitname|HSATII/
                   && $currentAnnot->getSeq1Beg - $pastAnnot->getSeq1End < 100
                   && $currentAnnot->getSeq2End + $pastAnnot->getSeq2End > 200 )
              || (
                   $nextAnnot
                && $nextAnnot->getSeq2Name() =~ /$hitname|HSATII/
                && $nextAnnot->getSeq1Beg() - $currentAnnot->getSeq1End < 100
                && (
                  ( $currentAnnot->getSeq2End + $nextAnnot->getSeq2End() > 200 )
                  || (    $pastAnnot
                       && $pastAnnot->getHitName eq $currentAnnot->getHitName
                       && $currentAnnot->getSeq2End + $pastAnnot->getSeq2End +
                       $nextAnnot->getSeq2End() > 200 )
                )
              )
              )
          {
            $currentAnnot->setClassName( "Satellite" );
          }
        }
        $currentAnnot->setHitName( $currentAnnot->getHitName() . '/Alpha' )
            if ( $currentAnnot->getHitName eq 'ALR' );
        $currentAnnot->setHitName( $currentAnnot->getHitName() . '/Beta' )
            if ( $currentAnnot->getHitName eq 'BSR' );
        if (    $pastAnnot
             && $currentAnnot->getSeq1Name eq $pastAnnot->getSeq1Name )
        {
          if (    $pastAnnot->getHitName eq $currentAnnot->getHitName
               && $pastAnnot->getRevComp eq $currentAnnot->getRevComp
               && $currentAnnot->getSeq1Beg - $pastAnnot->getSeq1End < 65 )
          {
            $currentAnnot->join( $pastAnnot );
          }
          if (    $currentAnnot->getSeq1Beg <= $pastAnnot->getSeq1End
               && $currentAnnot->getSeq1End > $pastAnnot->getSeq1End )
          {
            $length -=
                ( $pastAnnot->getSeq1End - $currentAnnot->getSeq1Beg + 1 );
          }
        }
        if ( $currentAnnot->getClassName =~ /Satellite/ ) {
          my $tmpClassName = $currentAnnot->getClassName();
          $tmpClassName =~ s/[Cc]entromeric$/centr/;
          $tmpClassName =~ s/telomeric$/telo/;
          $tmpClassName =~ s/acromeric$/acro/;
          $currentAnnot->setClassName( $tmpClassName );
        }
      }    # if Simple/Sattellite

      #
      # Stats
      #
      my $CN = $currentAnnot->getClassName;
      $CN =~ s/\?$//;   # I'm counting them with the class, even if I'm not sure
      if ( !defined $uniqCount{$CN} ) {
        $uniqCount{$CN} = 0;
        $totlength{$CN} = 0 if !defined $totlength{$CN};
      }

      my $checked = 0;
      if ( $currentAnnot->getLeftLinkedHit() ) {
        $checked = 1;
      }
      $uniqCount{$CN}++ unless $checked;
      $totlength{$CN}  += $length;
      $annotatedlength += $length;

      if ( $CN =~ /SINE/ ) {
        $sinecnt++ unless $checked;
        $sinelength += $length;
      }
      elsif ( $CN =~ /^LINE/ ) {
        $linecnt++ unless $checked;
        $linelength += $length;
        if ( $CN =~ /\/CR1$|\/L2$|\/Rex-Babar$/ ) {
          $lineCR1cnt++ unless $checked;
          $lineCR1length += $length;
        }
        elsif ( $CN =~ /\/R1$|\/LOA$|\/I$|\/Jockey$/ ) {
          $lineIcnt++ unless $checked;
          $lineIlength += $length;
        }
        elsif ( $CN =~ /\/RTE|\/Bov-B/ ) {
          $lineRTEcnt++ unless $checked;
          $lineRTElength += $length;
        }
        elsif ( $CN =~ /\/NeSL|\/R[24]|\/Dong/ ) {
          $lineR2cnt++ unless $checked;
          $lineR2length += $length;
        }
      }
      elsif ( $CN =~ /^LTR/ ) {
        $ltrcnt++ unless $checked;
        $ltrlength += $length;
        if ( $CN =~ /ERV|MaLR/ ) {
          $ltrERVcnt++ unless $checked;
          $ltrERVlength += $length;
        }
        elsif ( $CN =~ /PAO$|BEL$/i ) {
          $ltrBELcnt++ unless $checked;
          $ltrBELlength += $length;
        }
        elsif ( $CN =~ /DIRS$|Gypsy$/ ) {
          $ltrGYPcnt++ unless $checked;
          $ltrGYPlength += $length;
        }
      }
      elsif ( $CN =~ /^DNA/ ) {
        $dnacnt++ unless $checked;
        $dnalength += $length;
        if ( $CN =~ /\/Mariner|\/Tc[124]$|\/MER2|\/Tigger|\/Pogo|\/Stowaway/ ) {
          $dnaTC1cnt++ unless $checked;
          $dnaTC1length += $length;
        }
        elsif (
              $CN =~ /\/[hH]AT|\/AcHobo|Tam3$|Tol2$|\/Tip100|\/MER1|\/Charlie/ )
        {
          $dnaHATcnt++ unless $checked;
          $dnaHATlength += $length;
        }
        elsif ( $CN =~ /\/T2$|\/PiggyBac/ ) {
          $dnaPIGcnt++ unless $checked;
          $dnaPIGlength += $length;
        }
        elsif ( $CN =~ /Harbing|Tourist/ ) {
          $dnaHcnt++ unless $checked;
          $dnaHlength += $length;
        }
        elsif ( $CN =~ /\/P$|\/Mirage|\/Transib/ ) {
          $dnaPcnt++ unless $checked;
          $dnaPlength += $length;
        }
      }
      elsif ( $CN =~ /^Unknown|^Composite|^Other/ ) {
        $othercnt++ unless $checked;
        $otherlength += $length;
      }
      elsif ( $CN =~ /RNA$/ ) {
        $rnacnt++ unless $checked;
        $rnalength += $length;
      }
      elsif ( $CN =~ /Satel/ ) {
        $satelcnt++ unless $checked;
        $satellength += $length;
      }
      elsif ( $CN =~ /Simple/ ) {
        $simplecnt++ unless $checked;
        $simplelength += $length;
      }
      elsif ( $CN =~ /^Low/ ) {
        $lowcompcnt++ unless $checked;
        $lowcomplength += $length;
      }
      $checked{ $currentAnnot->getID() }++;

      ### TODO: Move this above the stats generation
      # do not print (near) duplicates created by fusing overlapping matches
      if (
        (
             $pastAnnot
          && $currentAnnot->getSeq1Name eq $pastAnnot->getSeq1Name()
          && $currentAnnot->getSeq1End <= $pastAnnot->getSeq1End()
          && $currentAnnot->getSW <= $pastAnnot->getSW()
          && $currentAnnot->getClassName eq $pastAnnot->getClassName()
          && $currentAnnot->getLastField eq $pastAnnot->getLastField()
        )
        || (    $currentAnnot->getClassName !~ /Simple/
             && $currentAnnot->getSeq1End() - $currentAnnot->getSeq1Beg() < 10
             || $currentAnnot->getSeq1End() - $currentAnnot->getSeq1Beg() < 5 )
        ||

        # nor low complexity DNA or simple repeats when people don't
        # want to see it
        (
             $options{'nolow'}
          && $currentAnnot->getClassName =~ /Low_complexity|Simple_repeat/
        )
          )
      {
        $currentAnnot->removeFromJoins();
        $cycleAnnotIter->remove();
        $pastAnnot->addDerivedFromAnnot( $currentAnnot )
            if ( $options{'source'} );
        next CYCLE10;
      }

      $pastAnnot = $currentAnnot;
    }

    #printHitArrayList( $sortedAnnotationsList );

    #
    # Now go through the dataset and renumber the ids
    #
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();
    my %id = ();
    while ( $cycleAnnotIter->hasNext() ) {
      my $currentAnnot = $cycleAnnotIter->next();

      #
      # Build the id{} datastructure for renumbering the annotations
      #
      print STDERR "About to renumber\n" if ( $DEBUG );
      my $tmpID = $currentAnnot->getID();
      $currentAnnot->print() if ( $DEBUG );
      if ( $currentAnnot->getLeftLinkedHit() ) {
        if ( $DEBUG ) {
          print STDERR "Left link is:\n";
          $currentAnnot->getLeftLinkedHit()->print();
          print STDERR "Setting to left's id{ "
              . $currentAnnot->getLeftLinkedHit()->getID() . " } = "
              . $id{ $currentAnnot->getLeftLinkedHit()->getID() } . "\n";
        }
        $id{$tmpID} = $id{ $currentAnnot->getLeftLinkedHit()->getID() };
      }
      else {
        print STDERR "Setting to new number $lastid + 1\n" if ( $DEBUG );
        $id{$tmpID} = ++$lastid;
      }
    }    # End while

    #printHitArrayList( $sortedAnnotationsList );

    # Get column widths
    my %colWidths = &getMaxColWidths( $sortedAnnotationsList );

    #
    # Print the out file.
    #
    $cycleAnnotIter = $sortedAnnotationsList->getIterator();
    my $headerWritten = 0;
    my $pastAnnot     = undef;
    while ( $cycleAnnotIter->hasNext() ) {
      my $currentAnnot = $cycleAnnotIter->next();

      # Get the next annot
      my $nextAnnot = undef;
      if ( $cycleAnnotIter->hasNext ) {
        $nextAnnot = $cycleAnnotIter->next();
        $cycleAnnotIter->previous();

        # NOTE: If you are going to remove anything in this
        #       cycle you should move back and forward so
        #       the last thing returned is the previous one.
      }

      #
      # Indicate overlapping sequences in table
      #
      my $Overlapped = "";
      if (
           (
                $pastAnnot
             && $currentAnnot->getSeq1Name eq $pastAnnot->getSeq1Name
             && $currentAnnot->getSeq1Beg <= $pastAnnot->getSeq1End
             && $currentAnnot->getSW < $pastAnnot->getSW
             && $currentAnnot->getLastField eq $pastAnnot->getLastField
           )
           || (    $nextAnnot
                && $currentAnnot->getSeq1Name eq $nextAnnot->getSeq1Name()
                && $currentAnnot->getSeq1End >= $nextAnnot->getSeq1Beg()
                && $currentAnnot->getSW < $nextAnnot->getSW()
                && $currentAnnot->getLastField eq $nextAnnot->getLastField() )
          )
      {
        $Overlapped = "*";
      }

      # format fields
      my $LeftOver = $seq1Lengths{ $currentAnnot->getSeq1Name } -
          $currentAnnot->getSeq1End;
      my $LeftOverPrint = "(" . $LeftOver . ")";

      my $Seq2BeginPrint     = "(" . $currentAnnot->get3PrimeUnaligned . ")";
      my $LeftUnalignedPrint = $currentAnnot->getSeq2Beg();
      if ( $currentAnnot->getRevComp eq '+' ) {
        $Seq2BeginPrint     = $currentAnnot->getSeq2Beg();
        $LeftUnalignedPrint = "(" . $currentAnnot->get3PrimeUnaligned . ")";
      }

      my $printid = $id{ $currentAnnot->getID() };
      if ( $options{'no_id'} ) {
        $printid = "";
      }

      my $PctSubst  = sprintf "%4.1f", $currentAnnot->getPctSubst;
      my $PctDelete = sprintf "%4.1f", $currentAnnot->getPctDelete;
      my $PctInsert = sprintf "%4.1f", $currentAnnot->getPctInsert;

      if ( $options{'xm'} ) {
        print OUTXM ""
            . $currentAnnot->getSW() . " "
            . $PctSubst . " "
            . $PctDelete . " "
            . $PctInsert . " "
            . $currentAnnot->getSeq1Name() . " "
            . $currentAnnot->getSeq1Beg() . " "
            . $currentAnnot->getSeq1End() . " "
            . $LeftOverPrint . " "
            . $currentAnnot->getRevComp() . " "
            . $currentAnnot->getHitName() . "\#"
            . $currentAnnot->getClassName() . " "
            . $Seq2BeginPrint . " "
            . $currentAnnot->getSeq2End() . " "
            . $LeftUnalignedPrint . " "
            . $Overlapped . "\n";
      }

      if ( $options{'ace'} ) {
        if ( $currentAnnot->getRevComp eq "C" ) {
          print OUTACE "Motif_homol \""
              . $currentAnnot->getHitName()
              . "\" \"RepeatMasker\" "
              . $PctSubst . " "
              . $currentAnnot->getSeq1Beg() . " "
              . $currentAnnot->getSeq1End() . " - "
              . $currentAnnot->getSeq2End() . " "
              . $currentAnnot->getSeq2Beg() . "\n";
        }
        else {
          print OUTACE "Motif_homol \""
              . $currentAnnot->getHitName()
              . "\" \"RepeatMasker\" "
              . $PctSubst . " "
              . $currentAnnot->getSeq1Beg() . " "
              . $currentAnnot->getSeq1End() . " + "
              . $currentAnnot->getSeq2End() . " "
              . $currentAnnot->getSeq2Beg() . "\n";
        }
      }

      if (    $options{'poly'}
           && $currentAnnot->getClassName eq "Simple_repeat"
           && $PctSubst + $PctDelete + $PctInsert < 10 )
      {
        printf OUTPOLY "%${colWidths{'SW'}}d  %${colWidths{'PctSubst'}}s "
            . "%${colWidths{'PctDelete'}}s "
            . "%${colWidths{'PctInsert'}}s  "
            . "%-${colWidths{'Seq1Name'}}s  "
            . "%${colWidths{'BeginAlign'}}s "
            . "%${colWidths{'EndAlign'}}s "
            . "%${colWidths{'LeftOver'}}s %1s "
            . "%-${colWidths{'HitName'}}s "
            . "%-${colWidths{'class'}}s "
            . "%${colWidths{'Seq2Begin'}}s "
            . "%${colWidths{'Seq2End'}}s "
            . "%${colWidths{'LeftUnaligned'}}s %1s\n", $currentAnnot->getSW(),
            $PctSubst, $PctDelete, $PctInsert, $currentAnnot->getSeq1Name(),
            $currentAnnot->getSeq1Beg(), $currentAnnot->getSeq1End(),
            $LeftOverPrint, $currentAnnot->getRevComp(),
            $currentAnnot->getHitName(), $currentAnnot->getClassName(),
            $Seq2BeginPrint, $currentAnnot->getSeq2End(), $LeftUnalignedPrint,
            $Overlapped;
      }    # if $options{'poly'}

      if ( $options{'gff'} ) {
        my $source;
        if ( $currentAnnot->getHitName =~ /Alu/ ) {
          $source = 'RepeatMasker_SINE';
        }
        else {
          $source = 'RepeatMasker';
        }
        print OUTGFF ""
            . $currentAnnot->getSeq1Name() . "\t"
            . $source
            . "\tsimilarity\t"
            . $currentAnnot->getSeq1Beg() . "\t"
            . $currentAnnot->getSeq1End() . "\t"
            . $PctSubst . "\t";
        if ( $currentAnnot->getRevComp() eq "C" ) {
          print OUTGFF "-";
        }
        else {
          print OUTGFF "+";
        }
        print OUTGFF "Target \"Motif:"
            . $currentAnnot->getHitName() . "\" "
            . $currentAnnot->getSeq2Beg() . " "
            . $currentAnnot->getSeq2End() . "\n";
      }

      if ( !$headerWritten ) {
        my $widthposquery = $colWidths{'BeginAlign'} + $colWidths{'EndAlign'} +
            $colWidths{'LeftOver'} + 2;
        my $widthposrepeat = $colWidths{'Seq2Begin'} + $colWidths{'Seq2End'} +
            $colWidths{'LeftUnaligned'} + 2;

        # First line of header
        printf OUTFULL "%${colWidths{'SW'}}s  %${colWidths{'PctSubst'}}s "
            . "%${colWidths{'PctDelete'}}s "
            . "%${colWidths{'PctInsert'}}s  "
            . "%-${colWidths{'Seq1Name'}}s  "
            . "%-${widthposquery}s   "
            . "%-${colWidths{'HitName'}}s %-${colWidths{'class'}}s "
            . "%${widthposrepeat}s\n", 'SW', 'perc', 'perc', 'perc', 'query',
            'position in query', 'matching', 'repeat', 'position in repeat';

        # Second line of header
        printf OUTFULL "%${colWidths{'SW'}}s  %${colWidths{'PctSubst'}}s "
            . "%${colWidths{'PctDelete'}}s "
            . "%${colWidths{'PctInsert'}}s  "
            . "%-${colWidths{'Seq1Name'}}s  "
            . "%-${colWidths{'BeginAlign'}}s "
            . "%-${colWidths{'EndAlign'}}s "
            . "%${colWidths{'LeftOver'}}s   "
            . "%-${colWidths{'HitName'}}s "
            . "%-${colWidths{'class'}}s "
            . "%-${colWidths{'Seq2Begin'}}s "
            . "%-${colWidths{'Seq2End'}}s "
            . "%-${colWidths{'LeftUnaligned'}}s ", 'score', 'div.', 'del.',
            'ins.', 'sequence', 'begin', 'end', '(left)', 'repeat',
            'class/family', 'begin', 'end', '(left)', 'ID';

        unless ( $options{'no_id'} ) {
          printf OUTFULL "%${colWidths{'ID'}}s", 'ID';
        }

        printf OUTFULL "\n\n";

        $headerWritten = 1;
      }

      if ( $options{'lcambig'} ) {

        # Use repeat name case to highlight ambiguous DNA
        # transposon fragments
        $currentAnnot->setHitName( uc( $currentAnnot->getHitName() ) );
        $currentAnnot->setHitName( lc( $currentAnnot->getHitName() ) )
            if (    $currentAnnot->getEquivHash()
                 && $currentAnnot->getClassName() =~ /DNA/ );
      }

      printf OUTFULL "%${colWidths{'SW'}}d  %${colWidths{'PctSubst'}}s "
          . "%${colWidths{'PctDelete'}}s "
          . "%${colWidths{'PctInsert'}}s  "
          . "%-${colWidths{'Seq1Name'}}s  "
          . "%${colWidths{'BeginAlign'}}s "
          . "%${colWidths{'EndAlign'}}s "
          . "%${colWidths{'LeftOver'}}s %1s "
          . "%-${colWidths{'HitName'}}s "
          . "%-${colWidths{'class'}}s "
          . "%${colWidths{'Seq2Begin'}}s "
          . "%${colWidths{'Seq2End'}}s "
          . "%${colWidths{'LeftUnaligned'}}s ", $currentAnnot->getSW(),
          $PctSubst, $PctDelete, $PctInsert, $currentAnnot->getSeq1Name(),
          $currentAnnot->getSeq1Beg(), $currentAnnot->getSeq1End(),
          $LeftOverPrint, $currentAnnot->getRevComp(),
          $currentAnnot->getHitName(), $currentAnnot->getClassName(),
          $Seq2BeginPrint, $currentAnnot->getSeq2End(), $LeftUnalignedPrint;

      unless ( $options{'no_id'} ) {
        printf OUTFULL "%${colWidths{'ID'}}s %1s\n", $printid, $Overlapped;
      }
      else {
        printf OUTFULL "%1s\n", $Overlapped;
      }

      if ( $options{'source'} ) {

        #print STDERR "Doing source output\n";
        printSourceAnnots( $currentAnnot, \%colWidths, 1 );
      }

      $pastAnnot = $currentAnnot;
    }    # while loop

    ### RMH: NEW STATS CODE -- RESURRECT?
    #&calcAnnotationStats( $sortedAnnotationsList, \%options );
    ### RMH: End

    close OUTFULL;

    #
    # Now mask so we can get stats on the seq for the table output
    #
    # GLOBAL for use in format statements
    my $usePerc = 1;
    if ( -f $options{'maskSource'} ) {
      print STDERR "\nmasking";
      my $db = FastaDB->new(
                             fileName    => $options{'maskSource'},
                             openMode    => SeqDBI::ReadOnly,
                             maxIDLength => 50
      );
      my $maskFormat = '';
      $maskFormat = 'x'      if ( $options{'x'} );
      $maskFormat = 'xsmall' if ( $options{'xsmall'} );
      ( $seq_cnt, $totseqlen, $nonNSeqLen, $frac_GC, $maskedlength ) =
          &maskSequence( $maskFormat, $db, "$file.out",
                         $options{'maskSource'} . ".masked" );
      $totalSeqLen = $totseqlen;
      if ( $options{'excln'} ) {
        $totseqlen = $nonNSeqLen;
        $exclnote  = "Runs of >=20 X/Ns in query were excluded in % calcs\n";
      }
      $nonNSeqLen    = "($nonNSeqLen bp excl N/X-runs)";
      $maskedpercent = ( $maskedlength / $totseqlen ) * 100;
    }
    elsif ( $numSearchedSeqs ) {
      $seq_cnt   = $numSearchedSeqs;
      $totseqlen = $lenSearchedSeqs;
      if ( $options{'excln'} ) {
        $totseqlen = $lenSearchedSeqsExcludingXNRuns;
        $exclnote  = "Runs of >=20 X/Ns in query were excluded in % calcs\n";
      }
      $totalSeqLen   = $totseqlen;
      $nonNSeqLen    = "($lenSearchedSeqsExcludingXNRuns bp excl N/X-runs)";
      $maskedlength  = $annotatedlength;
      $maskedpercent = ( $maskedlength / $totseqlen ) * 100;
      $frac_GC       = "Unknown";
    }
    else {
      warn "\nWarning: Calculation of statistics hampered by missing\n"
          . "sequence sizes in the input file *and* missing -maskSource\n"
          . "parameter!  Cannot calculate percentage masked values.\n";
      $usePerc       = 0;
      $totseqlen     = 1;
      $nonNSeqLen    = "";
      $maskedpercent = 0;
      $maskedlength  = $annotatedlength;
    }

    my $totallength =
        $sinelength + $linelength + $ltrlength + $dnalength + $otherlength;

    #$options{'species'}  =~
    #    s/^__(\S+)$/$1/;    # for the orders (rodent, artiodactyl, carnivore)
    #$options{'species'}  = uc($options{'species'});    # capitalizes
    #$options{'species'}  =~ s/(\S+)__\w+$/$1/;  # deletes the __order suffix
    # got to be a simpler way than those three lines to capitalize a word.

    # future aim is to use same format for at least all mammals
    if ( $options{'primate'} ) {
      my $OUT;
      open( $OUT, ">$file.tbl" )
          || die "can't create $file.tbl\n";
      printf $OUT "==================================================\n";
      printf $OUT "file name: %-25s\n",             $filename;
      printf $OUT "sequences:       %7d\n",         $seq_cnt;
      printf $OUT "total length: %10d bp  %-25s\n", $totalSeqLen, $nonNSeqLen;
      printf $OUT "GC level:        %6s \%\n",      $frac_GC;
      printf $OUT "bases masked: %10d bp ( %4.2f \%)\n", $maskedlength,
          $maskedpercent;
      printf $OUT "==================================================\n";
      printf $OUT "               number of      length   percentage\n";
      printf $OUT "               elements*    occupied  of sequence\n";
      printf $OUT "--------------------------------------------------\n";
      printf $OUT "SINEs:           %6d   %10d bp   %5.2f \%\n", $sinecnt,
          $sinelength, $sinelength * 100 * $usePerc / $totseqlen;
      printf $OUT "      ALUs       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/Alu"}, $totlength{"SINE/Alu"},
          $totlength{"SINE/Alu"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      MIRs       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/MIR"}, $totlength{"SINE/MIR"},
          $totlength{"SINE/MIR"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "LINEs:           %6d   %10d bp   %5.2f \%\n", $linecnt,
          $linelength, $linelength * 100 * $usePerc / $totseqlen;
      printf $OUT "      LINE1      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/L1"}, $totlength{"LINE/L1"},
          $totlength{"LINE/L1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      LINE2      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/L2"}, $totlength{"LINE/L2"},
          $totlength{"LINE/L2"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      L3/CR1     %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/CR1"}, $totlength{"LINE/CR1"},
          $totlength{"LINE/CR1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "LTR elements:    %6d   %10d bp   %5.2f \%\n", $ltrcnt,
          $ltrlength, $ltrlength * 100 * $usePerc / $totseqlen;
      printf $OUT "      MaLRs      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/MaLR"}, $totlength{"LTR/MaLR"},
          $totlength{"LTR/MaLR"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERVL       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERVL"}, $totlength{"LTR/ERVL"},
          $totlength{"LTR/ERVL"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERV_classI %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERV1"}, $totlength{"LTR/ERV1"},
          $totlength{"LTR/ERV1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERV_classII%6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERVK"}, $totlength{"LTR/ERVK"},
          $totlength{"LTR/ERVK"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "DNA elements:    %6d   %10d bp   %5.2f \%\n", $dnacnt,
          $dnalength, $dnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "      MER1_type  %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/MER1_type"}, $totlength{"DNA/MER1_type"},
          $totlength{"DNA/MER1_type"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      MER2_type  %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/MER2_type"}, $totlength{"DNA/MER2_type"},
          $totlength{"DNA/MER2_type"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Unclassified:    %6d   %10d bp   %5.2f \%\n", $othercnt,
          $otherlength, $otherlength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Total interspersed repeats:%9d bp   %5.2f \%\n",
          $totallength, $totallength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n\n";
      printf $OUT "Small RNA:       %6d   %10d bp   %5.2f \%\n", $rnacnt,
          $rnalength, $rnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Satellites:      %6d   %10d bp   %5.2f \%\n", $satelcnt,
          $satellength, $satellength * 100 * $usePerc / $totseqlen;
      printf $OUT "Simple repeats:  %6d   %10d bp   %5.2f \%\n", $simplecnt,
          $simplelength, $simplelength * 100 * $usePerc / $totseqlen;
      printf $OUT "Low complexity:  %6d   %10d bp   %5.2f \%\n", $lowcompcnt,
          $lowcomplength, $lowcomplength * 100 * $usePerc / $totseqlen;
      printf $OUT "==================================================\n";
      printf $OUT "\n";
      printf $OUT "* most repeats fragmented by insertions or deletions\n";
      printf $OUT "  have been counted as one element\n";
      printf $OUT "%54s\n", $exclnote;
      printf $OUT "\n";
      printf $OUT "The query species was assumed to be %-14s\n",
          $options{'species'};
      printf $OUT "%-82s\n", substr( $versionmode, 0, 82 );
      printf $OUT "$engine\n";
      printf $OUT "$dbversion\n";
      close $OUT;
    }
    elsif ( $options{'mus'} ) {
      my $OUT;
      open( $OUT, ">$file.tbl" )
          || die "can't create $file.tbl\n";
      printf $OUT "==================================================\n";
      printf $OUT "file name: %-25s\n",             $filename;
      printf $OUT "sequences:       %7d\n",         $seq_cnt;
      printf $OUT "total length: %10d bp  %-25s\n", $totalSeqLen, $nonNSeqLen;
      printf $OUT "GC level:        %6s \%\n",      $frac_GC;
      printf $OUT "bases masked: %10d bp ( %4.2f \%)\n", $maskedlength,
          $maskedpercent;
      printf $OUT "==================================================\n";
      printf $OUT "               number of      length   percentage\n";
      printf $OUT "               elements*    occupied  of sequence\n";
      printf $OUT "--------------------------------------------------\n";
      printf $OUT "SINEs:            %6d   %10d bp   %5.2f \%\n", $sinecnt,
          $sinelength, $sinelength * 100 * $usePerc / $totseqlen;
      printf $OUT "      Alu/B1      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/Alu"}, $totlength{"SINE/Alu"},
          $totlength{"SINE/Alu"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      B2-B4       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/B2"} + $uniqCount{"SINE/B4"},
          $totlength{"SINE/B2"} + $totlength{"SINE/B4"},
          ( $totlength{"SINE/B2"} + $totlength{"SINE/B4"} ) * 100 * $usePerc /
          $totseqlen;
      printf $OUT "      IDs         %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/ID"}, $totlength{"SINE/ID"},
          $totlength{"SINE/ID"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      MIRs        %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/MIR"}, $totlength{"SINE/MIR"},
          $totlength{"SINE/MIR"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "LINEs:            %6d   %10d bp   %5.2f \%\n", $linecnt,
          $linelength, $linelength * 100 * $usePerc / $totseqlen;
      printf $OUT "      LINE1       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/L1"}, $totlength{"LINE/L1"},
          $totlength{"LINE/L1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      LINE2       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/L2"}, $totlength{"LINE/L2"},
          $totlength{"LINE/L2"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      L3/CR1      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/CR1"}, $totlength{"LINE/CR1"},
          $totlength{"LINE/CR1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "LTR elements:     %6d   %10d bp   %5.2f \%\n", $ltrcnt,
          $ltrlength, $ltrlength * 100 * $usePerc / $totseqlen;
      printf $OUT "      MaLRs       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/MaLR"}, $totlength{"LTR/MaLR"},
          $totlength{"LTR/MaLR"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERVL        %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERVL"}, $totlength{"LTR/ERVL"},
          $totlength{"LTR/ERVL"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERV_classI  %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERV1"}, $totlength{"LTR/ERV1"},
          $totlength{"LTR/ERV1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERV_classII %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERVK"}, $totlength{"LTR/ERVK"},
          $totlength{"LTR/ERVK"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "DNA elements:     %6d    %10dbp   %5.2f \%\n", $dnacnt,
          $dnalength, $dnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "      MER1_type   %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/MER1_type"}, $totlength{"DNA/MER1_type"},
          $totlength{"DNA/MER1_type"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      MER2_type   %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/MER2_type"}, $totlength{"DNA/MER2_type"},
          $totlength{"DNA/MER2_type"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Unclassified:     %6d   %10d bp   %5.2f \%\n", $othercnt,
          $otherlength, $otherlength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Total interspersed repeats:%10d bp   %5.2f \%\n",
          $totallength, $totallength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n\n";
      printf $OUT "Small RNA:        %6d   %10d bp   %5.2f \%\n", $rnacnt,
          $rnalength, $rnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Satellites:       %6d   %10d bp   %5.2f \%\n", $satelcnt,
          $satellength, $satellength * 100 * $usePerc / $totseqlen;
      printf $OUT "Simple repeats:   %6d   %10d bp   %5.2f \%\n", $simplecnt,
          $simplelength, $simplelength * 100 * $usePerc / $totseqlen;
      printf $OUT "Low complexity:   %6d   %10d bp   %5.2f \%\n", $lowcompcnt,
          $lowcomplength, $lowcomplength * 100 * $usePerc / $totseqlen;
      printf $OUT "==================================================\n";
      printf $OUT "\n";
      printf $OUT "* most repeats fragmented by insertions or deletions\n";
      printf $OUT "  have been counted as one element\n";
      printf $OUT "%54s\n", $exclnote;
      printf $OUT "\n";
      printf $OUT "The query species was assumed to be %-14s\n",
          $options{'species'};
      printf $OUT "%-82s\n", substr( $versionmode, 0, 82 );
      printf $OUT "$engine\n";
      printf $OUT "$dbversion\n";
      close $OUT;
    }
    elsif ( $options{'mammal'} ) {
      my $OUT;
      open( $OUT, ">$file.tbl" )
          || die "can't create $file.tbl\n";
      printf $OUT "==================================================\n";
      printf $OUT "file name: %-25s\n",             $filename;
      printf $OUT "sequences:       %7d\n",         $seq_cnt;
      printf $OUT "total length: %10d bp  %-25s\n", $totalSeqLen, $nonNSeqLen;
      printf $OUT "GC level:        %6s \%\n",      $frac_GC;
      printf $OUT "bases masked: %10d bp ( %4.2f \%)\n", $maskedlength,
          $maskedpercent;
      printf $OUT "==================================================\n";
      printf $OUT "               number of      length   percentage\n";
      printf $OUT "               elements*    occupied  of sequence\n";
      printf $OUT "--------------------------------------------------\n";
      printf $OUT "SINEs:            %6d   %10d bp   %5.2f \%\n", $sinecnt,
          $sinelength, $sinelength * 100 * $usePerc / $totseqlen;
      printf $OUT "      Alu/B1      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/Alu"}, $totlength{"SINE/Alu"},
          $totlength{"SINE/Alu"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      MIRs        %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"SINE/MIR"}, $totlength{"SINE/MIR"},
          $totlength{"SINE/MIR"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "LINEs:            %6d   %10d bp   %5.2f \%\n", $linecnt,
          $linelength, $linelength * 100 * $usePerc / $totseqlen;
      printf $OUT "      LINE1       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/L1"}, $totlength{"LINE/L1"},
          $totlength{"LINE/L1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      LINE2       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/L2"}, $totlength{"LINE/L2"},
          $totlength{"LINE/L2"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      L3/CR1      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/CR1"}, $totlength{"LINE/CR1"},
          $totlength{"LINE/CR1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      RTE         %6d   %10d bp   %5.2f \%\n", $lineRTEcnt,
          $lineRTElength, $lineRTElength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "LTR elements:     %6d   %10d bp   %5.2f \%\n", $ltrcnt,
          $ltrlength, $ltrlength * 100 * $usePerc / $totseqlen;
      printf $OUT "      MaLRs       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/MaLR"}, $totlength{"LTR/MaLR"},
          $totlength{"LTR/MaLR"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERVL        %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERVL"}, $totlength{"LTR/ERVL"},
          $totlength{"LTR/ERVL"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERV_classI  %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERV1"}, $totlength{"LTR/ERV1"},
          $totlength{"LTR/ERV1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      ERV_classII %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/ERVK"}, $totlength{"LTR/ERVK"},
          $totlength{"LTR/ERVK"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "DNA elements:     %6d   %10d bp   %5.2f \%\n", $dnacnt,
          $dnalength, $dnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "      MER1_type   %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/MER1_type"}, $totlength{"DNA/MER1_type"},
          $totlength{"DNA/MER1_type"} * 100 * $usePerc / $totseqlen;
      printf $OUT "      MER2_type   %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/MER2_type"}, $totlength{"DNA/MER2_type"},
          $totlength{"DNA/MER2_type"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Unclassified:     %6d   %10d bp   %5.2f \%\n", $othercnt,
          $otherlength, $otherlength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Total interspersed repeats:%10d bp   %5.2f \%\n",
          $totallength, $totallength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n\n";
      printf $OUT "Small RNA:        %6d   %10d bp   %5.2f \%\n", $rnacnt,
          $rnalength, $rnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Satellites:       %6d   %10d bp   %5.2f \%\n", $satelcnt,
          $satellength, $satellength * 100 * $usePerc / $totseqlen;
      printf $OUT "Simple repeats:   %6d   %10d bp   %5.2f \%\n", $simplecnt,
          $simplelength, $simplelength * 100 * $usePerc / $totseqlen;
      printf $OUT "Low complexity:   %6d   %10d bp   %5.2f \%\n", $lowcompcnt,
          $lowcomplength, $lowcomplength * 100 * $usePerc / $totseqlen;
      printf $OUT "==================================================\n";
      printf $OUT "\n";
      printf $OUT "* most repeats fragmented by insertions or deletions\n";
      printf $OUT "  have been counted as one element\n";
      printf $OUT "%54s\n", $exclnote;
      printf $OUT "\n";
      printf $OUT "The query species was assumed to be %-14s\n",
          $options{'species'};
      printf $OUT "%-82s\n", substr( $versionmode, 0, 82 );
      printf $OUT "$engine\n";
      printf $OUT "$dbversion\n";
      close $OUT;
    }
    else {
      my $queryorigin;
      if ( $options{'species'} ) {
        $queryorigin =
            "The query species was assumed to be \""
            . $options{'species'} . "\"";
      }
      elsif ( $options{'lib'} ) {
        $options{'lib'} =~ s/.*(\/.*?$)/\.\.\.$1/;    # full path too long
             # obnoxiously, emacs' indentation can't handle that line;
             # nothing wrong
        $queryorigin =
            "The query was compared to sequences in \""
            . $options{'lib'} . "\"";
      }
      my $OUT;
      open( $OUT, ">$file.tbl" ) || die "can't create $file.tbl\n";

      printf $OUT "==================================================\n";
      printf $OUT "file name: %-25s\n",             $filename;
      printf $OUT "sequences:       %7d\n",         $seq_cnt;
      printf $OUT "total length: %10d bp  %-25s\n", $totalSeqLen, $nonNSeqLen;
      printf $OUT "GC level:        %6s \%\n",      $frac_GC;
      printf $OUT "bases masked: %10d bp ( %4.2f \%)\n", $maskedlength,
          $maskedpercent;
      printf $OUT "==================================================\n";
      printf $OUT "               number of      length   percentage\n";
      printf $OUT "               elements*    occupied  of sequence\n";
      printf $OUT "--------------------------------------------------\n";
      printf $OUT "Retroelements       %6d   %10d bp   %5.2f \%\n",
          $linecnt + $sinecnt + $ltrcnt, $linelength + $sinelength + $ltrlength,
          ( $linelength + $sinelength + $ltrlength ) * 100 * $usePerc /
          $totseqlen;
      printf $OUT "   SINEs:           %6d   %10d bp   %5.2f \%\n", $sinecnt,
          $sinelength, $sinelength * 100 * $usePerc / $totseqlen;
      printf $OUT "   Penelope         %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/Penelope"}, $totlength{"LINE/Penelope"},
          $totlength{"LINE/Penelope"} * 100 * $usePerc / $totseqlen;
      printf $OUT "   LINEs:           %6d   %10d bp   %5.2f \%\n", $linecnt,
          $linelength, $linelength * 100 * $usePerc / $totseqlen;
      printf $OUT "    CRE/SLACS       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/CRE"}, $totlength{"LINE/CRE"},
          $totlength{"LINE/CRE"} * 100 * $usePerc / $totseqlen;
      printf $OUT "     L2/CR1/Rex     %6d   %10d bp   %5.2f \%\n", $lineCR1cnt,
          $lineCR1length, $lineCR1length * 100 * $usePerc / $totseqlen;
      printf $OUT "     R1/LOA/Jockey  %6d   %10d bp   %5.2f \%\n", $lineIcnt,
          $lineIlength, $lineIlength * 100 * $usePerc / $totseqlen;
      printf $OUT "     R2/R4/NeSL     %6d   %10d bp   %5.2f \%\n", $lineR2cnt,
          $lineR2length, $lineR2length * 100 * $usePerc / $totseqlen;
      printf $OUT "     RTE/Bov-B      %6d   %10d bp   %5.2f \%\n", $lineRTEcnt,
          $lineRTElength, $lineRTElength * 100 * $usePerc / $totseqlen;
      printf $OUT "     L1/CIN4        %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LINE/L1"}, $totlength{"LINE/L1"},
          $totlength{"LINE/L1"} * 100 * $usePerc / $totseqlen;
      printf $OUT "   LTR elements:    %6d   %10d bp   %5.2f \%\n", $ltrcnt,
          $ltrlength, $ltrlength * 100 * $usePerc / $totseqlen;
      printf $OUT "     BEL/Pao        %6d   %10d bp   %5.2f \%\n", $ltrBELcnt,
          $ltrBELlength, $ltrBELlength * 100 * $usePerc / $totseqlen;
      printf $OUT "     Ty1/Copia      %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"LTR/Copia"}, $totlength{"LTR/Copia"},
          $totlength{"LTR/Copia"} * 100 * $usePerc / $totseqlen;
      printf $OUT "     Gypsy/DIRS1    %6d   %10d bp   %5.2f \%\n", $ltrGYPcnt,
          $ltrGYPlength, $ltrGYPlength * 100 * $usePerc / $totseqlen;
      printf $OUT "       Retroviral   %6d   %10d bp   %5.2f \%\n", $ltrERVcnt,
          $ltrERVlength, $ltrERVlength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "DNA transposons     %6d   %10d bp   %5.2f \%\n", $dnacnt,
          $dnalength, $dnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "   hobo-Activator   %6d   %10d bp   %5.2f \%\n", $dnaHATcnt,
          $dnaHATlength, $dnaHATlength * 100 * $usePerc / $totseqlen;
      printf $OUT "   Tc1-IS630-Pogo   %6d   %10d bp   %5.2f \%\n", $dnaTC1cnt,
          $dnaTC1length, $dnaTC1length * 100 * $usePerc / $totseqlen;
      printf $OUT "   En-Spm           %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/En-Spm"}, $totlength{"DNA/En-Spm"},
          $totlength{"DNA/En-Spm"} * 100 * $usePerc / $totseqlen;
      printf $OUT "   MuDR-IS905       %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"DNA/MuDR"}, $totlength{"DNA/MuDR"},
          $totlength{"DNA/MuDR"} * 100 * $usePerc / $totseqlen;
      printf $OUT "   PiggyBac         %6d   %10d bp   %5.2f \%\n", $dnaPIGcnt,
          $dnaPIGlength, $dnaPIGlength * 100 * $usePerc / $totseqlen;
      printf $OUT "   Tourist/Harbinger%6d   %10d bp   %5.2f \%\n", $dnaHcnt,
          $dnaHlength, $dnaHlength * 100 * $usePerc / $totseqlen;
      printf $OUT "   Other (Mirage,   %6d   %10d bp   %5.2f \%\n", $dnaPcnt,
          $dnaPlength, $dnaPlength * 100 * $usePerc / $totseqlen;
      printf $OUT "    P-element, Transib)\n";
      printf $OUT "\n";
      printf $OUT "Rolling-circles     %6d   %10d bp   %5.2f \%\n",
          $uniqCount{"RC/Helicop"}, $totlength{"RC/Helicop"},
          $totlength{"RC/Helicop"} * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Unclassified:       %6d   %10d bp   %5.2f \%\n", $othercnt,
          $otherlength, $otherlength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Total interspersed repeats:  %10d bp   %5.2f \%\n",
          $totallength, $totallength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n\n";
      printf $OUT "Small RNA:          %6d   %10d bp   %5.2f \%\n", $rnacnt,
          $rnalength, $rnalength * 100 * $usePerc / $totseqlen;
      printf $OUT "\n";
      printf $OUT "Satellites:         %6d   %10d bp   %5.2f \%\n", $satelcnt,
          $satellength, $satellength * 100 * $usePerc / $totseqlen;
      printf $OUT "Simple repeats:     %6d   %10d bp   %5.2f \%\n", $simplecnt,
          $simplelength, $simplelength * 100 * $usePerc / $totseqlen;
      printf $OUT "Low complexity:     %6d   %10d bp   %5.2f \%\n", $lowcompcnt,
          $lowcomplength, $lowcomplength * 100 * $usePerc / $totseqlen;
      printf $OUT "==================================================\n";
      printf $OUT "\n";
      printf $OUT "* most repeats fragmented by insertions or deletions\n";
      printf $OUT "  have been counted as one element\n";
      printf $OUT "%54s\n", $exclnote;
      printf $OUT "\n";
      printf $OUT "$queryorigin\n";
      printf $OUT "%-82s\n", substr( $versionmode, 0, 82 );
      printf $OUT "$engine\n";
      printf $OUT "$dbversion\n";
      close $OUT;
    }
  }
  close OUTXM   if $options{'xm'};
  close OUTACE  if $options{'ace'};
  close OUTGFF  if $options{'gff'};
  close OUTPOLY if $options{'poly'};
  print STDERR "\ndone\n";

}    # For each file

#########################################################################
##subroutines
#########################################################################

sub getMaxColWidths {
  my $annotationListRef = shift;

  my %widths = (
                 'SW'            => 5,
                 'BeginAlign'    => 5,
                 'Seq2Begin'     => 5,
                 'PctSubst'      => 5,
                 'PctInsert'     => 4,
                 'PctDelete'     => 4,
                 'Seq1Name'      => 8,
                 'HitName'       => 8,
                 'EndAlign'      => 5,
                 'LeftOver'      => 6,
                 'Seq2End'       => 4,
                 'class'         => 10,
                 'LeftUnaligned' => 6,
                 'ID'            => 3
  );

  if ( !defined $annotationListRef ) {
    return ( %widths );
  }

  my $annotIter = $annotationListRef->getIterator();

  while ( $annotIter->hasNext() ) {
    my $annot = $annotIter->next();

    my $Seq2BeginLen     = length "(" . $annot->get3PrimeUnaligned . ")";
    my $LeftUnalignedLen = length $annot->getSeq2Beg();
    if ( $annot->getRevComp eq '+' ) {
      $Seq2BeginLen     = length $annot->getSeq2Beg();
      $LeftUnalignedLen = length "(" . $annot->get3PrimeUnaligned . ")";
    }
    $widths{'SW'} = length $annot->getSW
        if $widths{'SW'} < length $annot->getSW;
    $widths{'Seq1Name'} = length $annot->getSeq1Name
        if $widths{'Seq1Name'} < length $annot->getSeq1Name;
    $widths{'BeginAlign'} = length $annot->getSeq1Beg
        if $widths{'BeginAlign'} < length $annot->getSeq1Beg;
    $widths{'EndAlign'} = length $annot->getSeq1End
        if $widths{'EndAlign'} < length $annot->getSeq1End;
    $widths{'LeftOver'} = length( $annot->getLeftOver() ) + 2
        if $widths{'LeftOver'} < length( $annot->getLeftOver() ) + 2;
    $widths{'HitName'} = length $annot->getHitName()
        if $widths{'HitName'} < length $annot->getHitName();
    $widths{'class'} = length $annot->getClassName
        if $widths{'class'} < length $annot->getClassName;
    $widths{'Seq2Begin'} = $Seq2BeginLen
        if $widths{'Seq2Begin'} < $Seq2BeginLen;
    $widths{'Seq2End'} = length $annot->getSeq2End
        if $widths{'Seq2End'} < length $annot->getSeq2End;
    $widths{'LeftUnaligned'} = $LeftUnalignedLen
        if $widths{'LeftUnaligned'} < $LeftUnalignedLen;
    $widths{'ID'} = length $annot->getID()
        if $widths{'ID'} < length $annot->getID();
  }

  return ( %widths );
}

sub printSourceAnnots {
  my $annot     = shift;
  my $widthsRef = shift;
  my $level     = shift;

  my %colWidths = %{$widthsRef};
  return if ( !defined $annot->getDerivedFromAnnot() );
  my @srcMembers = @{ $annot->getDerivedFromAnnot() };
  foreach my $member ( @srcMembers ) {
    print OUTFULL "  " x ( $level ) . "-> ";
    printf OUTFULL "%${colWidths{'SW'}}d  %${colWidths{'PctSubst'}}s "
        . "%${colWidths{'PctDelete'}}s "
        . "%${colWidths{'PctInsert'}}s  "
        . "%-${colWidths{'Seq1Name'}}s  "
        . "%${colWidths{'BeginAlign'}}s "
        . "%${colWidths{'EndAlign'}}s "
        . "%${colWidths{'LeftOver'}}s %1s "
        . "%-${colWidths{'HitName'}}s "
        . "%-${colWidths{'class'}}s "
        . "%${colWidths{'Seq2Begin'}}s "
        . "%${colWidths{'Seq2End'}}s "
        . "%${colWidths{'LeftUnaligned'}}s %${colWidths{'ID'}}s\n",
        $member->getSW(), $member->getPctSubst(), $member->getPctDelete(),
        $member->getPctInsert(), $member->getSeq1Name(),  $member->getSeq1Beg(),
        $member->getSeq1End(),   $member->getLeftOver(),  $member->getRevComp(),
        $member->getHitName(),   $member->getClassName(), $member->getSeq2Beg(),
        $member->getSeq2End(), $member->get3PrimeUnaligned(), $member->getID();
    &printSourceAnnots( $member, $widthsRef, $level++ );
  }
}

sub scoreLINEPair {
  my $annot1          = shift;
  my $annot2          = shift;
  my $elementDistance = shift;
  my $optRef          = shift;

  my $score = 0;
  my $DEBUG = 0;

  if ( $DEBUG ) {
    print STDERR "scoreLINEPair(): Scoring these two:\n";
    $annot1->print();
    $annot2->print();
  }

  # Establish position order
  my $leftAnnot  = $annot1;
  my $rightAnnot = $annot2;
  if ( $annot1->comparePositionOrder( $annot2 ) > 0 ) {
    $leftAnnot  = $annot2;
    $rightAnnot = $annot1;
  }

  # Calculate query overlap
  my $queryOverlap = $rightAnnot->getQueryOverlap( $leftAnnot );

  # Calculate consensus overlap & consensus gap
  my $consensusOverlap = $rightAnnot->getConsensusOverlap( $leftAnnot );
  my $consensusGap     = -$consensusOverlap;
  my $adjConOverlap    = $consensusOverlap;
  $adjConOverlap -= $queryOverlap if $queryOverlap > 0;

  # Determine name compatability
  my $namesCompat = 0;
  if ( $leftAnnot->getSeq2Name() eq $rightAnnot->getSeq2Name() ) {
    $namesCompat = 1;
  }
  else {
    my $nameHash = undef;
    if ( defined $RepeatAnnotationData::lineHash{ $leftAnnot->getHitName() } ) {
      $nameHash = $RepeatAnnotationData::lineHash{ $leftAnnot->getHitName() };
    }
    elsif (
          defined $RepeatAnnotationData::lineHash{ $rightAnnot->getHitName() } )
    {

      #warn "RepeatAnnotationData does not contain data on " .
      #     $leftAnnot->getHitName() . "\n";
      $nameHash = $RepeatAnnotationData::lineHash{ $rightAnnot->getHitName() };
    }
    else {

      #warn "RepeatAnnotationData does not contain data on " .
      #     $rightAnnot->getHitName() . "\n";
    }

    if ( $nameHash ) {
      my $nameEntry = undef;
      if ( defined $nameHash->{ $rightAnnot->getHitName() } ) {
        $nameEntry = $nameHash->{ $rightAnnot->getHitName() };
      }
      elsif ( defined $nameHash->{ $leftAnnot->getHitName() } ) {

        #warn "RepeatAnnotationData contains a non-reciprocal entry " .
        #     $rightAnnot->getHitName() . "\n";
        $nameEntry = $nameHash->{ $leftAnnot->getHitName() };
      }

      if ( $nameEntry ) {
        my $overlapThresh = $nameEntry->{'overThresh'};
        print STDERR "Names compatable: "
            . $rightAnnot->getHitName() . " "
            . $leftAnnot->getHitName()
            . " ot=$overlapThresh\n"
            if ( $DEBUG );
        if ( $overlapThresh >= 0 ) {
          $namesCompat = 1
              if ( $overlapThresh == 0
                   || ( $queryOverlap > $overlapThresh ) );
        }
      }    # if ( $nameEntry...
    }    # if ( $nameHash...
    else {
    }
  }    #else names are equal

  #
  # First use essential qualifiers
  #  - Same query sequence
  #  - Same orientation
  #
  if (    $annot1->getSeq1Name() eq $annot2->getSeq1Name()
       && $annot1->getRevComp() eq $annot2->getRevComp() )
  {

    print STDERR "scoreLINEPair() get3PrimeUnaligned = "
        . $leftAnnot->get3PrimeUnaligned . "\n"
        if ( $DEBUG );

    #
    # Consensus Positions Make Sense
    #
    #     i.e   100----->  50----->
    #        or <------200 <------320
    #
    if (
         (
              $leftAnnot->getRevComp() eq "+"
           && $rightAnnot->getSeq2Beg() >= $leftAnnot->getSeq2Beg() - 5
           || $leftAnnot->getRevComp() eq "C"
           && $leftAnnot->getSeq2Beg() >= $rightAnnot->getSeq2Beg() - 5
         )
        )
    {

      #
      # Is the model order valid and is there room
      # for model extension?
      #
      # i.e. do not allow:
      #       5 <--- 3
      #  or   3 ---> 5
      #
      # Also do not allow ( because? ):
      #
      #      3 --->|  anything
      #  or  anything |<---- 5
      #
      my $modelCompat = 1;
      if (
              $leftAnnot->getRevComp() eq "+"
           && $leftAnnot->getSeq2Name() =~ /_3end/
           && (    $rightAnnot->getSeq2Name() =~ /_5end/
                || $leftAnnot->get3PrimeUnaligned() < 10 )
           || $rightAnnot->getRevComp() eq "C"
           && $rightAnnot->getSeq2Name() =~ /_3end/
           && (    $leftAnnot->getSeq2Name() =~ /_5end/
                || $rightAnnot->getLeftOver() < 10 )
          )
      {
        $modelCompat = 0;
      }

      if ( $modelCompat ) {
        if ( $namesCompat ) {

          #
          # Calculate score:
          #   - divergence difference  ( large = bad )
          #   - query overlap          ( overlap = good, gap = worse )
          #   - consensus overlap      ( large overlap = bad, large gap = bad )
          #   distfine = CO < 33 && CG <=200 ||
          #      really complex CO/QO & Div formula
          #

          # divDiff = The closer the two divergences are to each
          #          other the closer divDiff gets to its max of
          #          1.54.  NOTE: It's later limited to 1.2
          #          wha? wha? wha?
          my $divDiff;
          if (    $rightAnnot->getPctSubst() > $leftAnnot->getPctSubst()
               && $rightAnnot->getPctSubst() > 0 )
          {
            $divDiff =
                ( ( $leftAnnot->getPctSubst() / $rightAnnot->getPctSubst() ) /
                  0.65 ) -
                ( ( $rightAnnot->getPctSubst() - $leftAnnot->getPctSubst() ) /
                  100 );
          }
          elsif (    $leftAnnot->getPctSubst() > $rightAnnot->getPctSubst()
                  && $leftAnnot->getPctSubst() > 0 )
          {
            $divDiff =
                ( $rightAnnot->getPctSubst() / $leftAnnot->getPctSubst() ) /
                0.65 -
                ( $leftAnnot->getPctSubst() - $rightAnnot->getPctSubst() ) /
                100;
          }
          else {
            $divDiff = 1.2;
          }
          $divDiff = 1.2 if $divDiff > 1.2;

          # Factor decreasing with number of intervening
          # elements ( of same type ); should prevent way distant link-ups
          my $elementDistanceFactor = 1 - ( $elementDistance - 1 ) / 30;

          my $avgLeftUnaligned = $leftAnnot->get3PrimeUnaligned();
          $avgLeftUnaligned = $rightAnnot->get3PrimeUnaligned()
              if ( $avgLeftUnaligned < $rightAnnot->get3PrimeUnaligned() );

          if ( $DEBUG ) {
            print STDERR "Stats: queryOverlap = $queryOverlap,\n"
                . "       consensusOverlap = $consensusOverlap,\n"
                . "       divDiff = $divDiff > 0.1,\n"
                . "       elementDistance = $elementDistance,\n"
                . "       elementDistanceFactor = $elementDistanceFactor,\n"
                . "       avgLeftUnaligned = $avgLeftUnaligned,\n";
            print STDERR "       adjConOverlap = $adjConOverlap <= "
                . ( ( 3.75 * $avgLeftUnaligned**0.48 - 47 ) *
                    $elementDistanceFactor**2 * $divDiff )
                . ",\n";
            print STDERR "       consGap = $consensusGap <= "
                . (
                   $elementDistanceFactor * $divDiff * $avgLeftUnaligned / 1.4 )
                . "\n";
          }

          if (

            # The allowed conensus overlap is dependent on the position
            # in the LINE1 consensus.  The further it is from the 3' end
            # ($LeftUnaligned) the more overlap is tolerated, this
            # somewhat has to do with the relatively poor representation
            # of 5' region consensus sequences, but largely because of
            # the presence of tandem promoter units. This should be
            # solved in a better way, e.g. identifying the tandem
            # repeats in the consensus sequences and treating those
            # regions as we treat satellites.

            # The overlap quadratically relates to the distance in IDs.
            (
                 $adjConOverlap == 0
              || $adjConOverlap <= ( 3.75 * $avgLeftUnaligned**0.48 - 47 ) *
              $elementDistanceFactor**2 * $divDiff
            )
            && $divDiff > 0.1    # I'm being generous here
            && $consensusGap <=
            $elementDistanceFactor * $divDiff * $avgLeftUnaligned / 1.4
              )
          {

            # consensus gap should be allowed to be larger the more 5'
            # you get, since these regions are getting rarer
            #print STDERR "****DISTFINE SET*****\n";
            print STDERR "   -- We call this good!\n" if ( $DEBUG );
            $score = 1;
          }

        }
        elsif ( $DEBUG ) {
          print STDERR "scoreLINEPair(): Names Not Compat Rule\n";
        }    # ...if ( $namesCompat...

      }
      elsif ( $DEBUG ) {
        print STDERR "scoreLINEPair(): Invalid Model Order or "
            . "Insufficient Unaligned\n";
      }    # if ( $modelCompat...

    }
    elsif ( $DEBUG ) {
      print STDERR "scoreLINEPair(): Invalid Consensus Order\n";
    }    # Do consensus positions make sense?

    #
    # Determine ShortHitName Compat
    #
    my $shortHitNameCompatible = 0;
    my $HitName                = $rightAnnot->getHitName();
    $HitName =~ s/_orf2$//;

    # TODO: This is a special case of an element which needs
    #       a portion of it's sequence masked out in a separate stage.
    #       The sequence is a simple repeats which is scored too high
    #       otherwise. I am refering to the endX designation.
    $HitName =~ s/(.*)_[35]endX?$/$1/;
    $HitName =~ s/_strong$//;

    # could use latter as a general tool to indicate a diagnostic fragment
    # rename carnivore LINEs who's name have been adjusted
    # temporarily to allow neighboring fragment recognition
    if ( $HitName =~ /^L1_Ca/ ) {
      $HitName =~ s/^L1_Canis0/L1_Cf/;
      $HitName =~ s/^L1_Canis4/L1_Canid/;
      $HitName =~ s/^L1_Canis5/L1_Canid2/;
    }
    my $shortHitName = $HitName;
    if ( $HitName =~ /^L1M/ ) {
      $shortHitName =~ s/(^\w{5}).*/$1/;
    }
    elsif ( $optRef->{'mammal'} && $HitName =~ /^L1_/ ) {
      $shortHitName = "L1_";
    }
    else {
      $shortHitName =~ s/(\S+\d)[a-zA-Z]$/$1/;
    }
    $shortHitName = quotemeta $shortHitName;
    my $leftHitName = $leftAnnot->getHitName();
    $leftHitName =~ s/_orf2$//;
    $leftHitName =~ s/(.*)_[35]endX?$/$1/;
    $leftHitName =~ s/_strong$//;
    if ( $leftHitName =~ /^L1_Ca/ ) {
      $leftHitName =~ s/^L1_Canis0/L1_Cf/;
      $leftHitName =~ s/^L1_Canis4/L1_Canid/;
      $leftHitName =~ s/^L1_Canis5/L1_Canid2/;
    }
    print STDERR "scoreLINEPair(): shortHitName = $shortHitName\n"
        if ( $DEBUG );
    if ( $leftHitName =~ /^$shortHitName/ ) {
      $shortHitNameCompatible = 1;
      print STDERR "scoreLINEPair(): shortHitNameCompatible -- yes\n"
          if ( $DEBUG );
    }

    # Less stringent
    if ( $score == 0 && $shortHitNameCompatible ) {
      print STDERR "scoreLINEPair():  last chance test ( names compat )\n"
          if ( $DEBUG );
      my $gapMax = 2500;
      $gapMax *= 1.5
          if ( $leftAnnot->getHitName() eq $rightAnnot->getHitName() );

      # Need to revise the way div diff is calc'd
      my $divDiff = $leftAnnot->getPctSubst() - $rightAnnot->getPctSubst();
      $divDiff = -$divDiff if ( $divDiff < 0 );
      $gapMax *= ( 10 - $divDiff ) / 10;
      $gapMax *= ( 10 - $elementDistance ) / 10;
      if ( $DEBUG ) {
        print STDERR " divDiff = $divDiff\n";
        print STDERR " gapMax = $gapMax > cg="
            . $leftAnnot->getConsensusGap( $rightAnnot ) . "\n";
      }
      if (    $leftAnnot->getConsensusOverlap( $rightAnnot ) < 33
           && $leftAnnot->getConsensusOverlap( $rightAnnot ) > -$gapMax )
      {
        print STDERR "scoreLINEPair():   Hmmm....questionable...but "
            . "going to do it\n"
            if ( $DEBUG );
        $score = 0.5;
      }
    }
    if ( $score == 0 ) {
      print STDERR "scoreLINEPair():  lastiness test\n"
          if ( $DEBUG );
      if (    $leftAnnot->getSeq1End() >= $rightAnnot->getSeq1Beg()
           && $rightAnnot->getSeq1End() > $leftAnnot->getSeq1End() )
      {

        #
        # If these element shave the same class, orientation,
        # similar names with small overlap or simply just
        # a large overlap then join them!!!  Arghhh
        #
        if (    $shortHitNameCompatible
             && $rightAnnot->getSeq1Beg() <= $leftAnnot->getSeq1End() - 12
             || $rightAnnot->getSeq1Beg() <= $leftAnnot->getSeq1End() - 33 )
        {
          if ( !$namesCompat ) {

            #warn "Must add "
            #    . $leftAnnot->getHitName() . " and "
            #    . $rightAnnot->getHitName()
            #    . " to the compat hash\n";
          }
          print STDERR "scoreLINEPair(): Well if you insist\n" if ( $DEBUG );
          $score = 0.25;
        }
      }
    }

  }
  elsif ( $DEBUG ) {
    print STDERR "scoreLINEPair(): Wrong Seq or Orientation Rule\n";
  }    # Same queryName and Same orientation

  if ( $score ) {
    my $conOverlapFactor = -1;
    $conOverlapFactor = 1 / abs( $adjConOverlap + $queryOverlap )
        if ( $adjConOverlap + $queryOverlap != 0 );

    if ( $DEBUG ) {
      print STDERR "adjConOverlap = $adjConOverlap + "
          . "queryOverlap = $queryOverlap conOverlapFactor "
          . "= $conOverlapFactor\n";
      print STDERR "score = $score\n";
    }

    if ( $conOverlapFactor > 0 ) {
      $score += $conOverlapFactor;
    }
    else {
      print STDERR "Using elementdistance = $elementDistance\n" if ( $DEBUG );
      $score += 1 / $elementDistance;
    }
  }

  print STDERR "scoreLINEPair(): Final Score = $score\n"
      if ( $DEBUG );

  return ( $score );
}

sub areLINENamesCompat {
  my $line1 = shift;
  my $line2 = shift;

  # If name incompatible then return low score early
  my $compat         = 0;
  my $line1Name      = $line1->getHitName();
  my $line1ClassName = $line1->getClassName();
  my $line2Name      = $line2->getHitName();
  my $line2ClassName = $line2->getClassName();

  # Establish position order
  my $leftAnnot  = $line1;
  my $rightAnnot = $line2;
  if ( $line1->comparePositionOrder( $line2 ) > 0 ) {
    $leftAnnot  = $line2;
    $rightAnnot = $line1;
  }

  my $queryOverlap = $rightAnnot->getQueryOverlap( $leftAnnot );

  if ( $line1->getSeq2Name() eq $line2->getSeq2Name() ) {
    $compat = 1;
  }
  elsif ( defined $RepeatAnnotationData::lineHash{$line1Name}->{$line2Name} ) {
    my $overlapThresh =
        $RepeatAnnotationData::lineHash{$line1Name}->{$line2Name}
        ->{'overThresh'};
    if ( $overlapThresh >= 0 ) {
      $compat = 1
          if ( $overlapThresh == 0
               || ( $queryOverlap > $overlapThresh ) );
    }
  }
  elsif ( defined $RepeatAnnotationData::lineHash{$line2Name}->{$line1Name} ) {
    my $overlapThresh =
        $RepeatAnnotationData::lineHash{$line2Name}->{$line1Name}
        ->{'overThresh'};
    if ( $overlapThresh >= 0 ) {
      $compat = 1
          if ( $overlapThresh == 0
               || ( $queryOverlap > $overlapThresh ) );
    }
  }
  else {
    print STDERR "Names not compatable\n" if ( $DEBUG );
  }

  return ( $compat );
}

sub calcAnnotationStats {
  my $annotArrayList = shift;
  my $optRef         = shift;

  my $filename      = "";
  my $seq_cnt       = 0;
  my $totalSeqLen   = "";
  my $nonNSeqLen    = "";
  my $frac_GC       = "";
  my $maskedpercent = "";
  my $source        = "";
  my $exclnote      = "";
  my $versionmode   = "";
  my $engine        = "";
  my $dbversion     = "";

  my $DEBUG = 0;

  # Create an ArrayListIterator for this cycle
  my $annotIter = $annotArrayList->getIterator();
  my %idSeen    = ();
  my $pastAnnot = undef;
  my %stats     = ();
  while ( $annotIter->hasNext() ) {
    my $annot     = $annotIter->next();
    my $length    = $annot->getSeq1End() - $annot->getSeq1Beg() + 1;
    my $id        = $annot->getID();
    my $hitName   = $annot->getHitName();
    my $className = $annot->getClassName();
    print STDERR "Considering  $id - $hitName\#$className\n" if ( $DEBUG );

    # Confident class are equivalent to insecure ones.
    $className =~ s/\?$//;
    my ( $type, $subtype ) = split( /\//, $className );

    if ( !defined $idSeen{$id} ) {
      $stats{'totalcnt'}++;
      $stats{'classes'}->{$type}->{'count'}++;
      $stats{'classes'}->{$type}->{'subclasses'}->{$subtype}->{'count'}++
          if ( $subtype ne "" );
    }
    if (    $pastAnnot
         && $pastAnnot->getSeq1End() >= $annot->getSeq1Beg() )
    {
      $length -= ( $pastAnnot->getSeq1End() - $annot->getSeq1Beg() + 1 );
    }
    $stats{'totallen'}                     += $length;
    $stats{'classes'}->{$type}->{'length'} += $length;
    $stats{'classes'}->{$type}->{'subclasses'}->{$subtype}->{'length'} +=
        $length
        if ( $subtype ne "" );
    $idSeen{$id}++;
    $pastAnnot = $annot;
  }

  my %tables = (
    "human" =>

        [
          "SINEs", "SINE", "",
          [ [ "ALUs", "SINE", "Alu" ], [ "MIRs", "SINE", "MIR" ] ],
          "LINEs", "LINE", "",
          [
            [ "LINE1",  "LINE", "L1" ],
            [ "LINE2",  "LINE", "L2" ],
            [ "L3/CR1", "LINE", "CR1" ]
          ],
          "LTR elements",
          "LTR", "",
          [
            [ "MaLRs",       "LTR", "MaLR" ],
            [ "ERVL",        "LTR", "ERVL" ],
            [ "ERV_classI",  "LTR", "ERV1" ],
            [ "ERV_classII", "LTR", "ERVK" ]
          ],
          "DNA elements",
          "DNA", "",
          [
            [ "MER1_type", "DNA", "MER1_type" ],
            [ "MER2_type", "DNA", "MER2_type" ]
          ],
          "Unclassified",
          "Agregate(Other)",
          "", undef,
          "Total interspersed repeats",
          "Agregate(INTER)",
          "", undef,
          "Small RNA",
          "Agregate(RNA)",
          "", undef,
          "Satellites",
          "Satellite",
          "", undef,
          "Simple repeats",
          "Simple_repeat",
          "", undef,
          "Low Complexity",
          "Low_complexity",
          "", undef
        ],
    "general" => [
                   "Retroelements",
                   "Agregate(RETRO)",
                   "", undef,
                   "  SINEs",
                   "SINE", "",
                   [ [ "Penelope", "LINE", "Penelope" ] ],
                   "  LINEs",
                   "LINE", "",
                   [
                     [ "CRE/SLACS",     "LINE",              "CRE" ],
                     [ "L2/CR1/Rex",    "Agregate(LINECR1)", "" ],
                     [ "R1/LOA/Jockey", "Agregate(LINEI)",   "" ],
                     [ "R2/R4/NeSL",    "Agregate(LINER2)",  "" ],
                     [ "RTE/Bov-B",     "Agregate(LINERTE)", "" ],
                     [ "L1/CIN4",       "LINE",              "L1" ]
                   ],
                   "  LTR elements",
                   "LTR", "",
                   [
                     [ "BEL/Pao",      "Agregate(LTRBEL)", "" ],
                     [ "Ty1/Copia",    "LTR",              "COPIA" ],
                     [ "Gypesy/DIRS1", "Agregate(LTRGYP)", "" ],
                     [ "Retroviral",   "Agregate(LTRERV)", "" ],
                   ],
                   "DNA transposons",
                   "DNA", "",
                   [
                     [ "hobo-Activator",    "Agregate(DNAHAT)", "" ],
                     [ "Tc1-IS630-Pogo",    "Agregate(DNATC1)", "" ],
                     [ "En-Spm",            "DNA",              "En-Spm" ],
                     [ "MuDR-IS905",        "DNA",              "MuDR" ],
                     [ "PiggyBac",          "Agregate(DNAPIG)", "" ],
                     [ "Tourist/Harbinger", "Agregate(DNAH)",   "" ],
                     [ "Mirage/P/Transib",  "Agregate(DNAP)",   "" ]
                   ],
                   "Rolling-circles",
                   "RC",
                   "Helicop",
                   undef,
                   "Unclassified",
                   "Agregate(Other)",
                   "", undef,
                   "Total interspersed repeats",
                   "Agregate(INTER)",
                   "", undef,
                   "Small RNA",
                   "Agregate(RNA)",
                   "", undef,
                   "Satellites",
                   "Satellite",
                   "", undef,
                   "Simple repeats",
                   "Simple_repeat",
                   "", undef,
                   "Low Complexity",
                   "Low_complexity",
                   "", undef
    ]
  );

  # Agregate calculations
  my $ag = $stats{'agregates'} = {};
  foreach my $type ( keys( %{ $stats{'classes'} } ) ) {
    my $typeStats = $stats{'classes'}->{$type};

    # Type agregates
    if ( $type =~ /RNA$/ ) {
      $ag->{'RNA'}->{'count'}  += $typeStats->{'count'};
      $ag->{'RNA'}->{'length'} += $typeStats->{'length'};
    }

    if ( $type =~ /LINE|SINE|LTR/ ) {
      $ag->{'RETRO'}->{'count'}  += $typeStats->{'count'};
      $ag->{'RETRO'}->{'length'} += $typeStats->{'length'};
    }

    # Type/Subtype agregates
    if ( defined $stats{'classes'}->{$type}->{'subclasses'} ) {
      my $subtypeStats = $typeStats->{'subclasses'};
      foreach my $subType ( keys( %{$subtypeStats} ) ) {
        if ( $type eq "LINE" && $subType =~ /CR1$|L2$|Rex-Babar$/ ) {
          $ag->{'LINECR1'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'LINECR1'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "LINE" && $subType =~ /R1$|LOA$|I$|Jockey$/ ) {
          $ag->{'LINEI'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'LINEI'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "LINE" && $subType =~ /RTE|Bov-B/ ) {
          $ag->{'LINERTE'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'LINERTE'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "LINE" && $subType =~ /NeSL|R[24]|Dong/ ) {
          $ag->{'LINER2'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'LINER2'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "LTR" && $subType =~ /ERV|MaLR/ ) {
          $ag->{'LTRERV'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'LTRERV'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "LTR" && $subType =~ /PAO$|BEL$/i ) {
          $ag->{'LTRBEL'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'LTRBEL'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "LTR" && $subType =~ /DIRS$|Gypsy$/ ) {
          $ag->{'LTRGYP'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'LTRGYP'}->{'length'} += $subtypeStats->{'length'};
        }

        if (    $type eq "DNA"
             && $subType =~ /Mariner|Tc[124]$|MER2|Tigger|Pogo|Stowaway/ )
        {
          $ag->{'DNATC1'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'DNATC1'}->{'length'} += $subtypeStats->{'length'};
        }

        if (    $type eq "DNA"
             && $subType =~ /[hH]AT|AcHobo|Tam3$|Tol2$|Tip100|MER1|Charlie/ )
        {
          $ag->{'DNAHAT'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'DNAHAT'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "DNA" && $subType =~ /T2$|PiggyBac/ ) {
          $ag->{'DNAPIG'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'DNAPIG'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "DNA" && $subType =~ /Harbing|Tourist/ ) {
          $ag->{'DNAH'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'DNAH'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type eq "DNA" && $subType =~ /P$|Mirage|Transib/ ) {
          $ag->{'DNAP'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'DNAP'}->{'length'} += $subtypeStats->{'length'};
        }

        if ( $type =~ /^Unknown|^Other/ || $subType =~ /^Composite/ ) {
          $ag->{'OTHER'}->{'count'}  += $subtypeStats->{'count'};
          $ag->{'OTHER'}->{'length'} += $subtypeStats->{'length'};
        }

        if (    $type =~ /SINE|LINE|LTR|DNA|Unknown|Other/
             || $subType =~ /^Composite/ )
        {
          $ag->{'INTER'}->{'count'}  += $typeStats->{'count'};
          $ag->{'INTER'}->{'length'} += $typeStats->{'length'};
        }
      }
    }
    else {
      if ( $type =~ /^Unknown|^Other/ ) {
        $ag->{'OTHER'}->{'count'}  += $typeStats->{'count'};
        $ag->{'OTHER'}->{'length'} += $typeStats->{'length'};
      }
      if ( $type =~ /SINE|LINE|LTR|DNA|Unknown|Other/ ) {
        $ag->{'INTER'}->{'count'}  += $typeStats->{'count'};
        $ag->{'INTER'}->{'length'} += $typeStats->{'length'};
      }
    }
  }
  print STDERR "STATS:\n" . Dumper( \%stats ) . "\n";

  print STDERR "\n\n";
  print STDERR "========================================================\n";
  print STDERR "file name: $filename\n";
  print STDERR "sequences:       $seq_cnt\n";
  print STDERR "total length: $totalSeqLen bp  $nonNSeqLen\n";
  print STDERR "GC level:        $frac_GC %\n";
  print STDERR "bases masked: "
      . $stats{'totallen'} . " bp ("
      . ( $maskedpercent ) . " %)\n";
  print STDERR "========================================================\n";
  print STDERR "                      number of      length   percentage\n";
  print STDERR "                      elements*    occupied  of sequence\n";
  print STDERR "--------------------------------------------------------\n";

 #  printf STDERR "%-15s     %6d    %9d bp\n",
 #                "SINEs:",
 #                $stats{'classes'}->{'SINE'}->{'count'},
 #                $stats{'classes'}->{'SINE'}->{'length'},
 #                ( $stats{'classes'}->{'SINE'}->{'length'} * 100 /
 #                  $totalSeqLen );
 #  printf STDERR "%15s     %6d    %9d bp\n",
 #            "ALUs",
 #            $stats{'classes'}->{'SINE'}->{'subclasses'}->{'ALU'}->{'count'},
 #            $stats{'classes'}->{'SINE'}->{'subclasses'}->{'ALU'}->{'length'},
 #            ( $stats{'classes'}->{'SINE'}->{'subclasses'}->{'ALU'}->{'length'}
 #            * 100 / $totalSeqLen );
 #  printf STDERR "%15s     %6d    %9d bp\n",
 #            "MIRs",
 #            $stats{'classes'}->{'SINE'}->{'subclasses'}->{'MIR'}->{'count'},
 #            $stats{'classes'}->{'SINE'}->{'subclasses'}->{'MIR'}->{'length'},
 #            ( $stats{'classes'}->{'SINE'}->{'subclasses'}->{'MIR'}->{'length'}
 #            * 100 / $totalSeqLen );
 #

  my $tableRef  = $tables{'general'};
  my $subTotCnt = 0;
  my $subTotLen = 0;
  for ( my $i = 0 ; $i < $#{$tableRef} ; $i += 4 ) {
    my $heading     = $tableRef->[ $i ];
    my $source1     = $tableRef->[ $i + 1 ];
    my $source2     = $tableRef->[ $i + 2 ];
    my $subHeadings = $tableRef->[ $i + 3 ];

    if ( $source =~ /Agregate\s*\(\s*(\S+)\s*\)/i ) {
      $source1 = $1;
      printf STDERR "%-20s     %6d    %9d bp\n", $heading . ":",
          $stats{'agregates'}->{$source1}->{'count'},
          $stats{'agregates'}->{$source1}->{'length'};
      $subTotCnt += $stats{'agregates'}->{$source1}->{'count'};
      $subTotLen += $stats{'agregates'}->{$source1}->{'length'};
    }
    elsif ( $source1 ne "" && $source2 eq "" ) {
      printf STDERR "%-20s     %6d    %9d bp\n", $heading . ":",
          $stats{'classes'}->{$source1}->{'count'},
          $stats{'classes'}->{$source1}->{'length'};
      $subTotCnt += $stats{'classes'}->{$source1}->{'count'};
      $subTotLen += $stats{'classes'}->{$source1}->{'length'};
    }
    else {
      printf STDERR "%-20s     %6d    %9d bp\n", $heading . ":",
          $stats{'classes'}->{$source1}->{'subclasses'}->{$source2}->{'count'},
          $stats{'classes'}->{$source1}->{'subclasses'}->{$source2}->{'length'};
      $subTotCnt +=
          $stats{'classes'}->{$source1}->{'subclasses'}->{$source2}->{'count'};
      $subTotLen +=
          $stats{'classes'}->{$source1}->{'subclasses'}->{$source2}->{'length'};
    }

    if ( $subHeadings ) {
      foreach my $subHead ( @{$subHeadings} ) {
        my $heading = $subHead->[ 0 ];
        my $type    = $subHead->[ 1 ];
        my $subtype = $subHead->[ 2 ];
        if ( $type =~ /Agregate\s*\(\s*(\S+)\s*\)/i ) {
          $type = $1;
          printf STDERR "%20s     %6d    %9d bp\n", $heading,
              $stats{'agregates'}->{$type}->{'count'},
              $stats{'agregates'}->{$type}->{'length'};

        }
        else {
          if ( $subtype eq "" ) {
            printf STDERR "%20s    %6d    %9d bp\n", $heading . ":",
                $stats{'classes'}->{$type}->{'count'},
                $stats{'classes'}->{$type}->{'length'};
          }
          else {
            printf STDERR "%20s     %6d    %9d bp\n", $heading,
                $stats{'classes'}->{$type}->{'subclasses'}->{$subtype}
                ->{'count'},
                $stats{'classes'}->{$type}->{'subclasses'}->{$subtype}
                ->{'length'};
          }
        }
      }
    }
    print STDERR "\n";
  }

  print STDERR "==================================================\n";
  print STDERR "\n";
  print STDERR "* most repeats fragmented by insertions or deletions\n";
  print STDERR "  have been counted as one element\n";
  print STDERR "$exclnote\n";
  print STDERR "\n";
  print STDERR "The query species was assumed to be "
      . $optRef->{'species'} . "\n";
  print STDERR "$versionmode\n";
  print STDERR "$engine\n";
  print STDERR "$dbversion\n";

  return ( \%stats );
}

#
#
# Given a fragment annotation "c" and a set of
# putative related fragments M.  Also given a
# set of transforms "transforms()" for c and
# members of M.
#
# for all transforms of "c" find the maximal
# scoring transform where maximal is determined
# by the transform which is compatible with the
# most elements of M.
#
# foreach transform "tc" in transforms("c")
#   foreach element "m" in M
#     foreach transform "tm" in transforms("m")
#       is "tc" + "m" + "tm" compatible?
#
#
# Things to consider:
#    - Perhaps the score should consider
#      the liklihood that two annotations
#      would be fused? i.e. minimize the
#      consensus gap distance??
#
#    - It would be parsomonious to choose
#      the set name which covers the most
#      of the given consensus.
#
#
sub joinDNATransposonFragments {
  my $chainBegHash         = shift;
  my $chainEndHash         = shift;
  my $repeatDB             = shift;
  my $currentAnnot         = shift;
  my $dnaTransposonCluster = shift;

  $DEBUG = 0;
  if ( $DEBUG ) {
    print STDERR "joinDNATransposonFragments(): Entered...\n";
    print STDERR "  Considering Element:\n    ";
    $currentAnnot->printBrief();
    print STDERR "  Neighbor Cluster:\n";
    foreach my $potAnnot ( @{$dnaTransposonCluster} ) {
      print STDERR "    ";
      $potAnnot->printBrief();
    }
    print STDERR "\n";
  }

  my ( $curHitName, $curClassName ) =
      split( /\#/, $currentAnnot->getSeq2Name() );

  my $curEquivHash = $currentAnnot->getEquivHash();
  $curEquivHash = {} if ( !defined $curEquivHash );
  my @curNames = ( $curHitName, ( sort ( keys( %{$curEquivHash} ) ) ) );

  my %nameScores   = ();
  my %nameAnnots   = ();
  my $proposedName = "";
  my $isCompatible = 0;
  my ( $adjCurBegin,       $adjCurEnd );
  my ( $adjCandidateBegin, $adjCandidateEnd );

  my $highestScore = 0;
  my $highName     = "";
  my $highCurRange;
  my $highMembers;

  #
  #  Consider all names that the current element may go by
  #  including it's current name and all aliases.
  #
  foreach my $curName ( @curNames ) {
    print STDERR "  Current Element Name: $curName\n" if ( $DEBUG );

    # Fake a range if hit name
    my @curRanges = ();
    if ( $curName eq $curHitName ) {
      push @curRanges,
          {
            'start'   => 1,
            'end'     => $chainEndHash->{ $currentAnnot->getID() },
            'eqstart' => 1,
            'eqend'   => $chainEndHash->{ $currentAnnot->getID() }
          };
    }
    if ( defined $curEquivHash->{$curName} ) {
      push @curRanges, @{ $curEquivHash->{$curName} };
    }

    my $highestRangeScore      = 0;
    my $highestScoringCurRange = undef;
    my $highestScoringMembers;
    foreach my $curNameRange ( @curRanges ) {
      print STDERR "    Current Element Range: [$curNameRange->{'start'}-"
          . "$curNameRange->{'end'}]-->[$curNameRange->{'eqstart'}-"
          . "$curNameRange->{'eqend'}]\n"
          if ( $DEBUG );
      my $curNameRangeScore  = 0;
      my @curNameRangeAnnots = ();
      ( $adjCurBegin, $adjCurEnd ) = &translateCoord(
                                                    $currentAnnot->getSeq2Beg(),
                                                    $currentAnnot->getSeq2End(),
                                                    $curNameRange
      );
      my $curNameRangeLastBegin = $adjCurBegin;
      my $curNameRangeLastEnd   = $adjCurEnd;
      foreach my $potAnnot ( @{$dnaTransposonCluster} ) {
        ## TESTING: Don't consider fragments that would be
        ##          inherited from the first one.
        next if ( $potAnnot->getLeftLinkedHit() );

        my ( $potHitName, $potClassName ) =
            split( /\#/, $potAnnot->getSeq2Name() );
        my $potEquivHash = $potAnnot->getEquivHash();
        $potEquivHash = {} if ( !defined $potEquivHash );
        my @potNames = ( $potHitName, ( sort ( keys( %{$potEquivHash} ) ) ) );
        my $adjPotStrand = $potAnnot->getRevComp();

        if ( $DEBUG ) {
          print STDERR "      Potential Element:\n        " if ( $DEBUG );
          $potAnnot->printBrief()                           if ( $DEBUG );
        }

        foreach my $potName ( @potNames ) {

          # Fake a range if hit name
          my @potRanges = ();
          if ( $potName eq $potHitName ) {
            push @potRanges,
                {
                  'start'   => 1,
                  'end'     => $chainEndHash->{ $potAnnot->getID() },
                  'eqstart' => 1,
                  'eqend'   => $chainEndHash->{ $potAnnot->getID() }
                };
          }
          if ( defined $potEquivHash->{$potName} ) {
            push @potRanges, ( @{ $potEquivHash->{$potName} } );
          }

          foreach my $potNameRange ( @potRanges ) {

            # Test comparison
            print STDERR "           Equiv Names: "
                . "$potName: ["
                . $potNameRange->{"start"} . "-"
                . $potNameRange->{"end"} . "]-->["
                . $potNameRange->{"eqstart"} . "-"
                . $potNameRange->{"eqend"} . "]\n"
                if ( $DEBUG );

            if ( $curName eq $potName ) {

              # Are the orientations correct?
              if (
                   (
                        $potNameRange->{'compl'} == $curNameRange->{'compl'}
                     && $currentAnnot->getRevComp() eq $potAnnot->getRevComp()
                   )
                   || ( $potNameRange->{'compl'} != $curNameRange->{'compl'}
                     && $currentAnnot->getRevComp() ne $potAnnot->getRevComp() )
                  )
              {

                ( $adjCandidateBegin, $adjCandidateEnd ) = &translateCoord(
                                                        $potAnnot->getSeq2Beg(),
                                                        $potAnnot->getSeq2End(),
                                                        $potNameRange
                );

                # Are the coordinates sensible?
                if ( $potAnnot->getRevComp() eq "C"
                     && defined $potNameRange->{'compl'} )
                {
                  $adjPotStrand = "+";
                }
                elsif ( $potAnnot->getRevComp() eq "+"
                        && defined $potNameRange->{'compl'} )
                {
                  $adjPotStrand = "C";
                }

                #$adjCurBegin, $adjCurEnd,
                $isCompatible = &isTransposonPairCompatible(
                       1,                           $curNameRangeLastBegin,
                       $curNameRangeLastEnd,        $adjCandidateBegin,
                       $adjCandidateEnd,            $adjPotStrand,
                       $currentAnnot->getSeq1Beg(), $currentAnnot->getSeq1End(),
                       $potAnnot->getSeq1Beg(),     $potAnnot->getSeq1End()
                );
                if ( $isCompatible ) {
                  print STDERR "            ---> isCompatible = $isCompatible\n"
                      if ( $DEBUG );
                  $curNameRangeLastBegin = $adjCandidateBegin;
                  $curNameRangeLastEnd   = $adjCandidateEnd;

                  ## TODO: Look into adding other factors into this score.
                  ##       Those would include, all things being equal take
                  ##       the higher scoring matches etc.
                  $curNameRangeScore++;
                  push @curNameRangeAnnots,
                      { 'annot' => $potAnnot, 'range' => $potNameRange };
                  ## TODO: Make this a recursive function or fuse overlapping
                  ##       elements first.  I prefer the first option.
                  last;
                }
              }    # if ( ...are orientations correct
            }    # are the names the same
          }    # foreach potNameRange
        }    # foreach potName
      }    # foreach $pot

      # Update stats:  We now know which name produced the highest element
      #                count for the current element, name, and range.
      #my $highestScoringName = (sort( keys( %curNameRangeScores )))[0];
      if ( $curNameRangeScore > $highestRangeScore ) {
        $highestRangeScore      = $curNameRangeScore;
        $highestScoringCurRange = $curNameRange;
        $highestScoringMembers  = [ @curNameRangeAnnots ];
        print STDERR "    New high score = $curNameRangeScore\n" if ( $DEBUG );
      }
    }    # foreach curNameRange

    if ( $highestRangeScore > $highestScore ) {
      print STDERR "  New high score = $highestRangeScore\n" if ( $DEBUG );
      $highestScore = $highestRangeScore;
      $highName     = $curName;
      $highCurRange = $highestScoringCurRange;
      $highMembers  = [ @{$highestScoringMembers} ];
    }
  }    # foreach curName

  print STDERR "\n  highestScore = $highestScore\n" if ( $DEBUG );

  if ( $highestScore > 0 ) {
    print STDERR "  highCurrentName/Range = $highName: ["
        . $highCurRange->{"start"} . "-"
        . $highCurRange->{"end"} . "]-->["
        . $highCurRange->{"eqstart"} . "-"
        . $highCurRange->{"eqend"} . "]\n"
        if ( $DEBUG );

    &translateAnnotation( $currentAnnot, $highCurRange, $highName, $repeatDB );

    if ( $currentAnnot->getRightLinkedHit()
         && !$currentAnnot->getLeftLinkedHit() )
    {
      my $tmpAnnot = $currentAnnot;
      while ( $tmpAnnot->getRightLinkedHit() ) {
        $tmpAnnot = $tmpAnnot->getRightLinkedHit();
        &translateAnnotation( $tmpAnnot, $highCurRange, $highName, $repeatDB );
      }
    }

    # Correct the coordinates & orientation of the member elements
    my $lastAnnot     = $currentAnnot;
    my $lastBegin     = $adjCurBegin;
    my $lastEnd       = $adjCurEnd;
    my $lastSeq1Begin = $currentAnnot->getSeq1Beg();
    my $lastSeq1End   = $currentAnnot->getSeq1End();

    my %memberSeen = ();
    foreach my $member ( @{$highMembers} ) 
    {
      print "Considering member:\n" if ( $DEBUG );
      $member->{'annot'}->print() if ( $DEBUG );
      my ( $memberHitName, $memberClassName ) =
          split( /\#/, $member->{'annot'}->getSeq2Name() );
      my ( $adjMemberBegin, $adjMemberEnd ) = &translateCoord(
                                               $member->{'annot'}->getSeq2Beg(),
                                               $member->{'annot'}->getSeq2End(),
                                               $member->{'range'}
      );

      # First check to see if this needs to be fused
      if (    $adjMemberBegin <= $lastEnd
           && $adjMemberEnd >= $lastBegin
           && $member->{'annot'}->getSeq1Beg() <= $lastSeq1Begin
           && $member->{'annot'}->getSeq1End() >= $lastSeq1End )
      {

        # Modify the last one
        # Add bases to either the end or begining of the consensus position
        #print STDERR "lastRange = $lastBegin  - $lastEnd\n";
        $lastAnnot->set3PrimeUnaligned(
              $lastAnnot->get3PrimeUnaligned() - ( $lastEnd - $adjMemberEnd ) );
        $lastAnnot->setSeq2End( $adjMemberEnd );

        # Remove ourselves
        $member->{'annot'}->setStatus( "DELETED" );

        # Adjust other things like score, div stats etc
        if ( $member->{'annot'}->getSW() > $lastAnnot->getSW() ) {
          $lastAnnot->setSW( $member->{'annot'}->getSW() );
        }
        if ( $member->{'annot'}->getPctSubst() < $lastAnnot->getPctSubst() ) {
          my $totalLastLength =
              $lastAnnot->getSeq1End() - $lastAnnot->getSeq2Beg();
          my $lastRemainder = $totalLastLength - getOverlapSize(
                                               $member->{'annot'}->getSeq1Beg(),
                                               $member->{'annot'}->getSeq1End(),
                                               $lastAnnot->getSeq1Beg(),
                                               $lastAnnot->getSeq1End()
          );

          $lastAnnot->setPctSubst(
             $member->{'annot'}->getPctSubst() + (
               $lastAnnot->getPctSubst() * ( $lastRemainder / $totalLastLength )
             )
          );
          $lastAnnot->setPctDelete(
            $member->{'annot'}->getPctDelete() + (
              $lastAnnot->getPctDelete() * ( $lastRemainder / $totalLastLength )
            )
          );
          $lastAnnot->setPctInsert(
            $member->{'annot'}->getPctInsert() + (
              $lastAnnot->getPctInsert() * ( $lastRemainder / $totalLastLength )
            )
          );

        }
        else {
          my $totalLastLength =
              $member->{'annot'}->getSeq1End() -
              $member->{'annot'}->getSeq2Beg();
          my $lastRemainder = $totalLastLength - getOverlapSize(
                                               $lastAnnot->getSeq1Beg(),
                                               $lastAnnot->getSeq1End(),
                                               $member->{'annot'}->getSeq1Beg(),
                                               $member->{'annot'}->getSeq1End()
          );

          $member->{'annot'}->setPctSubst(
                                     $lastAnnot->getPctSubst() + (
                                       $member->{'annot'}->getPctSubst() *
                                           ( $lastRemainder / $totalLastLength )
                                     )
          );
          $member->{'annot'}->setPctDelete(
                                     $lastAnnot->getPctDelete() + (
                                       $member->{'annot'}->getPctDelete() *
                                           ( $lastRemainder / $totalLastLength )
                                     )
          );
          $member->{'annot'}->setPctInsert(
                                     $lastAnnot->getPctInsert() + (
                                       $member->{'annot'}->getPctInsert() *
                                           ( $lastRemainder / $totalLastLength )
                                     )
          );

        }

        # Adjust seq1positions
      }
      else {

        &translateAnnotation( $member->{'annot'}, $member->{'range'}, $highName,
                              $repeatDB );

        if ( $member->{'annot'}->getRightLinkedHit()
             && !$member->{'annot'}->getLeftLinkedHit() )
        {
          my $tmpAnnot = $member->{'annot'};
          while ( $tmpAnnot->getRightLinkedHit() ) {
            $tmpAnnot = $tmpAnnot->getRightLinkedHit();
            &translateAnnotation( $tmpAnnot, $member->{'range'},
                                  $highName, $repeatDB );
          }
        }

        if ( $DEBUG ) {
          print STDERR "   Doing the join of\n" if ( $DEBUG );
          $lastAnnot->print();
          $member->{'annot'}->print();
        }

        $lastAnnot->join( $member->{'annot'} );
        $lastAnnot     = $member->{'annot'};
        $lastEnd       = $adjMemberEnd;
        $lastBegin     = $adjMemberBegin;
        $lastSeq1Begin = $member->{'annot'}->getSeq1Beg();
        $lastSeq1End   = $member->{'annot'}->getSeq1End();
      }    # is fusable else
    } # end foreach 

    if ( $DEBUG ) {
      print STDERR "  New current element:\n    ";
      $currentAnnot->printBrief();
      print STDERR "  New member elements:\n";
      foreach my $member ( @{$highMembers} ) {
        print STDERR "     " . $member->{'annot'}->getStatus() . ":";
        $member->{'annot'}->printBrief();
      }
    }
  }
  print STDERR "joinDNATransposonFragments(): Exiting...\n\n" if ( $DEBUG );
}

sub translateAnnotation {
  my $annot      = shift;
  my $transRange = shift;
  my $transName  = shift;
  my $repeatDB   = shift;

  # Correct the coordinates & orientation of the current element first
  my ( $curHitName, $curClassName ) =
      split( /\#/, $annot->getSeq2Name() );
  my ( $adjCurBegin, $adjCurEnd ) =
      &translateCoord( $annot->getSeq2Beg(), $annot->getSeq2End(),
                       $transRange );

  # Modify end coordinates and left unaligned if necessary.
  if (    $adjCurEnd == $annot->getSeq2End()
       && $curHitName eq $transName )
  {

    # Nothing to do...coordinates didn't change.
  }
  elsif ( defined $repeatDB->{ lc( $transName ) }->{'conlength'} ) {
    $annot->setSeq2End( $adjCurEnd );
    $annot->set3PrimeUnaligned(
        $repeatDB->{ lc( $transName ) }->{'conlength'} - $annot->getSeq2End() );
  }
  else {
    die "Cannot find the consensus length for element $transName!\n"
        . "consensus unaligned length will be incorrect in the\n"
        . "annotation.\n";
  }

  $annot->setSeq2Name( "$transName#$curClassName" );
  $annot->setSeq2Beg( $adjCurBegin );
  $annot->setStatus( "JOINED" );
  if ( $annot->getRevComp() eq "C"
       && defined $transRange->{'compl'} )
  {
    $annot->setRevComp( "+" );
  }
  elsif ( $annot->getRevComp() eq "+"
          && defined $transRange->{'compl'} )
  {
    $annot->setRevComp( "C" );
  }
}    # sub translateAnnotation

##sorting subroutines
# Cycle 0B
sub bySeqSWConbegin ($$) {
  ( $_[ 0 ]->getSeq1Name() ) cmp( $_[ 1 ]->getSeq1Name() )
      || ( $_[ 0 ]->getSW() ) <=>      ( $_[ 1 ]->getSW() )
      || ( $_[ 0 ]->getSeq2Beg() ) <=> ( $_[ 1 ]->getSeq2Beg() );
}

# Lots of places
sub byNameBeginEndrevSWrev ($$) {
  ( $_[ 0 ]->getSeq1Name() ) cmp( $_[ 1 ]->getSeq1Name() )
      || ( $_[ 0 ]->getSeq1Beg() ) <=> ( $_[ 1 ]->getSeq1Beg() )
      || ( $_[ 1 ]->getSeq1End() ) <=> ( $_[ 0 ]->getSeq1End() )
      || ( $_[ 1 ]->getSW() ) <=>      ( $_[ 0 ]->getSW() );
  ### note: takes the longer sequence starting at the same position first
}

# Cycle 0Da
sub byNameClassBeginEndrevAndSWrev ($$) {
  my ( $aSeqName, $aClassName ) = $_[ 0 ]->getSeq2Name() =~ /(.*)#(.*)/;
  my ( $bSeqName, $bClassName ) = $_[ 1 ]->getSeq2Name() =~ /(.*)#(.*)/;
  ( $_[ 0 ]->getSeq1Name() ) cmp( $_[ 1 ]->getSeq1Name() )
      || ( $aClassName ) cmp( $bClassName )
      || ( $_[ 0 ]->getSeq1Beg() ) <=> ( $_[ 1 ]->getSeq1Beg() )
      || ( $_[ 1 ]->getSeq1End() ) <=> ( $_[ 0 ]->getSeq1End() )
      || ( $_[ 1 ]->getSW() ) <=> ( $_[ 0 ]->getSW() );
}

# Line Preprocessing notes:
#
#
#  TODO: Eventually this routine should keep track of the adjustments
#        independent of the original annotation.  That way we can
#        track the evidence for each final annotation.
#
#  Marsupials are adjusted to L1_Mdo1
#  To be done: HAL1_Opos1_3end is not so close to normal LINE1s,
#              but probably still warrants to be lined up with L1.
#  opt_mammals and L1* are adjusted to L1_Canid
#  in future all mammalian LINEs need to have one startpoint, e.g. L1M2_ORF2
#  We change L1_Cf so that it can be recognized in fragment comparisons
#    with L1_Canis subs. Similarly for L1_Canid.
#
# LINE subfamilies have widely variable length 5' ends. To be able to
# merge closely related LINE subfamilies, the positions need to be
# adjusted to a standard. The ORF2 is basically of identical length
# between all known subfamilies, so the start of ORF2 is probably the
# best place to match the positions of the 5' end consensus
# sequences. I've taken L1PA2 as a standard for L1, where ORF2 starts
# at 2110. Many 5' end consensus sequences extend to overlap 150 bp
# with the ORF2, but many others only describe sequences further 5' in
# the element, usually because another subfamily has a very closely
# matching sequence over ORF1.
# The "left over in the consensus sequence" number (now reflecting
# how far the consensus extends 3') is adjusted to reflect what
# would be left in a full element (add 3294 for ORF2 + length best
# matching 3' end consensus - 2x 150 bp for overlaps)
# The first number fed to ChangePos is subtracted from the given
# position. Thus, a consensus that is longer than the standard
# gets a positive number, one that is shorter a negative number.
# When making adjustments dependent on position in consensus with the
# subroutine ChangePos begin-limit of doing so should be >= or <
# end-limit when the position number is decreased or increased, resp.
# L1PA4 ORF2 start 2110; L1 ORF2 length 3294 bp
#
#
# L1P4b-e are adjusted to L1P4a
# L1MEf_5end -- 3'end not yet known; used same as L1MDa
# L1MEg_5end -- 3' end not yet known; used same as L1MDa
# L3b, L3_Mars -- Are adjust to the ancient L3 consensus, even
#   if this consensus is incomplete. If this consensus is
#   updated, these adjustments need to be changed
sub preProcessLINE {
  my $chainBegHash   = shift;
  my $chainEndHash   = shift;
  my $conPosCorrHash = shift;
  my $annot          = shift;

  my $DEBUG = 0;
  if ( $DEBUG ) {
    print STDERR "preProcessLINE(): Before preprocessing\n";
    $annot->print();
  }

  my $HitName = $annot->getHitName();
  my $ID      = $annot->getID();

  if ( defined $RepeatAnnotationData::preProcData{$HitName} ) {
    my $adjChainBeg = 0;
    my $adjChainEnd = 0;

    # Adjust consensus positions
    if (
      defined $RepeatAnnotationData::preProcData{$HitName}->{'relToReference'} )
    {
      $annot->setSeq2Beg( $annot->getSeq2Beg() +
             $RepeatAnnotationData::preProcData{$HitName}->{'relToReference'} );
      $annot->setSeq2End( $annot->getSeq2End() +
             $RepeatAnnotationData::preProcData{$HitName}->{'relToReference'} );
      $adjChainBeg =
          $chainBegHash->{$ID} +
          $RepeatAnnotationData::preProcData{$HitName}->{'relToReference'};
      $adjChainEnd =
          $chainEndHash->{$ID} +
          $RepeatAnnotationData::preProcData{$HitName}->{'relToReference'};

      # I.e _5ends and full length elements?
      # TODO: Make this a function is3End isOrf etc..
      unless ( $HitName =~ /_3end|_orf2/ ) {
        $conPosCorrHash->{$ID} =
            -$RepeatAnnotationData::preProcData{$HitName}->{'relToReference'};
      }
    }

    # Adjust LeftUnaligned
    if ( defined $RepeatAnnotationData::preProcData{$HitName}->{'3EndLength'} )
    {
      $annot->set3PrimeUnaligned( $annot->get3PrimeUnaligned() +
                 $RepeatAnnotationData::preProcData{$HitName}->{'3EndLength'} );
    }

    # Rename based on adjusted consensus coordinates
    if ( defined $RepeatAnnotationData::preProcData{$HitName}->{'rangeNames'} )
    {
      foreach my $range (
             @{ $RepeatAnnotationData::preProcData{$HitName}->{'rangeNames'} } )
      {
        my $newHitName = $annot->getHitName();

        # range has maxEnd
        if ( defined $range->{'maxEnd'} && $DEBUG ) {
          print STDERR "Considering maxEnd= "
              . $range->{'maxEnd'}
              . " and hitname = "
              . $range->{'name'}
              . " and adjchainend=$adjChainEnd\n";
        }
        if ( defined $range->{'maxEnd'}
             && $adjChainEnd <= $range->{'maxEnd'} )
        {
          $newHitName = $range->{'name'};
        }

        #
        if ( defined $range->{'maxArianEndScore'}
             && ( $adjChainEnd + $annot->getSW() ) <=
             $range->{'maxArianEndScore'} )
        {
          $newHitName = $range->{'name'};
        }

        #
        if ( defined $range->{'minBeg'}
             && $adjChainBeg >= $range->{'minBeg'} )
        {
          $newHitName = $range->{'name'};
        }

        #
        if ( defined $range->{'relLeftUnaligned'}
             && $HitName ne $newHitName )
        {
          $annot->set3PrimeUnaligned(
                  $annot->get3PrimeUnaligned() + $range->{'relLeftUnaligned'} );
        }

        #
        $annot->setHitName( $newHitName );
      }
    }
  }
  if ( $DEBUG ) {
    print STDERR "After preprocessing\n";
    $annot->print();
  }
}

sub preProcessDNATransp {
  my $chainBegHash = shift;
  my $chainEndHash = shift;
  my $annot        = shift;
  my $repeatDB     = shift;

  if ( defined $repeatDB->{ lc( $annot->getHitName() ) } ) {
    my $dbRec = $repeatDB->{ lc( $annot->getHitName() ) };
    $DEBUG = 0;
    if ( defined $dbRec->{'equiv'} ) {
      my $rangeSlack = 6;
      my %compHash   = ();
      foreach my $equivRec ( @{ $dbRec->{'equiv'} } ) {

        # Sorted in start order
        foreach my $rangeRec ( @{ $equivRec->{'ranges'} } ) {

          # No need to check ranges which start after we end
          last if ( $chainEndHash->{ $annot->getID() } < $rangeRec->{'start'} );

          # Are we contained in this range? Leave some range slack
          # for search run through.
          if ( $chainBegHash->{ $annot->getID() } >=
                  $rangeRec->{'start'} - $rangeSlack
               && $chainEndHash->{ $annot->getID() } <=
               $rangeRec->{'end'} + $rangeSlack )
          {

            # Contained by a non-unique range
            # Not uniq to this consensus...push comparable
            push @{ $compHash{ $equivRec->{'name'} } }, $rangeRec;
          }
        }
      }
      if ( keys %compHash ) {
        if ( $DEBUG ) {
          print STDERR "\n\n***NOT UNIQUE***\n";
          $annot->print();
          print STDERR "Comps:\n";
          foreach my $key ( keys( %compHash ) ) {
            print STDERR "$key: " . Dumper( $compHash{$key} ) . "\n";
          }
        }
        $annot->setEquivHash( {%compHash} );
      }
      $DEBUG = 0;
    }
  }
}

# Temporarily adjusts consensus sequence position info to allow
# merging of matches to different subfamilies. The position is usually
# later readjusted based on the "conPosCorrection" hash.  Note that positive
# numbers fed to the subroutine are subtracted (longer subfamilies are
# adjusted with higher numbers, shorter with negatives)
sub ChangePos {
  my $chainBegHash   = shift;
  my $chainEndHash   = shift;
  my $conPosCorrHash = shift;
  my $annot          = shift;

  my $ID = $annot->getID();
  $conPosCorrHash->{$ID} = shift;
  $annot->setSeq2Beg( $annot->getSeq2Beg() - $conPosCorrHash->{$ID} );
  $chainBegHash->{$ID} -= $conPosCorrHash->{$ID};
  $annot->setSeq2End( $annot->getSeq2End() - $conPosCorrHash->{$ID} );
  $chainEndHash->{$ID} -= $conPosCorrHash->{$ID};
  $annot->set3PrimeUnaligned( $annot->get3PrimeUnaligned() + $_[ 0 ] )
      if $_[ 0 ];
}

#
# Returns overlap size for a range.
#
# TODO: Replace this with getQueryOverlap in object
#
sub getOverlapSize {
  my $range1Begin = shift;
  my $range1End   = shift;
  my $range2Begin = shift;
  my $range2End   = shift;

  my $overlap = 0;
  if (    $range1Begin >= $range2Begin
       && $range1Begin <= $range2End )
  {

    #      -------
    #   ------
    # or
    #     -----
    #   --------
    if ( $range1End <= $range2End ) {

      #     -----
      #   --------
      $overlap = $range1End - $range1Begin + 1;
    }
    else {

      #      -------
      #   ------
      $overlap = $range2End - $range1Begin + 1;
    }
  }
  elsif (    $range1End >= $range2Begin
          && $range1End <= $range2End )
  {

    #   -------
    #      ------
    # or
    #   --------
    #    -----
    if ( $range1End >= $range2End ) {

      #   --------
      #    -----
      $overlap = $range2End - $range2Begin + 1;
    }
    else {

      #   -------
      #      ------
      $overlap = $range1End - $range2Begin + 1;
    }
  }
  return $overlap;
}

sub isTransposonPairCompatible {
  my $cycle          = shift;
  my $adjCurBegin    = shift;
  my $adjCurEnd      = shift;
  my $adjNextBegin   = shift;
  my $adjNextEnd     = shift;
  my $curStrand      = shift;
  my $curBeginAlign  = shift;
  my $curEndAlign    = shift;
  my $nextBeginAlign = shift;
  my $nextEndAlign   = shift;

  my $DEBUG = 0;
  if ( $DEBUG ) {
    print STDERR " adjCurBegEndStrand=$adjCurBegin $adjCurEnd  $curStrand\n";
    print STDERR " adjNextBegEnd=$adjNextBegin $adjNextEnd\n";
  }

  my $conGap;
  if ( $curStrand ne "C" ) {

    #   ---current--->  (gap)   ---next--->
    $conGap = $adjNextBegin - $adjCurEnd;
  }
  else {

    #   <--current---  (gap)   <--next---
    $conGap = $adjCurBegin - $adjNextEnd;
  }

  my $seqGap;
  if ( $curBeginAlign > $nextEndAlign ) {

    #   ---next---  (gap)   ---current---
    $seqGap = $curBeginAlign - $nextEndAlign - 1;
  }
  else {

    #   ---current---  (gap)   ---next---
    $seqGap = $nextBeginAlign - $curEndAlign - 1;
  }

  ## TODO:  Do not attach pieces to complete consensi
  print STDERR "conGap = $conGap, seqGap = $seqGap: "
      . "Is conGap > -75 && ( conGap < 500 )\n"
      if ( $DEBUG );
  if ( $conGap > -75 || $seqGap < 500 ) {

    return ( 1 );
  }
  return ( 0 );
}

##
##
##
sub translateCoord {
  my $unBegin   = shift;
  my $unEnd     = shift;
  my $transHash = shift;

  ## Correction for run-through ranges
  $unBegin = $transHash->{'start'} if ( $unBegin < $transHash->{'start'} );
  $unEnd   = $transHash->{'end'}   if ( $unEnd > $transHash->{'end'} );

  my $rangeLen   = $transHash->{'end'} - $transHash->{'start'} + 1;
  my $eqRangeLen = $transHash->{'eqend'} - $transHash->{'eqstart'} + 1;
  my $conBegin = sprintf(
                          "%0.d",
                          (
                            (
                              ( $unBegin - $transHash->{'start'} ) * $eqRangeLen
                            ) / $rangeLen
                              ) + $transHash->{'eqstart'}
  );
  my $conEnd = sprintf(
                        "%0.d",
                        (
                          ( ( $unEnd - $transHash->{'start'} ) * $eqRangeLen ) /
                              $rangeLen
                            ) + $transHash->{'eqstart'}
  );

  return ( $conBegin, $conEnd );
}

#
# isTooDiverged():
#
# Return true of past element substitution percentage is 2x as
# high *and* greater than 10% higher than the current elements
# substitution percentage.
#
# A true value indicates that the past element is neither likely to
# be related to the current element nor is it likely that a
# fragment of the younger current element lies beyond the past element.
#
sub isTooDiverged {
  my $currentElementPctSub = shift;
  my $pastElementPctSub    = shift;
  $pastElementPctSub > 2 * $currentElementPctSub
      && $pastElementPctSub > $currentElementPctSub + 10;
}

sub printHitArrayList {
  my $sortedAnnotationsList = shift;

  my $cycleAnnotIter = $sortedAnnotationsList->getIterator();
  my %newID          = ();
  my $ind            = 1;
  while ( $cycleAnnotIter->hasNext() ) {
    my $currentAnnot = $cycleAnnotIter->next();
    if (    $currentAnnot->getLeftLinkedHit()
         && $newID{ $currentAnnot->getLeftLinkedHit()->getUniqID() } > 0 )
    {
      $newID{ $currentAnnot->getUniqID() } =
          $newID{ $currentAnnot->getLeftLinkedHit()->getUniqID() };
    }
    else {
      $newID{ $currentAnnot->getUniqID() } = $ind++;
    }
  }

  $cycleAnnotIter = $sortedAnnotationsList->getIterator();
  print STDERR "RESULTS OF JOINS\n";
  while ( $cycleAnnotIter->hasNext() ) {
    my $currentAnnot = $cycleAnnotIter->next();
    $currentAnnot->print( 1 );
    print STDERR "" . $newID{ $currentAnnot->getUniqID() } . "\n";
  }
  print STDERR "END RESULTS OF JOINS\n";

}

#####################################################################
################ C O N T A I N S   M E T A   D A T A ################
#################           metadata                 ################
#####################################################################

sub preProcessSINE {
  my $chainBegHash = shift;
  my $chainEndHash = shift;
  my $annot        = shift;

  my $HitName       = $annot->getHitName();
  my $Seq2Begin     = $annot->getSeq2Beg();
  my $Seq2End       = $annot->getSeq2End();
  my $LeftUnaligned = $annot->get3PrimeUnaligned();
  my $ID            = $annot->getID();

  if (
          $annot->getClassName() eq "SINE/Alu"
       && $HitName !~ /B1/
       && (    $chainEndHash->{$ID} < 176
            || $chainBegHash->{$ID} > 64 )
      )
  {

    #
    # Low scoring small fragments and highly diverged
    # ( for an alu ) AluY* elements are simply called Alu now
    #
    if (    $chainEndHash->{$ID} - $chainBegHash->{$ID} < 50
         && $annot->getSW() < 250
         || $HitName =~ /AluY\w+/ && $annot->getPctSubst() >= 10 )
    {
      $HitName = "Alu";
    }

    $LeftUnaligned += 169 if $HitName =~ /FLAM/;    # adjust to AluJ

    if ( $chainEndHash->{$ID} < 153 ) {
      $HitName = "AluR_5" if $HitName =~ /AluS[xq]/;
      $HitName =~ s/(AluY[a-z]?)\d/$1/;
      if ( $HitName eq "7SLRNA" && $chainEndHash->{$ID} < 80 ) {
        $HitName = "FLAM_A";
        $LeftUnaligned -= 19;    # rest subtracted before printing
      }
      if ( $HitName =~ /FLAM_C|AluJo/ && $chainEndHash->{$ID} < 134 ) {
        $HitName = "AluH_5";
        if ( $HitName =~ /FLAM_A|AluH_5/ && $chainBegHash->{$ID} > 37 ) {
          $HitName = "AluG_5";
        }
      }
      if ( $chainEndHash->{$ID} < 125 && $HitName =~ /Alu/ ) {
        $HitName = "AluZ1_5" if $HitName =~ /AluYa/;
        if ( $chainEndHash->{$ID} < 103 ) {
          $HitName = "AluI_5" if $HitName =~ /AluJb|Alu[GH]_5/;
          $HitName = "AluQ_5" if $HitName =~ /AluSp|AluR/;
          $HitName = "AluY"
              if $HitName =~ /AluYd/
              && $chainEndHash->{$ID} < 88;
          $HitName = "AluZ2_5" if $HitName =~ /Alu[YZ][^d]/;
          if ( $chainEndHash->{$ID} < 79 ) {
            $HitName = "AluX_5" if $HitName =~ /AluS[cg]|AluZ/;
            if ( $chainEndHash->{$ID} < 64 ) {
              $HitName = "AluV_5" if $HitName =~ /Alu[QX]/;
              $HitName = "Alu_5" if $chainEndHash->{$ID} < 57;
            }
          }
        }
      }
    }
    if ( $HitName =~ /F[R]?AM/ ) {    # adjust to AluJ
      $Seq2Begin           += 136;
      $chainBegHash->{$ID} += 136;
      $Seq2End             += 136;
      $chainEndHash->{$ID} += 136;
    }
    if ( $HitName eq "7SLRNA" && $chainBegHash->{$ID} > 238 ) {
      $HitName = "FAM";
      $Seq2Begin           -= 5;
      $chainBegHash->{$ID} -= 5;
      $Seq2End             -= 5;
      $chainEndHash->{$ID} -= 5;
    }
    elsif ( $chainBegHash->{$ID} > 64 ) {
      $HitName = "AluO_3" if $HitName =~ /AluS[xg]/;
      if ( $chainBegHash->{$ID} > 127 ) {
        $HitName = "AluH_3" if $HitName =~ /FRAM|AluJo/;
        if ( $chainEndHash->{$ID} < 227 ) {
          $HitName = "AluG_3" if $HitName =~ /FAM|AluH_3/;
          if ( $chainEndHash->{$ID} < 213 ) {
            $HitName = "AluF_3" if $HitName =~ /AluJb|AluG_3/;
          }
        }
        if ( $chainBegHash->{$ID} > 153 ) {
          $HitName = "AluP_3" if $HitName =~ /AluS[pq]/;
          if ( $chainBegHash->{$ID} > 165 ) {
            $HitName = "AluZ_3" if $HitName =~ /AluYa/;
            if ( $chainBegHash->{$ID} > 213 ) {
              $HitName = "AluI_3" if $HitName =~ /AluJb|AluH_3/;
              if ( $chainBegHash->{$ID} > 219 ) {
                $HitName = "AluT_3" if $HitName =~ /AluY$|AluO/;
                if ( $chainBegHash->{$ID} > 233 ) {
                  $HitName = "AluN_3" if $HitName =~ /Alu[ITZ]/;
                  if ( $chainBegHash->{$ID} > 246 ) {
                    if (
                         $HitName =~ /AluN|AluYb/
                         || (    $HitName eq "AluSc"
                              && $chainBegHash->{$ID} > 255 )
                         || (    $HitName eq "AluP_3"
                              && $chainBegHash->{$ID} > 263 )
                        )
                    {
                      $HitName = "Alu_3";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }    # if SINE/ALU
       # Make MIR's generic if they are not in the
       # unique regions.  NOTE: Unique regions are
       # a good possibility for generalization.
  elsif ( $HitName eq 'MIR3' ) {
    if (    $chainBegHash->{$ID} >= 16
         && $chainEndHash->{$ID} <= 153 )
    {
      $HitName = 'MIR';
    }
  }

  $annot->setHitName( $HitName );
  $annot->setSeq2Beg( $Seq2Begin );
  $annot->setSeq2End( $Seq2End );
  $annot->set3PrimeUnaligned( $LeftUnaligned );

## FOR CREATING EQUIV HASH LATER
#  if (    ( $HitName eq "Alu" && $lastorpast =~ /Alu\w/ )
#       || ( $HitName eq "AluR_5" && $lastorpast =~ /AluS[xq]/ )
#       || ( $HitName =~ /Alu[GH]_5/ && $lastorpast =~ /AluJo|FLAM/ )
#       || ( $HitName eq "AluZ1_5" && $lastorpast =~ /AluYa[58]/ )
#       || ( $HitName eq "AluI_5"  && $lastorpast =~ /AluJ/ )
#       || ( $HitName eq "AluQ_5"  && $lastorpast =~ /AluS[xqp]/ )
#       || ( $HitName eq "AluZ2_5" && $lastorpast =~ /AluY/ )
#       || ( $HitName eq "AluX_5"  && $lastorpast =~ /AluS[cg]|AluY/ )
#       || ( $HitName eq "AluV_5"  && $lastorpast =~ /Alu[SY]/ )
#       || ( $HitName eq "Alu_5"   && $lastorpast =~ /Alu[JSY]|FLAM/ ) )
#  {
#    $primary->setHitName( $lastorpast );
#  }
#  elsif ( $HitName =~ /Alu[QR]_5/ ) {
#    $primary->setHitName( "AluSx" ) if $lastorpast eq "AluO_3";
#    $primary->setHitName( "AluSq" ) if $lastorpast eq "AluP_3";
#  }
#  elsif ( $HitName =~ /Alu[GH]_5/ ) {
#    $primary->setHitName( "AluJo" ) if $lastorpast =~ /Alu[GH]_3/;
#    $primary->setHitName( "AluJ" ) if $lastorpast eq "AluF_3";
#  }
#  elsif ( $HitName eq "AluX_5" ) {
#    $primary->setHitName( "AluSg" ) if $lastorpast eq "AluO_3";
#  }
#  elsif ( $HitName eq "AluG_5" ) {
#    $primary->setHitName( "AluJo/FLAM" ) if $lastorpast =~ /Alu[HI]_5/;
#  }
#  elsif (    ( $HitName eq "AluO_3" && $lastorpast =~ /AluS[xg]/ )
#          || ( $HitName eq "AluH_3" && $lastorpast =~ /AluJo|FRAM/ )
#          || ( $HitName eq "AluG_3" && $lastorpast =~ /AluJo|FR?AM/ )
#          || ( $HitName eq "AluF_3" && $lastorpast =~ /AluJ|FR?AM/ )
#          || ( $HitName eq "AluP_3" && $lastorpast =~ /AluS[pq]/ )
#          || ( $HitName eq "AluZ_3" && $lastorpast =~ /AluYa/ )
#          || ( $HitName eq "AluI_3" && $lastorpast =~ /AluJ|FR?AM/ )
#          || ( $HitName eq "AluT_3" && $lastorpast =~ /AluY$|AluS[xg]/ )
#          || ( $HitName eq "AluN_3" && $lastorpast =~ /Alu[JSY][abgox]?|FR?AM/ )
#          || ( $HitName eq "Alu_3"  && $lastorpast =~ /Alu[JSY]|FR?AM/ ) )
#  {
#    $primary->setHitName( $lastorpast );
#  }
#  elsif ( $HitName eq "AluO_3" ) {
#    $primary->setHitName( "AluSx" ) if $lastorpast =~ /Alu[RQ]_5/;
#    $primary->setHitName( "AluSg" ) if $lastorpast eq "AluX_5";
#  }
#  elsif ( $HitName =~ /Alu[FGH]_3/ ) {
#    $primary->setHitName( "AluJo" ) if $lastorpast =~ /Alu[GH]_5/;
#  }
#  elsif ( $HitName eq "AluP_3" ) {
#    $primary->setHitName( "AluSq" )   if $lastorpast eq "AluR_5";
#    $primary->setHitName( "AluSg/q" ) if $lastorpast eq "AluSg";
#  }
#  if (    ( $lastorpast =~ /AluJb?$/ && $HitName =~ /Alu[GH]_[35]|AluJo/ )
#       || ( $lastorpast =~ /Alu[GH]_[35]|AluJo?$/ && $HitName eq "AluJb" ) )
#  {
#    $primary->setHitName( "AluJ" );
#  }

}

sub preProcessLTR {
  my $chainBegHash   = shift;
  my $chainEndHash   = shift;
  my $conPosCorrHash = shift;
  my $annot          = shift;

  my $ID      = $annot->getID();
  my $HitName = $annot->getHitName();

  # all MLT2s adjusted to MLT2B3 or 4
  if ( $chainBegHash->{$ID} > 180 ) {
    if ( $HitName =~ /^MLT2A/ ) {
      &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot, -108 )
          if $chainBegHash->{$ID} > 270;
    }
    elsif ( $HitName =~ /^MLT2B[12]$/ ) {
      &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot, -47 )
          if $chainBegHash->{$ID} > 265;
    }
    elsif ( $HitName eq "MLT2B5" ) {
      if ( $chainBegHash->{$ID} > 415 ) {
        &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot,
                    162 );
      }
      else {
        &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot,
                    116 );
      }
    }
    elsif ( $HitName eq "MLT2C1" ) {
      &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot, -166 )
          if $chainBegHash->{$ID} > 220;
    }
    elsif ( $HitName eq "MLT2C2" ) {
      &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot, -95 )
          if $chainBegHash->{$ID} > 275;
    }
    elsif ( $HitName eq "MLT2D" ) {
      &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot, -146 )
          if $chainBegHash->{$ID} > 225;
    }
    elsif ( $HitName eq "MLT2E" ) {
      &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot, 65 )
          if $chainBegHash->{$ID} > 520;
    }
    elsif ( $HitName eq "MLT2F" ) {
      &ChangePos( $chainBegHash, $chainEndHash, $conPosCorrHash, $annot, 100 )
          if $chainBegHash->{$ID} > 550;
    }
  }
}

# Used in cycle9
sub adjustSINEName {
  my $prevAnnot = shift;
  my $annot     = shift;
  my $nextAnnot = shift;
  my $repeatDB  = shift;
  my $optRef    = shift;

  my $DEBUG = 0;

  if ( $DEBUG ) {
    print STDERR "adjustSINEName(): Called with:\n";
    $prevAnnot->print() if ( $prevAnnot );
    if ( $annot ) {
      print STDERR "---> ";
      $annot->print();
    }
    $nextAnnot->print() if ( $nextAnnot );
  }

  my $HitName   = $annot->getHitName();
  my $ClassName = $annot->getClassName();
  my $RevComp   = $annot->getRevComp();

  if ( $ClassName eq "SINE/Alu" && !$optRef->{'mus'} ) {
    if ( $annot->getHitName =~ /Alu.*_[35]/ ) {
      if ( $annot->getHitName =~ /Alu[GH]_5/ ) {
        if (
             $RevComp eq '+'
             && (
                     !defined $nextAnnot
                  || $annot->getSeq1Name() ne $nextAnnot->getSeq1Name()
                  || (    $nextAnnot->getSeq1Beg() - $annot->getSeq1End() < 5
                       && $nextAnnot->getSeq2Name() =~ /SINE\/Alu/ )
             )
            )
        {
          $annot->setHitName( "AluJo/FLAM" );
        }
        elsif (
                $RevComp eq 'C'
                && (
                        !defined $prevAnnot
                     || $annot->getSeq1Name() ne $prevAnnot->getSeq1Name()
                     || (    $annot->getSeq1Beg() - $prevAnnot->getSeq1End() < 5
                          && $prevAnnot->getClassName() eq "SINE/Alu" )
                )
            )
        {
          $annot->setHitName( "AluJo/FLAM" );
        }
        else {
          $annot->setHitName( "FLAM" )   if ( $annot->getHitName eq "AluG_5" );
          $annot->setHitName( "FLAM_C" ) if ( $annot->getHitName eq "AluH_5" );
        }
      }
      elsif ( $annot->getHitName eq "AluO_3" ) {
        $annot->setHitName( "AluSg/x" );
      }
      elsif ( $annot->getHitName eq "AluR_5" ) {
        $annot->setHitName( "AluSq/x" );
      }
      elsif ( $annot->getHitName =~ /Alu[FGH]_3/ ) {
        if (
             $RevComp eq "C"
             && (
                     !defined $nextAnnot
                  || $annot->getSeq1Name() ne $nextAnnot->getSeq1Name()
                  || (    $nextAnnot->getSeq1Beg() - $annot->getSeq1End() < 5
                       && $nextAnnot->getSeq2Name() =~ /SINE\/Alu/ )
             )
             || $RevComp eq '+'
             && (
                     !defined $prevAnnot
                  || $annot->getSeq1Name() ne $prevAnnot->getSeq1Name()
                  || (    $annot->getSeq1Beg() - $prevAnnot->getSeq1End() < 5
                       && $prevAnnot->getClassName() eq "SINE/Alu" )
             )
            )
        {
          $annot->setHitName( "AluJo/FRAM" )
              if ( $annot->getHitName eq "AluH_3" );
          $annot->setHitName( "AluJo/F(R)AM" )
              if ( $annot->getHitName eq "AluG_3" );
          $annot->setHitName( "AluJ/F(R)AM" )
              if ( $annot->getHitName eq "AluF_3" );
        }
        else {
          $annot->setHitName( "FRAM" ) if ( $annot->getHitName eq "AluH_3" );
          $annot->setHitName( "FRAM/FAM" )
              if ( $annot->getHitName =~ /Alu[FG]_3/ );
        }
      }
      elsif ( $annot->getHitName eq "AluQ_5" ) {
        $annot->setHitName( "AluS" );
      }
      elsif ( $annot->getHitName eq "AluP_3" ) {
        $annot->setHitName( "AluSp/q" );
      }
      elsif ( $annot->getHitName eq "AluI_5" ) {
        $annot->setHitName( "AluJ/FLAM" );
      }
      elsif ( $annot->getHitName eq "AluI_3" ) {
        $annot->setHitName( "AluJ/FRAM" );
      }
      elsif ( $annot->getHitName =~ /Alu[VX]_5|AluT_3/ ) {
        if ( $annot->getPctSubst() > 11 ) {
          $annot->setHitName( "AluS" );    # generic AluS
        }
        elsif ( $annot->getPctSubst() < 5 ) {
          $annot->setHitName( "AluY" );    # rare AluYa5/8 and AluYb8 ignored
        }
        else {
          $annot->setHitName( "Alu" );
        }
      }
      elsif ( $annot->getHitName =~ /AluZ1_5|AluZ_3/ ) {
        $annot->setHitName( "AluYa5/8" );
      }
      elsif ( $annot->getHitName eq "AluZ2_5" ) {
        $annot->setHitName( "AluY" );      #rare AluYa5/8 and AluYb8 ignored
      }
      elsif ( $annot->getHitName =~ /AluN?_[35]/ ) {
        if ( $annot->getPctSubst() > 20 ) {
          $annot->setHitName( "AluJ/monomer" );
        }
        elsif ( $annot->getPctSubst() < 5 ) {
          $annot->setHitName( "AluY" );
        }
        else {
          $annot->setHitName( "Alu" );
        }
      }
      if ( $annot->getHitName =~ /AluY[ab]/ && $annot->getPctSubst() >= 6 ) {
        $annot->setHitName( "Alu" );
      }
    }
    if ( $annot->getHitName =~ /^F[LR]?AM/ ) {
      $annot->set3PrimeUnaligned( $annot->get3PrimeUnaligned() - 169 )
          if ( $annot->getHitName =~ /^FLAM/ );
      $annot->setSeq2Beg( $annot->getSeq2Beg() - 136 )
          if ( $annot->getHitName =~ /F[R]?AM/ );
      $annot->setSeq2Beg( 1 )
          if ( $annot->getSeq2Beg() < 1 );
      $annot->setSeq2End( $annot->getSeq2End() - 136 )
          if ( $annot->getHitName =~ /F[R]?AM/ );
    }
  }

  $annot->set3PrimeUnaligned( 0 ) if ( $annot->get3PrimeUnaligned() < 0 );

  # can be caused by minor errors in adjustments
  # negative leftunaligned throw lines out somehow

  if ( $DEBUG ) {
    print STDERR "Final Call:\n";
    $annot->print();
  }
}

# Used in CYCLE4
sub ChangeAluNames {
  my $primary = shift;
  my $partner = shift;

  my $DEBUG = 0;

  my $lastorpast = $partner->getHitName();
  my $HitName    = $primary->getHitName();
  if (    ( $HitName eq "Alu" && $lastorpast =~ /Alu\w/ )
       || ( $HitName eq "AluR_5" && $lastorpast =~ /AluS[xq]/ )
       || ( $HitName =~ /Alu[GH]_5/ && $lastorpast =~ /AluJo|FLAM/ )
       || ( $HitName eq "AluZ1_5" && $lastorpast =~ /AluYa[58]/ )
       || ( $HitName eq "AluI_5"  && $lastorpast =~ /AluJ/ )
       || ( $HitName eq "AluQ_5"  && $lastorpast =~ /AluS[xqp]/ )
       || ( $HitName eq "AluZ2_5" && $lastorpast =~ /AluY/ )
       || ( $HitName eq "AluX_5"  && $lastorpast =~ /AluS[cg]|AluY/ )
       || ( $HitName eq "AluV_5"  && $lastorpast =~ /Alu[SY]/ )
       || ( $HitName eq "Alu_5"   && $lastorpast =~ /Alu[JSY]|FLAM/ ) )
  {
    $primary->setHitName( $lastorpast );
  }
  elsif ( $HitName =~ /Alu[QR]_5/ ) {
    $primary->setHitName( "AluSx" ) if $lastorpast eq "AluO_3";
    $primary->setHitName( "AluSq" ) if $lastorpast eq "AluP_3";
  }
  elsif ( $HitName =~ /Alu[GH]_5/ ) {
    $primary->setHitName( "AluJo" ) if $lastorpast =~ /Alu[GH]_3/;
    $primary->setHitName( "AluJ" ) if $lastorpast eq "AluF_3";
  }
  elsif ( $HitName eq "AluX_5" ) {
    $primary->setHitName( "AluSg" ) if $lastorpast eq "AluO_3";
  }
  elsif ( $HitName eq "AluG_5" ) {
    $primary->setHitName( "AluJo/FLAM" ) if $lastorpast =~ /Alu[HI]_5/;
  }
  elsif (    ( $HitName eq "AluO_3" && $lastorpast =~ /AluS[xg]/ )
          || ( $HitName eq "AluH_3" && $lastorpast =~ /AluJo|FRAM/ )
          || ( $HitName eq "AluG_3" && $lastorpast =~ /AluJo|FR?AM/ )
          || ( $HitName eq "AluF_3" && $lastorpast =~ /AluJ|FR?AM/ )
          || ( $HitName eq "AluP_3" && $lastorpast =~ /AluS[pq]/ )
          || ( $HitName eq "AluZ_3" && $lastorpast =~ /AluYa/ )
          || ( $HitName eq "AluI_3" && $lastorpast =~ /AluJ|FR?AM/ )
          || ( $HitName eq "AluT_3" && $lastorpast =~ /AluY$|AluS[xg]/ )
          || ( $HitName eq "AluN_3" && $lastorpast =~ /Alu[JSY][abgox]?|FR?AM/ )
          || ( $HitName eq "Alu_3"  && $lastorpast =~ /Alu[JSY]|FR?AM/ ) )
  {
    $primary->setHitName( $lastorpast );
  }
  elsif ( $HitName eq "AluO_3" ) {
    $primary->setHitName( "AluSx" ) if $lastorpast =~ /Alu[RQ]_5/;
    $primary->setHitName( "AluSg" ) if $lastorpast eq "AluX_5";
  }
  elsif ( $HitName =~ /Alu[FGH]_3/ ) {
    $primary->setHitName( "AluJo" ) if $lastorpast =~ /Alu[GH]_5/;
  }
  elsif ( $HitName eq "AluP_3" ) {
    $primary->setHitName( "AluSq" )   if $lastorpast eq "AluR_5";
    $primary->setHitName( "AluSg/q" ) if $lastorpast eq "AluSg";
  }
  if (    ( $lastorpast =~ /AluJb?$/ && $HitName =~ /Alu[GH]_[35]|AluJo/ )
       || ( $lastorpast =~ /Alu[GH]_[35]|AluJo?$/ && $HitName eq "AluJb" ) )
  {
    $primary->setHitName( "AluJ" );
  }

}

sub scoreGenericPair {
  my $annot1               = shift;
  my $annot2               = shift;
  my $elementDistance      = shift;
  my $classElementDistance = shift;

  # Establish position order
  my $DEBUG      = 0;
  my $leftAnnot  = $annot1;
  my $rightAnnot = $annot2;
  if ( $annot1->comparePositionOrder( $annot2 ) > 0 ) {
    $leftAnnot  = $annot2;
    $rightAnnot = $annot1;
  }

  my $score          = 0;
  my $currentHitName = $rightAnnot->getHitName();
  my $prevHitName    = $leftAnnot->getHitName();
  if (    $leftAnnot->getSeq1Name() eq $rightAnnot->getSeq1Name()
       && $rightAnnot->getRevComp() eq $leftAnnot->getRevComp() )
  {
    print STDERR "   --- Same orient/seq\n" if ( $DEBUG );
    print STDERR "   --- qo = "
        . $rightAnnot->getQueryOverlap( $leftAnnot )
        . "\n       co = "
        . $rightAnnot->getConsensusOverlap( $leftAnnot ) . "\n"
        if ( $DEBUG );
    if (
         $rightAnnot->getLastField == $leftAnnot->getLastField()
         && (    $currentHitName eq $prevHitName
              || $currentHitName =~ /$prevHitName/
              || $prevHitName    =~ /$currentHitName/ )
         && -( $rightAnnot->getQueryOverlap( $leftAnnot ) ) <= 10
         && -( $rightAnnot->getConsensusOverlap( $leftAnnot ) ) <= 100
         && ( $rightAnnot->getConsensusOverlap( $leftAnnot ) <= 21
              || -( $rightAnnot->getQueryOverlap( $leftAnnot ) ) < 0
              && $rightAnnot->getConsensusOverlap( $leftAnnot ) -
              $rightAnnot->getQueryOverlap( $leftAnnot ) <= 20 )
        )
    {
      $score = 1;
    }
    my $HitName      = $rightAnnot->getHitName();
    my $shortHitName = $HitName;
    $shortHitName =~ s/(\S+\d)[a-zA-Z]$/$1/;
    $shortHitName = quotemeta $shortHitName;

    # Less stringent
    if ( $score == 0 && $leftAnnot->getHitName() =~ /^$shortHitName/ ) {
      print STDERR "scoreGenericPair():  last chancy test ( names compat )\n"
          if ( $DEBUG );
      my $gapMax = 2500;
      $gapMax *= 1.5
          if ( $leftAnnot->getHitName() eq $rightAnnot->getHitName() );

      # Need to revise the way div diff is calc'd
      my $divDiff = $leftAnnot->getPctSubst() - $rightAnnot->getPctSubst();
      print STDERR "scoreGenericPair(): gapMax = $gapMax "
          . "divDiff = $divDiff elemedist = $elementDistance\n"
          if ( $DEBUG );
      $divDiff = -$divDiff if ( $divDiff < 0 );
      $gapMax *= ( 10 - $divDiff ) / 10;
      $gapMax *= ( 15 - $elementDistance ) / 15;
      print STDERR "scoreGenericPair(): gapMax = $gapMax "
          . "divDiff = $divDiff\n"
          if ( $DEBUG );
      if (    $leftAnnot->getConsensusOverlap( $rightAnnot ) < 33
           && $leftAnnot->getConsensusOverlap( $rightAnnot ) > -$gapMax )
      {
        print STDERR "scoreGenericPair():   Hmmm....I guess so.. " . "\n"
            if ( $DEBUG );
        $score = 0.5;
      }
    }
  }
  return ( $score );
}

sub scoreSINEPair {
  my $annot1          = shift;
  my $annot2          = shift;
  my $elementDistance = shift;

  # Establish position order
  my $DEBUG      = 0;
  my $leftAnnot  = $annot1;
  my $rightAnnot = $annot2;
  if ( $annot1->comparePositionOrder( $annot2 ) > 0 ) {
    $leftAnnot  = $annot2;
    $rightAnnot = $annot1;
  }

  my $score          = 0;
  my $currentHitName = $rightAnnot->getHitName();
  my $prevHitName    = $leftAnnot->getHitName();
  if (    $leftAnnot->getSeq1Name() eq $rightAnnot->getSeq1Name()
       && $rightAnnot->getRevComp() eq $leftAnnot->getRevComp() )
  {
    print STDERR "   --- Same orient/seq\n" if ( $DEBUG );
    print STDERR "   --- qo = "
        . $rightAnnot->getQueryOverlap( $leftAnnot )
        . "\n       co = "
        . $rightAnnot->getConsensusOverlap( $leftAnnot ) . "\n"
        if ( $DEBUG );
    if (
      $rightAnnot->getLastField == $leftAnnot->getLastField()
      && (    $currentHitName eq $prevHitName
           || $currentHitName =~ /$prevHitName/
           || $prevHitName    =~ /$currentHitName/ )
      ## TODO: Change these to QueryGap etc.
      && -( $rightAnnot->getQueryOverlap( $leftAnnot ) ) <= 10
      && -( $rightAnnot->getConsensusOverlap( $leftAnnot ) ) <= 100
      && ( $rightAnnot->getConsensusOverlap( $leftAnnot ) <= 21
           || -( $rightAnnot->getQueryOverlap( $leftAnnot ) ) < 0
           && $rightAnnot->getConsensusOverlap( $leftAnnot ) -
           $rightAnnot->getQueryOverlap( $leftAnnot ) <= 20 )
        )
    {
      print STDERR "    --- good score  ( 1 )\n" if ( $DEBUG );
      $score = 1;
    }
    my $HitName      = $rightAnnot->getHitName();
    my $shortHitName = $HitName;
    if ( $HitName =~ /^Alu/ ) {
      $shortHitName =~ s/(^\w{5}).*/$1/;
    }
    else {
      $shortHitName =~ s/(\S+\d)[a-zA-Z]$/$1/;
    }
    $shortHitName = quotemeta $shortHitName;

    # Less stringent
    if ( $score == 0 && $leftAnnot->getHitName() =~ /^$shortHitName/ ) {
      print STDERR "scoreSINEPair():  last chancy test ( names compat )\n"
          if ( $DEBUG );
      my $gapMax = 2500;
      $gapMax *= 1.5
          if ( $leftAnnot->getHitName() eq $rightAnnot->getHitName() );

      # Need to revise the way div diff is calc'd
      my $divDiff = $leftAnnot->getPctSubst() - $rightAnnot->getPctSubst();
      print STDERR "scoreSINEPair(): gapMax = $gapMax "
          . "divDiff = $divDiff elemedist = $elementDistance\n"
          if ( $DEBUG );
      $divDiff = -$divDiff if ( $divDiff < 0 );
      $gapMax *= ( 10 - $divDiff ) / 10;
      $gapMax *= ( 15 - $elementDistance ) / 15;
      print STDERR "scoreSINEPair(): gapMax = $gapMax " . "divDiff = $divDiff\n"
          if ( $DEBUG );
      if (    $leftAnnot->getConsensusOverlap( $rightAnnot ) < 33
           && $leftAnnot->getConsensusOverlap( $rightAnnot ) > -$gapMax )
      {
        print STDERR "scoreSINEPair():   Hmmm....I guess so.. " . "\n"
            if ( $DEBUG );
        $score = 0.5;
      }
    }
  }
  return ( $score );
}

sub scoreLTRPair {
  my $annot1      = shift;
  my $annot2      = shift;
  my $eleDistance = shift;
  my $ltrDistance = shift;

  my $DEBUG = 0;
  if ( $DEBUG ) {
    print STDERR "scoreLTRPair(): Considering...\n";
    $annot1->print();
    $annot2->print();
  }

  # Establish position order
  my $leftAnnot  = $annot1;
  my $rightAnnot = $annot2;
  if ( $annot1->comparePositionOrder( $annot2 ) > 0 ) {
    $leftAnnot  = $annot2;
    $rightAnnot = $annot1;
  }

  my $intScore = 0;
  my $hybrid   = 0;

  # Ensure compatible names and orientation agreement
  if (    &areLTRNamesCompat( $annot1, $annot2 )
       && $annot1->getRevComp() eq $annot2->getRevComp() )
  {
    print STDERR "scoreLTRPair():  Names are compatable\n" if ( $DEBUG );

    #
    # Model component specific checks
    #
    if ( &isInternal( $annot1 ) && &isInternal( $annot2 ) ) {
      print STDERR "scoreLTRPair():   Both internals\n" if ( $DEBUG );

      # Both internal
      #    Names are compatable loosely compatable.
      my $CO = $leftAnnot->getConsensusOverlap( $rightAnnot );
      my $CG = -$CO;

      if (    $CO <= 111 && $CG <= 1234
           || $leftAnnot->getHitName() eq $rightAnnot->getHitName()
           && $CO <= 111
           && $CG <= 5555 )
      {
        print STDERR "scoreLTRPair():   INT Good One\n" if ( $DEBUG );
        $intScore = 1;
      }
      else {
        print STDERR "scoreLTRPair():   Failed: CO=$CO>111, "
            . "CG=$CG>1234 etc..\n"
            if ( $DEBUG );
      }

    }
    elsif ( &isLTR( $annot1 ) && &isLTR( $annot2 ) ) {
      print STDERR "scoreLTRPair():   Both ltrs\n" if ( $DEBUG );

      # Both LTR
      #   Join if:
      #      Class is MaLR or
      #      Both are MLT2.. variations or
      #      Hitnames are shorthitname alike
      #    And
      #      LastFields = 5
      #      CG <= 220 - ( number of LTRs distant + 1 ) * 20
      #      CO <= 50
      #      Same orientation
      #    And
      #      Unaligned edges are >= 10bp long
      if (
           (
             (
                  $annot1->getClassName() =~ /MaLR/
               && $annot2->getClassName() =~ /MaLR/
             )
             || (    $annot1->getHitName() =~ /MLT2/
                  && $annot2->getHitName() =~ /MLT2/ )
             || &areLTRNamesCompat( $annot1, $annot2 ) == 1
           )
           && ( $annot1->getLastField() == 5 && $annot2->getLastField() == 5 )
           && ( $leftAnnot->getConsensusOverlap( $rightAnnot ) >
                -( 220 - $ltrDistance * 20 ) )
           && ( $leftAnnot->getConsensusOverlap( $rightAnnot ) <= 50 )
           && ( $leftAnnot->getRevComp() eq $rightAnnot->getRevComp() )
          )
      {
        print STDERR "scoreLTRPair():      Good distance\n" if ( $DEBUG );
        if (

          # --ltr--> --ltr-->
          (
               $annot1->getRevComp() eq "+"
            && $leftAnnot->get3PrimeUnaligned() >= 10
            && $rightAnnot->getSeq2Beg() >= 10
          )

          # <--ltr-- <--ltr---
          || (    $annot2->getRevComp() eq "C"
               && $leftAnnot->getSeq2Beg() >= 10
               && $rightAnnot->get3PrimeUnaligned() >= 10 )
            )
        {
          $intScore = 1;
        }
      }
    }
    else {

      # Mixture of internal and ltr
      $hybrid = 1;
      print STDERR "scoreLTRPair():   Mixture of ltr/internal: "
          . "eleDist = $eleDistance\n"
          if ( $DEBUG );

      # Mixture of internal and ltr fragments
      # Stringent:
      #    - Names are compatable: loosely compatable.
      #    - <= 33 bp unaligned on each fragment
      #    - Same orientation
      #    - No more than 2 insertions
      #    - No more than 350 bp gap in query
      # No more than 2 insertions

      ## TODO: Should lower stringency based on the exactness of the
      ## flanking name.
      if (    $eleDistance <= 2
           && $annot1->getQueryOverlap( $annot2 ) > -350 )
      {
        print STDERR "scoreLTRPair():  eleDistance OK and queryOverlap OK\n"
            if ( $DEBUG );
        if (

          # ----> ---int--->
          # ---int--> ----->
          (
               $annot1->getRevComp() eq "+"
            && $leftAnnot->get3PrimeUnaligned() <= 33
            && $rightAnnot->getSeq2Beg() <= 33
          )

          # <---- <--int---
          # <---int-- <-----
          || (    $annot2->getRevComp() eq "C"
               && $leftAnnot->getSeq2Beg() <= 33
               && $rightAnnot->get3PrimeUnaligned() <= 33 )
            )
        {
          print STDERR "scoreLTRPair():   Good One\n" if ( $DEBUG );
          $intScore = 1;
        }
      }
    }

    # Less stringent
    # Loose applies to all combinations of elements:
    #    - No more than 10,000 bp gap in query
    #    - Same orientation
    #    - No intervening element with > 1.33 * PctSubst than
    #      the *higher-query-position* member of the pair.
    #    - Similar names: shorthitname rules
    #    - Gap < 500
    #        gapallowed = 1.5*2500
    #           if exact name
    #        diff = difference in substitution ( max 10% )
    #        gapallowed *= %difference in substition
    #    - gapallowed *= # of intervening elements ( max 10 )
    #    - Consensus overlap is < 33 and the gap < gapallowed
    if ( $intScore == 0 && &areLTRNamesCompat( $annot1, $annot2 ) == 1 ) {
      print STDERR "scoreLTRPair():  last chance test ( names compat )\n"
          if ( $DEBUG );
      my $gapMax = 2500;
      $gapMax *= 1.5 if ( $annot1->getHitName() eq $annot2->getHitName() );

      # Need to revise the way div diff is calc'd
      my $divDiff = $annot1->getPctSubst() - $annot2->getPctSubst();
      $divDiff = -$divDiff if ( $divDiff < 0 );
      $gapMax *= ( 10 - $divDiff ) / 10;
      $gapMax *= ( 10 - $eleDistance ) / 10;
      if (
           $leftAnnot->getConsensusOverlap( $rightAnnot ) > -$gapMax
           && (
                $hybrid
                || (    $leftAnnot->getConsensusOverlap( $rightAnnot ) < 33
                     && $annot1->getLastField() == 5
                     && $annot2->getLastField() == 5 )
           )
          )
      {
        print STDERR "scoreLTRPair():   Ok\n" if ( $DEBUG );
        $intScore = 0.5;
      }
      elsif ( $DEBUG ) {
        print STDERR "scoreLTRPair():   Not Ok: gapMax = $gapMax > "
            . $leftAnnot->getConsensusGap( $rightAnnot ) . "\n";
        print STDERR "scoreLTRPair():           co = "
            . $leftAnnot->getConsensusOverlap( $rightAnnot )
            . " < 33\n";
        print STDERR "scoreLTRPair():           hybrid = $hybrid or "
            . $leftAnnot->getLastField() . " == "
            . $rightAnnot->getLastField() . "\n";
      }
    }

    ## Last last chance from cycle 4
    if ( $intScore == 0 ) {
      print STDERR "scoreLTRPair():  last last chance test\n"
          if ( $DEBUG );
      if (    $leftAnnot->getSeq1End() >= $rightAnnot->getSeq1Beg()
           && $rightAnnot->getSeq1End() > $leftAnnot->getSeq1End() )
      {

        #
        # If these element shave the same class, orientation,
        # similar names with small overlap or simply just
        # a large overlap then join them!!!  Arghhh
        #
        if (    &areLTRNamesCompat( $annot1, $annot2 ) == 1
             && $rightAnnot->getSeq1Beg() <= $leftAnnot->getSeq1End() - 12
             || $rightAnnot->getSeq1Beg() <= $leftAnnot->getSeq1End() - 33 )
        {
          print STDERR "scoreLTRPair():   Well if you insist\n" if ( $DEBUG );
          $intScore = 0.25;
        }
      }
    }

  }
  elsif ( $DEBUG ) {
    print STDERR "scoreLTRPair():   Names are not compatable\n";
  }

  if ( $intScore ) {
    print STDERR "Using elementdistance = $eleDistance\n" if ( $DEBUG );
    $intScore += 1 / $eleDistance;
  }

  print STDERR "scoreLTRPair():    Returning score = $intScore\n" if ( $DEBUG );
  return $intScore;
}

sub isInternal {
  my $annot = shift;

  my $HitName = $annot->getHitName();

  if (
       ( $HitName !~ /LTR/ || $HitName =~ /int$/ )
       && (    $HitName =~ /int|ERV|PRIMA41|Harlequin|HUERS/i
            || $HitName =~ /MMERGLN|MMURS|MMVL30|MULV|MURVY|ETn|^IAP/ )
      )
  {
    return ( 1 );
  }
  return ( 0 );
}

sub isLTR {
  my $annot = shift;

  return ( !&isInternal( $annot ) );
}

sub areLTRNamesCompat {
  my $annot1 = shift;
  my $annot2 = shift;

  my $annot1Name  = $annot1->getHitName();
  my $annot1Class = $annot1->getClassName();
  my $annot2Name  = $annot2->getHitName();
  my $annot2Class = $annot2->getClassName();
  my $DEBUG       = 0;

  if ( $DEBUG ) {
    print STDERR "areLTRNamesCompat(): $annot1Name vs $annot2Name\n";
  }

  #
  # Rules when annot1Name is internal
  #
  if ( $annot1Class eq $annot2Class ) {
    my $shortHitName = $annot2Name;
    if ( $annot2Name =~ /^MER\d{2}|^LTR\d{2}/ ) {
      $shortHitName =~ s/(^\w{5}).*/$1/;
    }
    elsif ( $annot2Name =~ /^MER\d[A-Z_a-z]|^LTR\d[A-Z_a-z]|ORR1/ ) {
      $shortHitName =~ s/(^\w{4}).*/$1/;
    }
    else {
      $shortHitName =~ s/(\S+\d)[\-a-zA-Z].*/$1/;
    }
    $shortHitName = quotemeta $shortHitName;

    print STDERR "areLTRNamesCompat(): comparing $annot1Name =~ $shortHitName\n"
        if ( $DEBUG );

    if ( $annot1Name =~ /$shortHitName/ ) {
      print STDERR "areLTRNamesCompat(): returning 1\n" if ( $DEBUG );
      return ( 1 );
    }

    if (
         $annot1Class !~ /MaLR/
      && $annot2Name !~ /pTR5/

      # pTR5 is not a product of retrovrial transposition but
      # appears like a "processed pseudogene". Obviously cant
      # act like an LTR.
      # The following are all MaLR names
      || (    $annot1Name =~ /^THE1/ && $annot2Name =~ /THE1|MST[AB-]/
           || $annot1Name =~ /^MST/ && $annot2Name =~ /THE1[BC-]|MST|MLT1[AB-]/
           || $annot1Name =~ /^MLT-int/
           && $annot2Name =~ /THE1C|MST[ABCD]|MLT1[ABC]/
           || $annot1Name =~ /^MLT1[A-]/ && $annot2Name =~ /MST[CD-]|MLT1[ABC-]/
           || $annot1Name =~ /^MLT1F/ && $annot2Name =~ /MLT1[DEFGHIJKL]/
           || $annot1Name =~ /MLT1[B-H]/ && $annot2Name =~ /MLT1/
           || $annot1Name =~ /^ORR1/ && $annot2Name =~ /^ORR1|^MT/
           || $annot1Name =~ /^MT/ && $annot2Name =~ /^MT|^ORR1/ )
        )
    {
      print STDERR "areLTRNamesCompat(): returning 0.5\n" if ( $DEBUG );
      return ( 0.5 );
    }
    if (
         $annot2Class !~ /MaLR/
         || ( $annot2Name =~ /^THE1/ && $annot1Name =~ /THE1|MST[AB-]/
           || $annot2Name =~ /^MST/ && $annot1Name =~ /THE1[BC-]|MST|MLT1[AB-]/
           || $annot2Name =~ /^MLT-int/
           && $annot1Name =~ /THE1C|MST[ABCD]|MLT1[ABC]/
           || $annot2Name =~ /^MLT1[A-]/ && $annot1Name =~ /MST[CD-]|MLT1[ABC-]/
           || $annot2Name =~ /^MLT1F/ && $annot1Name =~ /MLT1[DEFGHIJKL]/
           || $annot2Name =~ /MLT1[B-H]/ && $annot1Name =~ /MLT1/
           || $annot2Name =~ /^ORR1/ && $annot1Name =~ /^ORR1|^MT/
           || $annot2Name =~ /^MT/ && $annot1Name =~ /^MT|^ORR1/ )
        )
    {
      print STDERR "areLTRNamesCompat(): returning 0.5\n" if ( $DEBUG );
      return ( 0.5 );
    }
  }

  # Not compat
  if ( $DEBUG ) {
    print STDERR "areLTRNamesCompat(): Not compatible!\n";
  }
  return ( 0 );

}

##########################################################################
##########################################################################
##########################################################################

##-------------------------------------------------------------------------##
## Use:  my ( $seq_cnt, $totalSeqLen, $nonMaskedSeqLen, $totGCLevel,
##             $totBPMasked ) =
##                    &maskSequence ( $seqDB, $annotationFile,
##                                    $outputFile );
##  Returns
##
##     $seq_cnt:          The number of sequences in the FASTA file.
##     $totalSeqLen:      The absoulte length of all sequences combined.
##     $nonMaskedSeqLen:  Length of sequence (excluding runs of >20 N's
##                         and X's) of the pre-masked sequence.
##     $totGCLevel:       The GC content of the original sequence.
##     $totBPMasked:      The total bp we masked
##
##-------------------------------------------------------------------------##
sub maskSequence {
  my $maskFormat     = shift;
  my $seqDB          = shift;
  my $annotationFile = shift;
  my $outputFile     = shift;

  print "ProcessRepeats::maskSequence()\n" if ( $DEBUG );

  my %annots = ();

  #
  # Open up a search results object
  #
  my $searchResults =
      CrossmatchSearchEngine::parseOutput( searchOutput => $annotationFile );

  #
  # Read in annotations and throw away the rest
  #
  my $prevResult;
  for ( my $i = 0 ; $i < $searchResults->size() ; $i++ ) {
    my $result = $searchResults->get( $i );
    my $start  = $result->getQueryStart();
    my $end    = $result->getQueryEnd();
    if (    defined $prevResult
         && $prevResult->getQueryName() eq $result->getQueryName()
         && $prevResult->getQueryEnd() >= $start )
    {
      next if ( $prevResult->getQueryEnd() >= $end );
      $start = $prevResult->getQueryEnd() + 1;
    }
    push @{ $annots{ $result->getQueryName() } },
        {
          'begin' => $start,
          'end'   => $end
        };
    $prevResult = $result;
  }
  undef $searchResults;

  my @seqIDs     = $seqDB->getIDs();
  my $seq_cnt    = scalar( @seqIDs );
  my $sublength  = $seqDB->getSubtLength();
  my $totGCLevel = 100 * $seqDB->getGCLength() / $sublength;
  $totGCLevel = sprintf "%4.2f", $totGCLevel;
  my $totalSeqLen     = 0;
  my $totBPMasked     = 0;
  my $nonMaskedSeqLen = 0;
  my $workseq         = "";
  open OUTFILE, ">$outputFile";

  foreach my $seqID ( @seqIDs ) {
    my $seq = $seqDB->getSequence( $seqID );
    $totalSeqLen += length $seq;
    $workseq = $seq;
    $nonMaskedSeqLen += length $workseq;

    # This was counting all N' rather than only ones in blocks of 20 or more
    #$nonMaskedSeqLen -= ( $workseq =~ tr/[N,X]{20,}// );
    while ( $workseq =~ /([X,N]{20,})/ig ) {
      $nonMaskedSeqLen -= length( $1 );
    }
    foreach my $posRec ( @{ $annots{$seqID} } ) {
      my $beginPos = $posRec->{'begin'};
      my $endPos   = $posRec->{'end'};
      my $repLen   = $endPos - $beginPos + 1;
      substr( $workseq, $beginPos - 1, $repLen ) = "0" x ( $repLen );
      if ( $maskFormat eq 'xsmall' ) {
        substr( $seq, $beginPos - 1, $repLen ) =
            lc( substr( $seq, $beginPos - 1, $repLen ) );
      }
      elsif ( $maskFormat eq 'x' ) {
        substr( $seq, $beginPos - 1, $repLen ) = "X" x ( $repLen );
      }
      else {
        substr( $seq, $beginPos - 1, $repLen ) = "N" x ( $repLen );
      }
      $totBPMasked += $repLen;
    }
    print OUTFILE ">" . $seqID;
    my $desc = $seqDB->getDescription( $seqID );
    if ( $desc ne "" ) {
      print OUTFILE " " . $desc;
    }
    print OUTFILE "\n";
    $seq =~ s/(\S{50})/$1\n/g;
    $seq .= "\n"
        unless ( $seq =~ /.*\n+$/s );
    print OUTFILE $seq;
  }
  close OUTFILE;

  return ( $seq_cnt, $totalSeqLen, $nonMaskedSeqLen, $totGCLevel,
           $totBPMasked );
}

sub parseCATFile {
  my %nameValuePairs = @_;

  # Create ourselves as a hash
  my $retObj = new ArrayList;

  croak( "parseCATFile(): Missing 'file' parameter!\n" )
      if ( !defined $nameValuePairs{'file'} );
  open( XMATCH, $nameValuePairs{'file'} )
      || die "parseCATFile(): Cannot " . "open $nameValuePairs{'file'}\n";
  my $id             = -1;
  my $matrixGCLevel  = "";
  my $matrixSubLevel = "";
  my $alignData      = "";
  my $hit            = undef;
  while ( <XMATCH> ) {

    if ( /^[^\#].+\(\d+\)/ ) {    # only occurs in parse lines
      if ( $hit && $alignData ) {
        $hit->setAlignData( $alignData );
        $alignData = "";
      }
      $hit = new Hit( $_ );
      $id += 1;
      $hit->setID( $id );
      $hit->setMatrixSubLevel( $matrixSubLevel );
      $hit->setMatrixGCLevel( $matrixGCLevel );
      $retObj->add( $hit );
    }
    elsif ( $id >= 0 ) {
      $alignData .= $_ unless ( defined $nameValuePairs{'noAlignData'} );
    }
    if ( /^Matrix =/ ) {
      /(\d\d)p(\d\d)g.matrix/;
      $matrixSubLevel = $1 if ( $1 );
      $matrixGCLevel  = $2 if ( $2 );
    }
  }
  if ( $hit && $alignData ) {
    $hit->setAlignData( $alignData );
    $alignData = "";
  }
  close XMATCH;
  return $retObj;
}

######################################################################

package Hit;

sub new {
  my $class     = shift;    # @_ = (HIT, $parseLine)
  my $parseLine = shift;

  my $this = {};
  bless $this, $class;

  # create a reference for each parsed line, the line
  # is parsed into a list of refs to hashes (LoH)
  $this->addParsedLine( $parseLine );

  return $this;
}

##-------------------------------------------------------------------------##
##
##=head2 clone()
##
##  Use: my $newObj = $obj->clone();
##
##  Clone a Hit *duplicating* all the values of the old
##  object in the new one.
##
##=cut
##
##-------------------------------------------------------------------------##
sub clone {
  my $this = shift;

  my %newHash = %{$this};
  my $newObj  = \%newHash;

  bless $newObj, ref( $this );

  return $newObj;
}

# Just these fields for now
sub setFrom {
  my $this   = shift;
  my $source = shift;

  $this->setSW( $source->getSW() );
  $this->setPctSubst( $source->getPctSubst() );
  $this->setPctDelete( $source->getPctDelete() );
  $this->setPctInsert( $source->getPctInsert() );
  $this->setSeq1Name( $source->getSeq1Name() );
  $this->setSeq1Beg( $source->getSeq1Beg() );
  $this->setSeq1End( $source->getSeq1End() );
  $this->setLeftOver( $source->getLeftOver() );
  $this->setRevComp( $source->getRevComp() );
  $this->setHitName( $source->getHitName() );
  $this->setClassName( $source->getClassName() );
  $this->setSeq2Beg( $source->getSeq2Beg() );
  $this->setSeq2End( $source->getSeq2End() );
  $this->set3PrimeUnaligned( $source->get3PrimeUnaligned() );
  $this->setLastField( $source->getLastField() );
  $this->setID( $source->getID() );
  $this->setEquivHash( $source->getEquivHash() );
  $this->setMatrixSubLevel( $source->getMatrixSubLevel() );
  $this->setMatrixGCLevel( $source->getMatrixGCLevel() );
  $this->setAlignData( $source->getAlignData() );

  # These are the fields we are ignoring currently
  #    setScore
  #    setPctMatch
  #    setSeq1Len
  #    setSeq2Len
  #    setStatus
  #    setLeftLinkedHit
  #    setRightLinkedHit

  return $this;
}

sub addParsedLine {
  my ( $this, $line ) = @_;

  #
  # parse the line passed, the returned refs will correspond to
  # the start and end of a hit, its name and orientation (rel to
  # the first sequence in crossmatch.  the next elements ([4] - [end])
  # will contain the simscore (%match) and start and ending points)
  #
  $line =~ s/^\s+//;
  my @tokens = split( /\s+/, $line );
  $this->{'SW'}   = $tokens[ 0 ];    # smith-waterman score
  $this->{'SUBS'} = $tokens[ 1 ];    # % substitution (bidirectional)

  # Flipped insertions and deletions to reflect nature and that seq2
  # is the consensus/ancestor in RepeatMasker. Otherwise tricky to
  # understand logic elsewhere in script.
  $this->{'DEL'}           = $tokens[ 2 ];    # % deletions    seq1 vs seq2
  $this->{'INS'}           = $tokens[ 3 ];    # % insertions          ""
  $this->{'SEQ1NAME'}      = $tokens[ 4 ];    # name of seq1
  $this->{'SEQ1BEG'}       = $tokens[ 5 ];    # beginning of alignment
  $this->{'SEQ1END'}       = $tokens[ 6 ];    # end of alignment
  $this->{'SEQ1REMAINING'} = $tokens[ 7 ];

  $this->{'MATCH'} = 100 - $this->{'SUBS'};

  if ( $tokens[ 8 ] eq "C" ) {                # the C for complemented seqs
    $this->{'SEQ2NAME'}      = $tokens[ 9 ];     # name of seq2
    $this->{'REVCOMP'}       = "C";              # to be added it to the array
    $this->{'SEQ2REMAINING'} = $tokens[ 10 ];    # 3' unaligned portion
    $this->{'SEQ2END'}       = $tokens[ 11 ];    # end of seq2 alignment
    $this->{'SEQ2BEG'}       = $tokens[ 12 ];    # beginning of seq2 alignment
    if ( defined $tokens[ 13 ] ) {
      if ( $tokens[ 13 ] eq '*' ) {
        if ( defined $tokens[ 14 ] ) {
          $this->{'LASTFIELD'} = $tokens[ 14 ];
          $this->{'LINEID'}    = $tokens[ 15 ];
        }
        else {
          $this->{'LASTFIELD'} = 1;              # -nocut option
        }
      }
      else {
        $this->{'LASTFIELD'} = $tokens[ 13 ];
        $this->{'LINEID'}    = $tokens[ 14 ];
      }
    }
    else {
      $this->{'LASTFIELD'} = 1;                  # -nocut option
    }
  }
  elsif ( $tokens[ 8 ] eq '+' ) {                # for cycles 1-4
    $this->{'SEQ2NAME'}      = $tokens[ 9 ];
    $this->{'REVCOMP'}       = '+';
    $this->{'SEQ2BEG'}       = $tokens[ 10 ];
    $this->{'SEQ2END'}       = $tokens[ 11 ];    #
    $this->{'SEQ2REMAINING'} = $tokens[ 12 ];
    if ( $tokens[ 13 ] eq '*' ) {
      $this->{'LASTFIELD'} = $tokens[ 14 ];
      $this->{'LINEID'}    = $tokens[ 15 ];
    }
    else {
      $this->{'LASTFIELD'} = $tokens[ 13 ];
      $this->{'LINEID'}    = $tokens[ 14 ];
    }
  }
  else {                                         # cross_match output
    $this->{'REVCOMP'}       = '+';
    $this->{'SEQ2NAME'}      = $tokens[ 8 ];
    $this->{'SEQ2BEG'}       = $tokens[ 9 ];
    $this->{'SEQ2END'}       = $tokens[ 10 ];
    $this->{'SEQ2REMAINING'} = $tokens[ 11 ];
    if ( defined $tokens[ 12 ] ) {
      if ( $tokens[ 12 ] eq '*' ) {
        if ( defined $tokens[ 13 ] ) {
          $this->{'LASTFIELD'} = $tokens[ 13 ];
        }
        else {
          $this->{'LASTFIELD'} = 1;
        }
      }
      else {
        $this->{'LASTFIELD'} = $tokens[ 12 ];
      }
    }
    else {
      $this->{'LASTFIELD'} = 1;
    }
  }

  # we will return an array with the beginning and end positions
  # of the hit, its name, and its orientation

  $this->{'SEQ1REMAINING'} =~ tr/[()]//d;    # remove flanking "()"
  $this->{'SEQ2REMAINING'} =~ tr/[()]//d;    # remove flanking "()"

  $this->setClassName( "Unknown" )
      unless ( $this->getClassName() );

}

# the following methods are used to get the data

sub getMatrixSubLevel {
  my $this = shift;
  return $this->{'MATRIXSUB'};
}

sub setMatrixSubLevel {
  my $this = shift;
  $this->{'MATRIXSUB'} = shift;
}

sub getMatrixGCLevel {
  my $this = shift;
  return $this->{'MATRIXGC'};
}

sub setMatrixGCLevel {
  my $this = shift;
  $this->{'MATRIXGC'} = shift;
}

# smith-waterman score
sub getSW {
  my $this = shift;
  return $this->{'SW'};
}

sub setSW {
  my $this = shift;
  $this->{'SW'} = shift;
}

sub getAlignData {
  my $this = shift;
  return $this->{'ALIGNDATA'};
}

sub setAlignData {
  my $this = shift;
  $this->{'ALIGNDATA'} = shift;
}

sub getScore {
  my $this = shift;
  return $this->{'SW'};
}

sub setScore {
  my $this = shift;
  $this->{'SW'} = shift;
}

# % substitution (seq1 vs seq2)
sub getPctSubst {
  my $this = shift;
  return $this->{'SUBS'};
}

sub setPctSubst {
  my $this = shift;
  $this->{'SUBS'} = shift;
}

# leftover sequence of query
sub getLeftOver {
  my $this = shift;
  return $this->{'SEQ1REMAINING'};
}

sub setLeftOver {
  my $this = shift;
  $this->{'SEQ1REMAINING'} = shift;
}

# percent match
sub getPctMatch {
  my $this = shift;
  return $this->{'MATCH'};
}

sub setPctMatch {
  my $this = shift;
  $this->{'MATCH'} = shift;
}

## Flipped insertions and deletions to reflect RepeatMasker standard:
## deletions and insertions should be with respect to the consensus
## (ancestral) sequences (seq2 in RepeatMasker)

# % deletions
sub getPctDelete {
  my $this = shift;
  return $this->{'DEL'};
}

sub setPctDelete {
  my $this = shift;
  $this->{'DEL'} = shift;
}

# % insertions
sub getPctInsert {
  my $this = shift;
  return $this->{'INS'};
}

sub setPctInsert {
  my $this = shift;
  $this->{'INS'} = shift;
}

# name of sequence 1
sub getSeq1Name {
  my $this = shift;
  return $this->{'SEQ1NAME'};
}

sub setSeq1Name {
  my $this = shift;
  $this->{'SEQ1NAME'} = shift;
}

# beginning of alignment
sub getSeq1Beg {
  my $this = shift;
  return $this->{'SEQ1BEG'};
}

sub setSeq1Beg {
  my $this = shift;
  $this->{'SEQ1BEG'} = shift;
}

# end of alignment
sub getSeq1End {
  my $this = shift;
  return $this->{'SEQ1END'};
}

sub setSeq1End {
  my $this = shift;
  $this->{'SEQ1END'} = shift;
}

#len of seq1
sub getSeq1Len {
  my $this = shift;
  return $this->{'SEQ1LEN'};
}

sub setSeq1Len {
  my $this = shift;
  $this->{'SEQ1LEN'} = shift;
}

# name of hit (tokens[9])
sub getSeq2Name {
  my $this = shift;
  return $this->{'SEQ2NAME'};
}

sub setSeq2Name {
  my $this = shift;
  $this->{'SEQ2NAME'} = shift;
}

# returns the orientation of the hit
sub getRevComp {
  my $this = shift;
  return $this->{'REVCOMP'};
}

sub setRevComp {
  my $this = shift;
  $this->{'REVCOMP'} = shift;
}

# returns beginning of seq 2 alignment
sub getSeq2Beg {
  my $this = shift;
  return $this->{'SEQ2BEG'};
}

sub setSeq2Beg {
  my $this = shift;
  $this->{'SEQ2BEG'} = shift;
}

# returns end of seq 2 alignment
sub getSeq2End {
  my $this = shift;
  return $this->{'SEQ2END'};
}

sub setSeq2End {
  my $this = shift;
  $this->{'SEQ2END'} = shift;
}

# returns length of 3' unaligned portion
sub get3PrimeUnaligned {
  my $this = shift;
  return $this->{'SEQ2REMAINING'};
}

sub set3PrimeUnaligned {
  my $this = shift;
  $this->{'SEQ2REMAINING'} = shift;
}

# returns the length of Seq2
sub getSeq2Len {
  my $this = shift;

  #if ( ! defined $this->{'SEQ2LEN'} || $this->{'SEQ2LEN'} !~ /[\d-\.]+/ )
  #{
  $this->{'SEQ2LEN'} =
      $this->{'SEQ2END'} + $this->{'SEQ2REMAINING'};    # for "dotplots"
                                                        #}
  return $this->{'SEQ2LEN'};
}

# NOTE: THIS ISN'T USED....
sub setSeq2Len {
  my $this = shift;
  $this->{'SEQ2LEN'} = shift;
}

# returns the length of Seq2
sub getEquivHash {
  my $this = shift;
  return $this->{'EQUIVHASH'};
}

sub setEquivHash {
  my $this = shift;
  $this->{'EQUIVHASH'} = shift;
}

#returns level of condensation of DNA
sub getLastField {
  my $this = shift;
  return $this->{'LASTFIELD'};
}

sub setLastField {
  my $this = shift;
  $this->{'LASTFIELD'} = shift;
}

#returns line ID number
sub getID {
  my $this = shift;
  return $this->{'LINEID'};
}

sub setID {
  my $this = shift;
  $this->{'LINEID'} = shift;
}

#returns status ( currently only used for DNA transposon analysis )
sub getStatus {
  my $this = shift;
  return $this->{'STATUS'};
}

sub setStatus {
  my $this = shift;
  $this->{'STATUS'} = shift;
}

#returns element ( if set ) who is linked to our left edge ( Seq1Begin )
sub getLeftLinkedHit {
  my $this = shift;
  return $this->{'LEFTHIT'};
}

sub setLeftLinkedHit {
  my $this = shift;
  $this->{'LEFTHIT'} = shift;
}

#returns element ( if set ) who is linked to our right edge ( Seq1End )
sub getRightLinkedHit {
  my $this = shift;
  return $this->{'RIGHTHIT'};
}

sub setRightLinkedHit {
  my $this = shift;
  $this->{'RIGHTHIT'} = shift;
}

sub getClassName {
  my $this = shift;
  my ( $hitName, $className ) =
      split( /\#/, $this->{'SEQ2NAME'} );
  return $className;
}

sub setClassName {
  my $this         = shift;
  my $newClassName = shift;
  my ( $hitName, $className ) =
      split( /\#/, $this->{'SEQ2NAME'} );
  $this->{'SEQ2NAME'} = $hitName . "#" . $newClassName;
}

sub getHitName {
  my $this = shift;
  my ( $hitName, $className ) =
      split( /\#/, $this->{'SEQ2NAME'} );
  return $hitName;
}

sub setHitName {
  my $this       = shift;
  my $newHitName = shift;
  my ( $hitName, $className ) =
      split( /\#/, $this->{'SEQ2NAME'} );
  $this->{'SEQ2NAME'} = $newHitName . "#" . $className;
}

sub getUniqID {
  my $this = shift;
  return (   $this->{'SW'}
           . $this->{'SUBS'}
           . $this->{'DEL'}
           . $this->{'INS'}
           . $this->{'SEQ1NAME'}
           . $this->{'SEQ1BEG'}
           . $this->{'SEQ1END'}
           . $this->{'SEQ1REMAINING'}
           . $this->{'REVCOMP'}
           . $this->{'SEQ2NAME'}
           . $this->{'SEQ2BEG'}
           . $this->{'SEQ2END'}
           . $this->{'SEQ2REMAINING'} );
}

sub getDerivedFromAnnot {
  my $this = shift;
  return ( $this->{'DERIVEDFROM'} );
}

sub addDerivedFromAnnot {
  my $this   = shift;
  my $member = shift;

  #print STDERR "Pushing DERIVED\n";
  my $annot = new Hit;
  $annot->setFrom( $member );
  push @{ $this->{'DERIVEDFROM'} }, $annot;
}

sub print {
  my $this       = shift;
  my $noLineTerm = shift;
  my $lineTerm   = "\n" if ( !defined $noLineTerm );
  my $outStr = sprintf(
                      "%4d %3.1f %3.1f %3.1f %-18.18s %8d %8d "
                          . "%8d %1s %-18.18s %8d %8d %8d %3d %3d %6s$lineTerm",
                      $this->{'SW'},            $this->{'SUBS'},
                      $this->{'DEL'},           $this->{'INS'},
                      $this->{'SEQ1NAME'},      $this->{'SEQ1BEG'},
                      $this->{'SEQ1END'},       $this->{'SEQ1REMAINING'},
                      $this->{'REVCOMP'},       $this->{'SEQ2NAME'},
                      $this->{'SEQ2BEG'},       $this->{'SEQ2END'},
                      $this->{'SEQ2REMAINING'}, $this->{'LASTFIELD'},
                      $this->{'LINEID'},        $this->{'STATUS'}
  );
  print STDERR $outStr;
}

sub printBrief {
  my $this = shift;
  my $outStr = sprintf(
                        "%4d %-18.18s %8d %8d " . "%1s %-18.18s %8d %8d\n",
                        $this->{'SW'},      $this->{'SEQ1NAME'},
                        $this->{'SEQ1BEG'}, $this->{'SEQ1END'},
                        $this->{'REVCOMP'}, $this->{'SEQ2NAME'},
                        $this->{'SEQ2BEG'}, $this->{'SEQ2END'}
  );
  print STDERR $outStr;
}

sub printLeftRightLinks {
  my $this = shift;
  if ( $this->getLeftLinkedHit() != undef ) {
    print STDERR "    ";
    $this->getLeftLinkedHit()->printBrief();
  }
  else {
    print STDERR "    UNDEF\n";
  }
  print STDERR " -->";
  $this->printBrief();
  if ( $this->getRightLinkedHit() != undef ) {
    print STDERR "    ";
    $this->getRightLinkedHit()->printBrief();
  }
  else {
    print STDERR "    UNDEF\n";
  }
}

sub sanityCheckConsPos {
  my $this    = shift;
  my $hashRef = shift;

  # Find begining
  print STDERR "Sanity Checking:\n";
  my $firstInChain = $this;
  my $detectLoop   = 0;
  while (    $firstInChain->getLeftLinkedHit() != undef
          && $detectLoop < 50 )
  {
    $firstInChain = $firstInChain->getLeftLinkedHit();
    $detectLoop++;
  }

  if ( $detectLoop >= 50 ) {
    print STDERR "WARNING! This chain contains a loop!!!!\n";
  }

  # Now print
  my $nextInChain = $firstInChain;
  do {
    if ( $nextInChain == $this ) {
      print STDERR "--> (";
    }
    else {
      print STDERR "    (";
    }
    print STDERR "" . $hashRef->{ $nextInChain->getID() } . "): ";
    $nextInChain->printBrief();
    $nextInChain = $nextInChain->getRightLinkedHit();
      } while ( $nextInChain )

}

#
# Print an element and ( if exists ) all of it chain members in order
#
sub printLinks {
  my $this = shift;

  # Find begining
  my $firstInChain = $this;
  my $detectLoop   = 0;
  while (    $firstInChain->getLeftLinkedHit() != undef
          && $detectLoop < 50 )
  {
    $firstInChain = $firstInChain->getLeftLinkedHit();
    $detectLoop++;
  }

  if ( $detectLoop >= 50 ) {
    print STDERR "WARNING! This chain contains a loop!!!!\n";
  }

  # Now print
  my $nextInChain = $firstInChain;
  do {
    if ( $nextInChain == $this ) {
      print STDERR "--> ";
    }
    else {
      print STDERR "    ";
    }
    $nextInChain->printBrief();
    $nextInChain = $nextInChain->getRightLinkedHit();
      } while ( $nextInChain )

}

# Intelligently relink an element's edges prior to removal
sub removeFromJoins {
  my $this = shift;

  my $left  = $this->getLeftLinkedHit();
  my $right = $this->getRightLinkedHit();

  # Just reset these since we are being removed
  $this->setLeftLinkedHit( undef );
  $this->setRightLinkedHit( undef );

  if ( defined $left && !defined $right ) {

    # Remove left's edge reference
    $left->setRightLinkedHit( undef );
  }
  elsif ( defined $left && defined $right ) {

    # Join our neighbors together
    $left->setRightLinkedHit( $right );
    $right->setLeftLinkedHit( $left );
  }
  elsif ( !defined $left && defined $right ) {

    # Remove rights's edge reference
    $right->setLeftLinkedHit( undef );
  }
}

# Intelligently relink an elements edges for insertion
sub join {
  my $this    = shift;
  my $partner = shift;

  if ( $DEBUG ) {
    print STDERR "join this:\n";
    $this->printLinks();
    print STDERR "to partner\n";
    $partner->printLinks();
  }

  die "join(): Invalid join!  \$this == \$partner" if ( $this == $partner );

  my @cluster = ();
  foreach my $chain ( $this, $partner ) {
    push @cluster, $chain;
    my $nextInChain = $chain;
    while ( $nextInChain->getLeftLinkedHit() ) {
      $nextInChain = $nextInChain->getLeftLinkedHit();
      push @cluster, $nextInChain;
    }
    $nextInChain = $chain;
    while ( $nextInChain->getRightLinkedHit() ) {
      $nextInChain = $nextInChain->getRightLinkedHit();
      push @cluster, $nextInChain;
    }
  }

  # Sort cluster
  @cluster = sort { $a->comparePositionOrder( $b ) } ( @cluster );

  my $lastAnnot = undef;
  foreach my $annot ( @cluster ) {
    next if ( $annot == $lastAnnot );
    $annot->setLeftLinkedHit( $lastAnnot );
    $annot->setRightLinkedHit( undef );
    if ( $lastAnnot ) {
      $lastAnnot->setRightLinkedHit( $annot );
    }
    $lastAnnot = $annot;
  }

  if ( $DEBUG ) {
    print STDERR "Now look what we did with this thing:\n";
    $this->printLinks();
  }

}

# Intelligently relink an elements edges for insertion
sub resortJoins {
  my $this = shift;

  my @cluster = ();
  push @cluster, $this;
  my $nextInChain = $this;
  while ( $nextInChain->getLeftLinkedHit() ) {
    $nextInChain = $nextInChain->getLeftLinkedHit();
    push @cluster, $nextInChain;
  }
  $nextInChain = $this;
  while ( $nextInChain->getRightLinkedHit() ) {
    $nextInChain = $nextInChain->getRightLinkedHit();
    push @cluster, $nextInChain;
  }

  # Sort cluster
  @cluster = sort { $a->comparePositionOrder( $b ) } ( @cluster );

  my $lastAnnot = undef;
  foreach my $annot ( @cluster ) {
    next if ( $annot == $lastAnnot );
    $annot->setLeftLinkedHit( $lastAnnot );
    $annot->setRightLinkedHit( undef );
    if ( $lastAnnot ) {
      $lastAnnot->setRightLinkedHit( $annot );
    }
    $lastAnnot = $annot;
  }

  if ( $DEBUG ) {
    print STDERR "Now look what we did with this thing:\n";
    $this->printLinks();
  }

}

# Intelligently merge $partner information with us.  Then remove
# our partner's links to ready it for removal.
sub mergeSimpleLow {
  my $this    = shift;
  my $partner = shift;

  my $DEBUG = 0;

  if ( $DEBUG ) {
    print STDERR "mergeSimpleLow(): THIS links:\n";
    $this->printLinks();
    print STDERR "mergeSimpleLow(): PARTNER links\n";
    $partner->printLinks();
  }

  # Pick appropriate substitution/insertion/deletion stats for
  # merged element.
  if ( $this->getHitName() eq $partner->getHitName() ) {
    $this->adjustSubstLevel( $partner, "noQueryOverlapAdj" );
    $this->setSW( $partner->getSW() )
        if ( $this->getSW() < $partner->getSW() );
  }
  else {
    if ( $this->getSW() < $partner->getSW() ) {
      $this->setPctSubst( $partner->getPctSubst() );
      $this->setPctDelete( $partner->getPctDelete() );
      $this->setPctInsert( $partner->getPctInsert() );
      $this->setSW( $partner->getSW() );
      $this->setSeq2Name( $partner->getSeq2Name() );
    }    # else....keep ours
  }

  # Pick the lower query begin position
  $this->setSeq1Beg( $partner->getSeq1Beg() )
      if ( $this->getSeq1Beg() > $partner->getSeq1Beg() );

  # Pick the higher query end position
  if ( $this->getSeq1End() < $partner->getSeq1End() ) {
    $this->setSeq1End( $partner->getSeq1End() );
    $this->setLeftOver( $partner->getLeftOver() );
  }

  my $newQuerySize = $this->getSeq1End() - $this->getSeq1Beg() + 1;
  my $newSeq2End   =
      $newQuerySize + ( $this->getPctDelete() - $this->getPctInsert() ) *
      $newQuerySize / 100;
  $this->setSeq2Beg( 1 );
  $this->setSeq2End( sprintf( "%d", $newSeq2End ) );

  ## TODO: What happens when our partner has joins that
  ##       should point to the new merger?
  $partner->removeFromJoins();

  if ( $DEBUG ) {
    print STDERR "mergeSimpleLow(): Final THIS links:\n";
    $this->printLinks();
    print STDERR "mergeSimpleLow(): Leaving\n";
  }

}

# Intelligently merge $partner information with us.  Then remove
# our partner's links to ready it for removal.
sub merge {
  my $this    = shift;
  my $partner = shift;

  my $DEBUG = 0;

  if ( $DEBUG ) {
    print STDERR "merge(): Entered\n";
    print STDERR "merge(): THIS links:\n";
    $this->printLinks();
    print STDERR "merge(): PARTNER links\n";
    $partner->printLinks();
  }

  # Pick appropriate substitution/insertion/deletion stats for
  # merged element.
  $this->adjustSubstLevel( $partner );

  # Pick the lower query begin position
  $this->setSeq1Beg( $partner->getSeq1Beg() )
      if ( $this->getSeq1Beg() > $partner->getSeq1Beg() );

  # Pick the higher query end position
  if ( $this->getSeq1End() < $partner->getSeq1End() ) {
    $this->setSeq1End( $partner->getSeq1End() );
    $this->setLeftOver( $partner->getLeftOver() );
  }

  # Find the lower consensus begin position
  my $minBeg = $partner->getSeq2Beg();
  $minBeg = $this->getSeq2Beg()
      if ( $this->getSeq2Beg() < $minBeg );

  # Find the higher consensus end position
  my $maxEnd = $partner->getSeq2End();
  $maxEnd = $this->getSeq2End()
      if ( $this->getSeq2End() > $maxEnd );

  # Sanity check consensus position choices. If
  # the hybrid range ( lowest begin & highest end ) of
  # the two elements is > 2* query length then
  # use the original range of the higher scoring
  # element instead of the hybrid.
  if ( ( $maxEnd - $minBeg + 1 ) >
       ( 2 * ( $this->getSeq1End() - $this->getSeq1Beg() + 1 ) ) )
  {

    # Use the highest scoring annotation's range
    if ( $this->getSW() < $partner->getSW() ) {
      $this->setSeq2Beg( $partner->getSeq2Beg() );
      $this->setSeq2End( $partner->getSeq2End() );
      $this->set3PrimeUnaligned( $partner->get3PrimeUnaligned() );
    }
  }
  else {

    # Use a hybrid range
    $this->setSeq2Beg( $minBeg );
    if ( $this->getSeq2End() < $partner->getSeq2End() ) {
      $this->setSeq2End( $maxEnd );
      $this->set3PrimeUnaligned( $partner->get3PrimeUnaligned() );
    }
  }

  # Use the higher score and it's associated consensus name
  if ( $this->getSW() < $partner->getSW() ) {
    $this->setSW( $partner->getSW() );
    $this->setSeq2Name( $partner->getSeq2Name() );
  }

  $partner->removeFromJoins();

  if ( $DEBUG ) {
    print STDERR "merge(): Final THIS links:\n";
    $this->printLinks();
    print STDERR "merge(): Leaving\n";
  }

}

# Adjust the current element's divergence characteristics based
# on the overlap between it and a past element ( j ). If $ignorediv
# is set simply set the current to the past element -- note this
# is possibly not needed anymore.
sub getAdjustedSubstLevel {
  my $this   = shift;
  my $method = shift;

  my $DEBUG = 0;
  if ( $DEBUG ) {
    print STDERR "getAdjustSubstLevel( $this, $method ): Entered\n";
  }

  warn "getAjustedSubstLevel(): Unknown method $method"
      if ( defined $method && $method !~ /usePartnerStats|noQueryOverlapAdj/ );

  my $partner = undef;
  if (    $this->getLeftLinkedHit()
       && $this->getQueryOverlap( $this->getLeftLinkedHit() ) > 33 )
  {
    $partner = $this->getLeftLinkedHit();
  }
  if (    $this->getRightLinkedHit()
       && $this->getQueryOverlap( $this->getRightLinkedHit() ) > 33 )
  {
    warn "getAdjustedSubstLevel(): Strange...overlaps on both sides!"
        if ( $partner );
    $partner = $this->getRightLinkedHit();
  }

  if ( $partner ) {
    my $subBases;
    my $thisLength    = $this->getSeq1End() - $this->getSeq1Beg() + 1;
    my $partnerLength = $partner->getSeq1End() - $partner->getSeq1Beg() + 1;
    my $qo            = 0;
    $qo = $this->getQueryOverlap( $partner )
        unless ( $method eq "noQueryOverlapAdj" );
    print STDERR "getAdjustedSubstLevel(): qo = $qo "
        . "thisLength = $thisLength, "
        . "partnerLength = $partnerLength\n"
        if ( $DEBUG );
    if ( $this->getPctSubst() <= $partner->getPctSubst() ) {
      $subBases =
          $thisLength * $this->getPctSubst() + ( $partnerLength - $qo ) *
          $partner->getPctSubst();
    }
    else {
      $subBases =
          $partnerLength * $partner->getPctSubst() + ( $thisLength - $qo ) *
          $this->getPctSubst();
    }

    my $totalLength = $thisLength + $partnerLength - $qo;
    $totalLength = 1 if $totalLength < 1;
    return ( sprintf( "%0.2f", ( $subBases / $totalLength ) ) );
  }
  return ( $this->getPctSubst() );
}

# Adjust the current element's divergence characteristics based
# on the overlap between it and a past element ( j ). If $ignorediv
# is set simply set the current to the past element -- note this
# is possibly not needed anymore.
sub adjustSubstLevel {
  my $this    = shift;
  my $partner = shift;
  my $method  = shift;

  my $DEBUG = 0;
  if ( $DEBUG ) {
    print STDERR "adjustSubstLevel( $this, $partner, $method ): Entered\n";
    $this->print();
    $partner->print();
  }

  warn "adjustSubstLevel(): Unknown method $method"
      if ( defined $method && $method !~ /usePartnerStats|noQueryOverlapAdj/ );

  ## Used to be called "ignorediv" which was used for
  ## falsely extended L1 ORF2 fragments???
  if ( defined $method && $method eq "usePartnerStats" ) {
    $this->setPctSubst( $partner->getPctSubst() );
    $this->setPctDelete( $partner->getPctDelete() );
    $this->setPctInsert( $partner->getPctInsert() );
  }
  else {

    # For calculation, choose best matching consensus in overlapped region
    my $subBases;
    my $delBases;
    my $insBases;
    my $thisLength    = $this->getSeq1End() - $this->getSeq1Beg() + 1;
    my $partnerLength = $partner->getSeq1End() - $partner->getSeq1Beg() + 1;
    my $qo            = 0;
    $qo = $this->getQueryOverlap( $partner )
        unless ( $method eq "noQueryOverlapAdj" );
    my $co = $this->getConsensusOverlap( $partner );
    print STDERR "adjustSubstLevel(): qo = $qo, co = $co, "
        . "thisLength = $thisLength, "
        . "partnerLength = $partnerLength\n"
        if ( $DEBUG );

    if ( $this->getPctSubst() <= $partner->getPctSubst() ) {
      $subBases =
          $thisLength * $this->getPctSubst() + ( $partnerLength - $qo ) *
          $partner->getPctSubst();
      $delBases =
          $thisLength * $this->getPctDelete() + ( $partnerLength - $qo ) *
          $partner->getPctDelete();
      $insBases =
          $thisLength * $this->getPctInsert() + ( $partnerLength - $qo ) *
          $partner->getPctInsert();
    }
    else {
      $subBases =
          $partnerLength * $partner->getPctSubst() + ( $thisLength - $qo ) *
          $this->getPctSubst();
      $delBases =
          $partnerLength * $partner->getPctDelete() + ( $thisLength - $qo ) *
          $this->getPctDelete();
      $insBases =
          $partnerLength * $partner->getPctInsert() + ( $thisLength - $qo ) *
          $this->getPctInsert();
    }

    # Include the query or consensus gap in $PctInsert or $PctDelete
    # Expressed in percent (not bases)
    if ( $qo <= 10 && $method ne "noQueryOverlapAdj" ) {
      if ( $co - $qo > 0 ) {
        $insBases += ( $co - $qo ) * 100;
      }
      else {
        $delBases -= ( $co - $qo ) * 100;
      }
    }

    my $totalLength = $thisLength + $partnerLength - $qo;
    $totalLength = 1 if $totalLength < 1;

    print STDERR "adjustSubstLevel(): subBases=$subBases, delBases=$delBases"
        . ", insBases=$insBases, totalLength = $totalLength\n"
        if ( $DEBUG );

    $this->setPctSubst( sprintf( "%0.2f",  ( $subBases / $totalLength ) ) );
    $this->setPctDelete( sprintf( "%0.2f", ( $delBases / $totalLength ) ) );
    $this->setPctInsert( sprintf( "%0.2f", ( $insBases / $totalLength ) ) );
  }
}

sub comparePositionOrder {
  my $this       = shift;
  my $refElement = shift;

  # Am I on the left or right of the reference?
  return ( $this->getSeq1Name() ) cmp( $refElement->getSeq1Name() )
      || ( $this->getSeq1Beg() ) <=>       ( $refElement->getSeq1Beg() )
      || ( $refElement->getSeq1End() ) <=> ( $this->getSeq1End() )
      || ( $refElement->getSW() ) <=>      ( $this->getSW() );
}

#
# Tests if this current element is joined
# so that it "contains" the refElement.
#
#
#      +-------------------------------------+
#      |                                     |
#   -------  ..  --refElement---  ..   ---this----
#
#  or
#
#      +-------------------------------------+
#      |                                     |
#   --this---  ..  --refElement---  ..   --------
#
sub containsElement {
  my $this       = shift;
  my $refElement = shift;

  # Am I on the left or right of the reference?
  if ( $this->comparePositionOrder( $refElement ) > 0 ) {

    # I am on the right
    my $leftLink = $this->getLeftLinkedHit();
    return 0 if ( $leftLink == undef );
    return 1 if ( $leftLink->comparePositionOrder( $refElement ) < 0 );
  }
  else {

    # I am on the left
    my $rightLink = $this->getRightLinkedHit();
    return 0 if ( $rightLink == undef );
    return 1 if ( $rightLink->comparePositionOrder( $refElement ) > 0 );
  }
}

sub getConsensusGap {
  my $this    = shift;
  my $partner = shift;
  return ( -$this->getConsensusOverlap( $partner ) );
}

sub getConsensusOverlap {
  my $this    = shift;
  my $partner = shift;

  warn "getConsensusOverlap() mismatched orientations!\n"
      if ( $this->getRevComp() != $partner->getRevComp() );

  my $left  = $this;
  my $right = $partner;
  if ( $left->comparePositionOrder( $right ) > 0 ) {

    # I am on the right
    $left  = $partner;
    $right = $this;
  }

  if ( $this->getRevComp() eq "C" ) {

    #                      0
    # <--left--, <--right---
    #
    return ( $right->getSeq2End() - $left->getSeq2Beg() + 1 );
  }
  else {

    # 0
    # --left-->, --right-->
    #
    return ( $left->getSeq2End() - $right->getSeq2Beg() + 1 );
  }
}

sub getQueryGap {
  my $this    = shift;
  my $partner = shift;
  return ( -$this->getQueryOverlap( $partner ) );
}

sub getQueryOverlap {
  my $this    = shift;
  my $partner = shift;

  my $sign = 1;
  $sign = -1
      if (    $this->getSeq1Beg() > $partner->getSeq1End()
           || $partner->getSeq1Beg > $this->getSeq1End() );

  my $left = $this->getSeq1Beg();
  $left = $partner->getSeq1Beg()
      if ( $partner->getSeq1Beg() > $left );
  my $right = $this->getSeq1End();
  $right = $partner->getSeq1End()
      if ( $partner->getSeq1End() < $right );
  return ( abs( $right - $left + 1 ) * $sign );

}

package main;
